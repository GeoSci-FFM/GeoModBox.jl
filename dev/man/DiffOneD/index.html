<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1D · GeoModBox.jl</title><meta name="title" content="1D · GeoModBox.jl"/><meta property="og:title" content="1D · GeoModBox.jl"/><meta property="twitter:title" content="1D · GeoModBox.jl"/><meta name="description" content="Documentation for GeoModBox.jl."/><meta property="og:description" content="Documentation for GeoModBox.jl."/><meta property="twitter:description" content="Documentation for GeoModBox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeoModBox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Governing Equation</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Solution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GESolution/">General</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Heat Diffusion Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DiffMain/">General</a></li><li class="is-active"><a class="tocitem" href>1D</a><ul class="internal"><li><a class="tocitem" href="#Discretization-and-Numerical-Schemes"><span>Discretization and Numerical Schemes</span></a></li><li><a class="tocitem" href="#Variable-Thermal-Parameters"><span>Variable Thermal Parameters</span></a></li></ul></li><li><a class="tocitem" href="../DiffTwoD/">2D</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Momentum Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../MomentumMain/">General</a></li><li><a class="tocitem" href="../MomentumOneD/">1D</a></li><li><a class="tocitem" href="../MomentumTwoD/">2D</a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Examples/">Overview</a></li><li><a class="tocitem" href="../OceanicGeotherm/">Oceanic Geotherm</a></li></ul></li><li><a class="tocitem" href="../listoffunctions/">List of functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Governing Equation</a></li><li><a class="is-disabled">Heat Diffusion Equation</a></li><li class="is-active"><a href>1D</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1D</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GeoSci-FFM/GeoModBox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/docs/src/man/DiffOneD.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Temperature-Equation-(1D)"><a class="docs-heading-anchor" href="#Temperature-Equation-(1D)">Temperature Equation (1D)</a><a id="Temperature-Equation-(1D)-1"></a><a class="docs-heading-anchor-permalink" href="#Temperature-Equation-(1D)" title="Permalink"></a></h1><p>In one dimension, the conductive component of the <em>temperature equation</em> is given by (assuming only radiogenic heat sources):</p><p class="math-container">\[\begin{equation}
\frac{\partial T}{\partial t} = -\frac{\partial q_x}{\partial x} + \rho H.
\end{equation}\]</p><p>Incorporating Fourier’s law, and allowing for spatially variable thermal properties, the equation becomes:</p><p class="math-container">\[\begin{equation}
\frac{\partial T}{\partial t} = \frac{\partial}{\partial x} k_x \frac{\partial T}{\partial x} + \rho H. 
\end{equation}\]</p><p>Assuming constant thermal properties, Equation (2) simplifies to:</p><p class="math-container">\[\begin{equation}
\frac{\partial T}{\partial t} = \kappa \frac{\partial^2 T}{\partial x^2} + \frac{Q}{\rho c_p},
\end{equation}\]</p><p>where <span>$\kappa = k/\rho/c_p$</span> is the thermal diffusivity [m²/s], and <span>$Q = \rho H$</span> is the volumetric heat production rate [W/m³].  </p><p>Equation (3) is a <em>parabolic partial differential equation</em> (PDE), which can be solved numerically given appropriate initial and boundary conditions.</p><h2 id="Discretization-and-Numerical-Schemes"><a class="docs-heading-anchor" href="#Discretization-and-Numerical-Schemes">Discretization and Numerical Schemes</a><a id="Discretization-and-Numerical-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization-and-Numerical-Schemes" title="Permalink"></a></h2><p>To numerically solve Equation (3), the spatial domain must be discretized and physical parameters assigned to their corresponding locations on the grid.  </p><blockquote><p><strong>Note</strong>: Although the thermal conductivity is assumed constant for now, we adopt a <em>conservative gridding</em> approach to ensure physical consistency. In this scheme, temperature <span>$T$</span> is defined at <strong>cell centers</strong> (centroids), while heat flux <span>$q$</span> is defined at <strong>cell interfaces</strong> (vertices).</p></blockquote><p><img src="../../assets/Diff_1D_Discretization.png" alt="1DDiscretization"/></p><p><strong>Figure 1. 1D Discretization.</strong> Conservative finite difference grid used to solve the 1D conductive part of the temperature equation. Temperature is defined at centroids and heat flux at vertices. <em>Ghost nodes</em> are introduced to implement <em>Dirichlet</em> and <em>Neumann</em> boundary conditions.</p><p>The example script <a href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/1D/Heat_1D_discretization.jl">Heat<em>1D</em>discretization.jl</a> demonstrates various numerical schemes for solving the conductive part of the temperature equation, including <em>explicit</em>, <em>implicit</em>, <em>Crank–Nicolson</em>, and <em>defect correction</em> methods. Below, we briefly describe these well-known schemes and highlight their strengths and limitations.</p><h3 id="Explicit-Finite-Difference-Scheme-(FTCS;-Forward-Euler)"><a class="docs-heading-anchor" href="#Explicit-Finite-Difference-Scheme-(FTCS;-Forward-Euler)">Explicit Finite Difference Scheme (FTCS; Forward Euler)</a><a id="Explicit-Finite-Difference-Scheme-(FTCS;-Forward-Euler)-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Finite-Difference-Scheme-(FTCS;-Forward-Euler)" title="Permalink"></a></h3><p>A basic and intuitive approach to solving the 1D heat conduction equation is the <strong>Forward in Time and Centered in Space (FTCS)</strong> scheme, implemented in an <strong>explicit</strong> manner.</p><p>This method approximates the continuous PDE on a discrete grid and converges toward the analytical solution as the spatial (<span>$\Delta x$</span>) and temporal (<span>$\Delta t$</span>) resolutions become sufficiently small. Its main advantages are <strong>simplicity</strong> and <strong>computational efficiency</strong>.</p><p>However, the FTCS scheme is <strong>conditionally stable</strong>. Its stability is governed by the <em>heat diffusion stability criterion</em>, which can be derived via <em>Von Neumann</em> analysis. This assesses how numerical perturbations grow or decay over time.</p><p>For a uniform grid, the stability condition is:</p><p class="math-container">\[\begin{equation}
\Delta t &lt; \frac{\Delta{x^2}}{2 \kappa}.
\end{equation}\]</p><p>Thus, the maximum time step is limited by the grid spacing.</p><p>Discretizing Equation (3) with the FTCS scheme gives:</p><p class="math-container">\[\begin{equation}
\frac{T_{i}^{n+1} - T_{i}^{n} }{\Delta t} = \kappa \frac{T_{i-1}^{n} - 2T_{i}^{n} + T_{i+1}^{n}}{\Delta{x^2}} + \frac{Q_{i}^n}{\rho c_p},
\end{equation}\]</p><p>where  <span>$i$</span> is the spatial grid index, <span>$n$</span> is the time step index, <span>$\Delta x$</span> is the grid spacing, <span>$\Delta t$</span> is the time step, and <span>$Q_i^n$</span> is the heat production rate at node <span>$i$</span> and time <span>$n$</span>.</p><p>Solving for <span>$T_i^{n+1}$</span>:</p><p class="math-container">\[\begin{equation}
T_{i}^{n+1} = T_{i}^{n} + a \left(T_{i-1}^{n} - 2T_{i}^{n} + T_{i+1}^{n} \right) + \frac{Q_{i}^n \Delta t}{\rho c_p}, 
\end{equation}\]</p><p>where <span>$a = \frac{\kappa \Delta t}{\Delta x^2}$</span>.</p><p>Equation (6) is solved for all interior nodes at each time step, assuming initial and boundary conditions are specified.</p><p>For implementation details, see the <a href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/src/HeatEquation/1Dsolvers.jl">source code</a>.</p><h3 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h3><p>Boundary conditions are implemented using ghost nodes. Here, we consider the two most common thermal boundary conditions: Dirichlet and Neumann.</p><p><strong>Dirichlet Boundary Condition</strong></p><p>The Dirichlet condition specifies a fixed temperature at the boundary. The temperature at the left (West) and right (East) ghost nodes is given by:</p><p class="math-container">\[\begin{equation}
T_{G,W} = 2T_{BC,W} - T_{1},
\end{equation}\]</p><p class="math-container">\[\begin{equation}
T_{G,E} = 2T_{BC,E} - T_{nc},
\end{equation}\]</p><p>where  <span>$T_{BC,W}$</span> and <span>$T_{BC,E}$</span> are the prescribed boundary temperatures, <span>$T_1$</span> and <span>$T_{nc}$</span> are the temperatures at the first and last interior centroids, <span>$T_{G,W}$</span> and <span>$T_{G,E}$</span> are the ghost node temperatures on the west and east boundaries, and <span>$nc$</span> is the number of centroids.</p><p><strong>Neumann Boundary Condition</strong></p><p>The Neumann condition specifies a fixed gradient (e.g., a heat flux or temperature gradient) at the boundary. The ghost node temperatures are defined as:</p><p class="math-container">\[\begin{equation}
T_{G,W} = T_{1} - c_{W} \Delta{x},
\end{equation}\]</p><p class="math-container">\[\begin{equation}
T_{G,E} = T_{nc} + c_{E} \Delta{x},
\end{equation}\]</p><p>with:  </p><p class="math-container">\[\begin{equation}
\left. c_{W} = \frac{\partial{T}}{\partial{x}} \right\vert_{W},\ \textrm{and}\ \left. c_{E} = \frac{\partial{T}}{\partial{x}} \right\vert_{E}, 
\end{equation}\]</p><p>where <span>$c_W$</span> and <span>$c_E$</span> are the prescribed temperature gradients on the west and east boundaries, respectively.</p><p>These ghost node definitions are substituted into the numerical scheme to enforce boundary conditions at each time step.</p><h3 id="Implicit-Scheme-(Backward-Euler)"><a class="docs-heading-anchor" href="#Implicit-Scheme-(Backward-Euler)">Implicit Scheme (Backward Euler)</a><a id="Implicit-Scheme-(Backward-Euler)-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Scheme-(Backward-Euler)" title="Permalink"></a></h3><p>The fully implicit finite difference scheme, also known as the <strong>Backward Euler</strong> method, is <strong>unconditionally stable</strong>, allowing time steps larger than those permitted by the diffusion stability criterion.</p><p>In 1D, the temperature equation becomes:</p><p class="math-container">\[\begin{equation}
\frac{T_{i}^{n+1}-T_{i}^n}{\Delta t} = \kappa \frac{T_{i-1}^{n+1}-2T_{i}^{n+1}+T_{i+1}^{n+1}}{\Delta{x^2}} + \frac{Q_{i}^n}{\rho c_p},
\end{equation}\]</p><p>where  <span>$i$</span> is the spatial index, <span>$n$</span> and <span>$n+1$</span> are the current and next time steps, <span>$\Delta t$</span> is the time step, and <span>$\Delta x$</span> is the spatial grid spacing. </p><p>Rearranging into known (right-hand side) and unknown (left-hand side) terms yields a linear system:</p><p class="math-container">\[\begin{equation}
-a T_{i-1}^{n+1} + \left(2a + b \right) T_{i}^{n+1} - a T_{i+1}^{n+1} = b T_{i}^n + \frac{Q_{i}^n}{\rho c_p},
\end{equation}\]</p><p>with  <span>$a = \dfrac{\kappa}{\Delta x^2}$</span> and <span>$b = \dfrac{1}{\Delta t}$</span>.</p><p>This equation results in a tridiagonal system of the form:</p><p class="math-container">\[\begin{equation}
\mathbf{A} \cdot \overrightharpoon{x} = \overrightharpoon{\text{rhs}}
\end{equation}\]</p><p>where <span>$\mathbf{A}$</span> is the coefficient matrix (with three non-zero diagonals), <span>$\overrightharpoon{x}$</span> is the unknown temperature vector at time <span>$n+1$</span>, and <span>$\overrightharpoon{\text{rhs}}$</span> is the known right-hand side.</p><p>The coefficients are arranged to match the matrix structure used in the <em>defect correction</em> method, preserving modularity.</p><blockquote><p><strong>Note</strong>: While the implicit method is unconditionally stable, very large time steps may still yield inaccurate results, particularly for resolving small-scale thermal gradients.</p></blockquote><h3 id="Boundary-Conditions-2"><a class="docs-heading-anchor" href="#Boundary-Conditions-2">Boundary Conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-2" title="Permalink"></a></h3><p>The temperature at ghost nodes is defined as before (see Equations (7)-(10)). However, to maintain symmetry in the coefficient matrix and ensure consistent discretization near boundaries, both the <strong>matrix coefficients</strong> and the <strong>right-hand side</strong> must be modified for the nodes adjacent to the boundaries.</p><p><strong>Dirichlet Boundary Condition</strong></p><p><strong>West boundary</strong></p><p class="math-container">\[\begin{equation}
\left(3 a + b\right) T_{1}^{n+1} - a T_{2}^{n+1} = b T_{1}^{n} + 2 a T_{BC,W},
\end{equation}\]</p><p><strong>East boundary</strong></p><p class="math-container">\[\begin{equation}
-a T_{nc-1}^{n+1} + \left(3 a + b\right) T_{nc}^{n+1}  = b T_{nc}^{n} + 2 a T_{BC,E}, 
\end{equation}\]</p><p><strong>Neumann Boundary Condition</strong></p><p><strong>West boundary</strong></p><p class="math-container">\[\begin{equation}
\left(a + b\right) T_{1}^{n+1} - a T_{2}^{n+1} = b T_{1}^{n} - a c_{W} \Delta{x},
\end{equation}\]</p><p><strong>East boundary</strong></p><p class="math-container">\[\begin{equation}
-a T_{nc-1}^{n+1} + \left(a + b\right) T_{nc}^{n+1}  = b T_{nc}^{n} + a c_{E} \Delta{x}, 
\end{equation}\]</p><p>where  <span>$T_{BC,W}$</span>, <span>$T_{BC,E}$</span> are the prescribed boundary temperatures, <span>$c_W$</span>, <span>$c_E$</span> are the prescribed temperature gradients at the west and east boundaries, and <span>$nc$</span> is the number of centroids.</p><p>These adjustments ensure that the boundary conditions are enforced consistently while preserving the symmetry and stability of the implicit solver.</p><h3 id="Defect-Correction-Method"><a class="docs-heading-anchor" href="#Defect-Correction-Method">Defect Correction Method</a><a id="Defect-Correction-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Defect-Correction-Method" title="Permalink"></a></h3><p>The <strong>defect correction method</strong> is an iterative scheme that progressively reduces the residual of the conductive part of the temperature equation using a correction term. If the system is linear, one iteration is sufficient to obtain the exact solution.</p><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>The conductive part of the temperature equation, in implicit form, can be written as:</p><p class="math-container">\[\begin{equation}
\mathbf{K} \cdot T - b = R, 
\end{equation}\]</p><p>where  <span>$\mathbf{K}$</span> is the coefficient matrix, <span>$T$</span> is the temperature at the new time step, <span>$b$</span> is a known term that includes contributions from the previous time step and internal heat sources, and <span>$R$</span> is the residual (or defect).</p><p>Given an initial temperature guess <span>$T_i$</span>, the residual is:</p><p class="math-container">\[\begin{equation}
R_i = \mathbf{K} \cdot T_i - b.
\end{equation}\]</p><p>To reduce the residual, we define a correction <span>$\delta T$</span> such that:</p><p class="math-container">\[\begin{equation}
0 = \mathbf{K} \left(T_i + \delta{T} \right) - b = \mathbf{K} T_i - b + \mathbf{K} \delta{T} = R_i + \mathbf{K} \delta{T}.
\end{equation}\]</p><p>Rearranging gives: </p><p class="math-container">\[\begin{equation}
R_i = -\mathbf{K} \delta{T}, 
\end{equation}\]</p><p>and hence: </p><p class="math-container">\[\begin{equation}
\delta{T} = -\mathbf{K}^{-1} R_i. 
\end{equation}\]</p><p>Thus, the updated solution becomes: </p><p class="math-container">\[\begin{equation}
T_{i+1} = T_i + \delta T.
\end{equation}\]</p><p>In the linear case, this yields the exact solution in a single step. For nonlinear problems, the process is repeated iteratively until the residual is sufficiently small.</p><h4 id="Coefficient-Matrix"><a class="docs-heading-anchor" href="#Coefficient-Matrix">Coefficient Matrix</a><a id="Coefficient-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficient-Matrix" title="Permalink"></a></h4><p>The matrix <span>$\mathbf{K}$</span> can be derived from the discretized form of the temperature equation:</p><p class="math-container">\[\begin{equation}
\frac{\partial{T}}{\partial{t}} - \kappa \frac{\partial^2{T}}{\partial{x}^2} = R, 
\end{equation}\]</p><p>which discretizes to: </p><p class="math-container">\[\begin{equation}
\frac{T_i^{n+1}-T_i^{n}}{\Delta{t}} - \kappa \frac{T_{i-1}^{n+1} - 2 T_{i}^{n+1} + T_{i+1}^{n+1}}{\Delta{x}^2} = R,
\end{equation}\]</p><p>or equivalently:</p><p class="math-container">\[\begin{equation}
-a T_{i-1}^{n+1} + \left(2 a + b \right) T_{i}^{n+1} - a T_{i+1}^{n+1} - b T_{i}^{n} = R, 
\end{equation}\]</p><p>where:</p><p class="math-container">\[\begin{equation}
a = \frac{\kappa}{\Delta{x}^2},\ \textrm{and} \ b = \frac{1}{\Delta{t}}. 
\end{equation}\]</p><p>This structure defines the coefficients in <span>$\mathbf{K}$</span>.</p><h3 id="Boundary-Conditions-3"><a class="docs-heading-anchor" href="#Boundary-Conditions-3">Boundary Conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-3" title="Permalink"></a></h3><p>As in the implicit FTCS method, the coefficients in <span>$\mathbf{K}$</span> must be adjusted for centroids adjacent to the boundaries (see Equations (14)–(17)). However, <strong>the right-hand side vector <span>$b$</span> remains unchanged</strong> during these modifications.</p><p>This makes the defect correction method efficient and modular, especially when reusing the same matrix structure across iterations or solver variants.</p><h3 id="Crank-Nicolson-approach-(CNA)"><a class="docs-heading-anchor" href="#Crank-Nicolson-approach-(CNA)">Crank-Nicolson approach (CNA)</a><a id="Crank-Nicolson-approach-(CNA)-1"></a><a class="docs-heading-anchor-permalink" href="#Crank-Nicolson-approach-(CNA)" title="Permalink"></a></h3><p>The fully implicit FTCS method is unconditionally stable but only first-order accurate in time. To improve temporal accuracy while retaining stability, the <strong>Crank-Nicolson scheme</strong> can be used. This method employs a time-centered (implicit) discretization and is second-order accurate in time.</p><p>In one dimension, the Crank-Nicolson discretization of the conductive part of the temperature equation (Equation (3)) becomes:</p><p class="math-container">\[\begin{equation}
\frac{T_{i}^{n+1} - T_{i}^{n}}{\Delta t} = \frac{\kappa}{2}\frac{(T_{i-1}^{n+1}-2T_{i}^{n+1}+T_{i+1}^{n+1})+(T_{i-1}^{n}-2T_{i}^{n}+T_{i+1}^{n})}{\Delta{x^2}}. 
\end{equation}\]</p><p>Rearranging into known and unknown terms yields a linear system of the form:</p><p class="math-container">\[\begin{equation}
-aT_{i-1}^{n+1} + \left(b+2a\right)T_{i}^{n+1} - a T_{i+1}^{n+1} = aT_{i-1}^{n} + \left(b-2a\right)T_{i}^{n} + a T_{i+1}^{n},
\end{equation}\]</p><p>where:</p><p class="math-container">\[a = \frac{\kappa}{2\Delta{x^2}}\]</p><p>and <span>$b = \frac{1}{\Delta{t}}$</span>. </p><h3 id="Boundary-Conditions-4"><a class="docs-heading-anchor" href="#Boundary-Conditions-4">Boundary Conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-4" title="Permalink"></a></h3><p>To obtain a symmetric coefficient matrix, both the matrix and the right-hand side vector must be modified at the boundaries. The equations for centroids adjacent to the boundaries are:</p><p><strong>Dirichlet Boundary Conditions</strong></p><p><strong>West boundary</strong></p><p class="math-container">\[\begin{equation}
\left(b + 3 a \right) T_{1}^{n+1} - a T_{2}^{n+1} = \left( b - 3 a \right) T_{1}^{n} + a T_{2}^{n} + 4 a T_{BC,W}
\end{equation}\]</p><p><strong>East boundary</strong></p><p class="math-container">\[\begin{equation}
-a T_{nc-1}^{n+1} + \left(b + 3 a \right) T_{nc}^{n+1} = a T_{nc-1}^{n} + \left( b - 3 a \right) T_{nc}^{n} + 4 a T_{BC,E}
\end{equation}\]</p><p><strong>Neumann Boundary Conditions</strong></p><p><strong>West boundary</strong></p><p class="math-container">\[\begin{equation}
\left(b+a\right)T_{1}^{n+1} - a T_{2}^{n+1} = \left(b-a\right)T_{1}^{n} + a T_{2} - 2ac_{W} \Delta{x}
\end{equation}\]</p><p><strong>East boundary</strong></p><p class="math-container">\[\begin{equation}
-a T_{nc-1}^{n+1} + \left(b+a\right)T_{nc}^{n+1}  = a T_{nc-1}^{n} + \left(b-a\right)T_{nc}^{n} + 2ac_{E} \Delta{x}
\end{equation}\]</p><p>The resulting coefficient matrix remains tridiagonal, preserving computational efficiency. However, memory demands increase with higher resolution models due to the larger size of the linear system, making this method more memory-intensive.</p><p>For implementation details, refer to the <a href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/src/HeatEquation/1Dsolvers.jl">source code</a>.</p><hr/><h3 id="Temperature-Field-Management"><a class="docs-heading-anchor" href="#Temperature-Field-Management">Temperature Field Management</a><a id="Temperature-Field-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Temperature-Field-Management" title="Permalink"></a></h3><p>For the <strong>explicit solver</strong> and the <strong>defect correction method</strong>, the full temperature field—including ghost nodes—is used to evaluate the temperature equation. The old temperature field is assigned to the centroids of the extended grid to compute the new temperature.</p><p>For the <strong>implicit methods</strong> (Backward Euler, Crank-Nicolson), the current temperature at the centroids is assigned to the right-hand side vector. The coefficient matrix is then assembled, and the new temperature is computed by solving the resulting linear system.</p><h3 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h3><p>While the <strong>explicit FTCS scheme</strong> is simple and efficient for small time steps, <strong>implicit methods</strong> like Backward Euler and Crank-Nicolson are preferred for their unconditional stability. The Crank-Nicolson scheme further improves accuracy with its second-order time discretization. The <strong>defect correction method</strong> provides a flexible framework for both linear and nonlinear problems, allowing for iterative refinement when needed.</p><hr/><h2 id="Variable-Thermal-Parameters"><a class="docs-heading-anchor" href="#Variable-Thermal-Parameters">Variable Thermal Parameters</a><a id="Variable-Thermal-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Thermal-Parameters" title="Permalink"></a></h2><p>To solve the conductive part of the 1-D temperature equation with <strong>spatially variable thermal parameters</strong>, a conservative finite difference scheme must be used. In this formulation, temperature is defined at centroids, while heat flux and thermal conductivity are defined at vertices (see Figure 1).</p><p>The governing equation is:</p><p class="math-container">\[\begin{equation}
\rho c_{p} \frac{\partial{T}}{\partial{t}} = \frac{\partial{}}{\partial{y}}\left(k \frac{\partial{T}}{\partial{y}}\right) + \rho H,
\end{equation}\]</p><p>where <span>$\rho$</span> is the density [kg/m³], <span>$c_p$</span> is the specific heat capacity [J/kg/K], <span>$T$</span> is the temperature [K], <span>$t$</span> is the time [s], <span>$k$</span> is the thermal conductivity [W/m/K],  <span>$H$</span> is the internal heat generation rate per unit mass [W/kg], and <span>$y$</span> is the vertical coordinate (depth) [m]</p><h3 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h3><p>In a conservative scheme, the vertical conductive heat flux <span>$q_y$</span> is defined on vertices, as:</p><p class="math-container">\[\begin{equation}
\left. q_{y,m} = -k_m \frac{\partial T}{\partial y}\right\vert_{m},\ \textrm{for}\ m = 1:nv, 
\end{equation}\]</p><p>where <span>$n_v$</span> is the number of <em>vertices</em>.</p><h3 id="Explicit-Finite-Difference-Formulation"><a class="docs-heading-anchor" href="#Explicit-Finite-Difference-Formulation">Explicit Finite Difference Formulation</a><a id="Explicit-Finite-Difference-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Finite-Difference-Formulation" title="Permalink"></a></h3><p>Using the above discretization, the time evolution of temperature at each centroid is computed from:</p><p class="math-container">\[\begin{equation}
\rho_j c_{p,j} \frac{T_{j}^{n+1} - T_{j}^{n}}{\Delta{t}} = -\frac{q_{y,j+1}^{n} - q_{y,j}^{n} }{\Delta{y}} + \rho_j H_j,\ \textrm{for}\ j = 1:nc, 
\end{equation}\]</p><p>where  <span>$T$</span> is evaluated at centroids, <span>$q_y$</span> and <span>$k$</span> are evaluated at vertices, <span>$\Delta t$</span> is the time step, and <span>$\Delta y$</span> is the spatial grid resolution.</p><p>Substituting the expression for <span>$q_y$</span> gives:</p><p class="math-container">\[\begin{equation}
\rho_j c_{p,j} \frac{T_{j}^{n+1} - T_{j}^{n}}{\Delta{t}} = \frac{ k_{j+1} \frac{T_{j+1}^{n} - T_{j}^{n}}{\Delta{y}} - k_{j} \frac{T_{j}^{n} - T_{j-1}^{n}}{\Delta{y}} }{\Delta{y}} + \rho_j H_j.
\end{equation}\]</p><p>Rewriting this into an explicit update formula for <span>$T_j^{n+1}$</span>:</p><p class="math-container">\[\begin{equation}
T_{j}^{n+1} = ak_{j}T_{j-1}^{n} + \left(1-a\left(k_{j+1}+k_{j}\right)\right)T_{j}^{n} + ak_{j+1}T_{j+1}^{n} + \frac{H_j\Delta{t}}{c_{p,j}},
\end{equation}\]</p><p>where:</p><p class="math-container">\[\begin{equation}
a = \frac{\Delta{t}}{\Delta{y^2} \rho c_{p_{j}}}.
\end{equation}\]</p><h3 id="Boundary-Conditions-5"><a class="docs-heading-anchor" href="#Boundary-Conditions-5">Boundary Conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-5" title="Permalink"></a></h3><p>For centroids adjacent to the boundaries, ghost nodes are used to evaluate the temperature gradient consistently with the chosen thermal boundary condition (Dirichlet or Neumann). These ghost node values are computed according to equations (7)–(10).</p><hr/><p>For implementation details, refer to the <a href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/src/HeatEquation/1Dsolvers.jl">source code</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DiffMain/">« General</a><a class="docs-footer-nextpage" href="../DiffTwoD/">2D »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Saturday 31 May 2025 08:10">Saturday 31 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
