<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gaussian Diffusion (2D) · GeoModBox.jl</title><meta name="title" content="Gaussian Diffusion (2D) · GeoModBox.jl"/><meta property="og:title" content="Gaussian Diffusion (2D) · GeoModBox.jl"/><meta property="twitter:title" content="Gaussian Diffusion (2D) · GeoModBox.jl"/><meta name="description" content="Documentation for GeoModBox.jl."/><meta property="og:description" content="Documentation for GeoModBox.jl."/><meta property="twitter:description" content="Documentation for GeoModBox.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GeoModBox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Governing Equation</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Solution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../GESolution/">General</a></li><li><a class="tocitem" href="../../Ini/">Initial Condition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Heat Diffusion Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DiffMain/">General</a></li><li><a class="tocitem" href="../../DiffOneD/">1D</a></li><li><a class="tocitem" href="../../DiffTwoD/">2D</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Advection Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AdvectMain/">General</a></li><li><a class="tocitem" href="../../AdvOneD/">1D</a></li><li><a class="tocitem" href="../../AdvTwoD/">2D</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Momentum Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../MomentumMain/">General</a></li><li><a class="tocitem" href="../../MomentumOneD/">1D</a></li><li><a class="tocitem" href="../../MomentumTwoD/">2D</a></li></ul></li></ul></li><li><span class="tocitem">Exercises</span><ul><li><a class="tocitem" href="../../Exercises/">General</a></li><li><a class="tocitem" href="../../exercises/01_Euler_Advection/">01 - Euler Advection</a></li><li><a class="tocitem" href="../../exercises/02_1D_Heat_explicit/">02 - 1D Heat Diffusion (explicit)</a></li><li><a class="tocitem" href="../../exercises/03_1D_Heat_implicit/">03 - 1D Heat Diffusion (implicit)</a></li><li><a class="tocitem" href="../../exercises/04_2D_Diffusion_Stationary/">04 - 2D Heat Diffusion (stationary)</a></li><li><a class="tocitem" href="../../exercises/05_2D_Diffusion_TD_Plume/">05a - 2D Heat Diffusion (Plume)</a></li><li><a class="tocitem" href="../../exercises/05_2D_Diffusion_TD_Sill/">05b - 2D Heat Diffusion (Sill)</a></li><li><a class="tocitem" href="../../exercises/06_1D_Advection/">06 - 1D Advection</a></li><li><a class="tocitem" href="../../exercises/07_2D_Energy_Equation/">07 - 2D Energy Conservation</a></li><li><a class="tocitem" href="../../exercises/08_1D_Stokes/">08 - 1D Stokes</a></li><li><a class="tocitem" href="../../exercises/09_2D_Falling_Block/">09 - 2D Falling Block (steady state)</a></li><li><a class="tocitem" href="../../exercises/10_2D_Falling_Block_td/">10 - 2D Falling Block (time-dep)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../Examples/">General</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Diffusion Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../OceanicGeotherm/">Oceanic Geotherm (1D)</a></li><li><a class="tocitem" href="../ContinentalGeotherm/">Continental Geotherm (1D)</a></li><li><a class="tocitem" href="../GaussianDiffusion1D/">Gaussian Diffusion (1D)</a></li><li><a class="tocitem" href="../BackwardEuler_DC/">Backward Euler (2D)</a></li><li><a class="tocitem" href="../ForwardEuler_DC/">Forward Euler (2D)</a></li><li class="is-active"><a class="tocitem" href>Gaussian Diffusion (2D)</a></li><li><a class="tocitem" href="../PoissonRestest/">Poisson Problem (2D)</a></li><li><a class="tocitem" href="../PoissonVariablek/">Poisson Problem; variable k (2D)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Advection Equtaion</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Advection2D/">Advection (2D)</a></li><li><a class="tocitem" href="../AdvectionRestest2D/">Advection Resolution Test (2D)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Stokes Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ChannelFlow1D/">Channel Flow (1D)</a></li><li><a class="tocitem" href="../FallingBlockBenchmark/">Falling Block Benchmark</a></li><li><a class="tocitem" href="../FallingBlockDC/">Falling Block</a></li><li><a class="tocitem" href="../RTI/">Rayleigh Taylor Instability (RTI)</a></li><li><a class="tocitem" href="../RTI_growth_rate/">RTI - Growth Rate</a></li><li><a class="tocitem" href="../ViscousInclusion/">Viscous Inclusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Mixed Thermal Convection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BottomHeatedConvection/">Bottom Heated</a></li><li><a class="tocitem" href="../InternallyHeatedConvection/">Internally Heated</a></li><li><a class="tocitem" href="../MixedHeatedConvection/">Mixed Heated</a></li></ul></li></ul></li><li><a class="tocitem" href="../../listoffunctions/">List of functions</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Diffusion Equation</a></li><li class="is-active"><a href>Gaussian Diffusion (2D)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gaussian Diffusion (2D)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GeoSci-FFM/GeoModBox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/docs/src/man/examples/GaussianDiffusion2D.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="[Gaussian-Diffusion-(2D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Gaussian_Diffusion.jl)"><a class="docs-heading-anchor" href="#[Gaussian-Diffusion-(2D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Gaussian_Diffusion.jl)"><a href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Gaussian_Diffusion.jl">Gaussian Diffusion (2D)</a></a><a id="[Gaussian-Diffusion-(2D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Gaussian_Diffusion.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[Gaussian-Diffusion-(2D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Gaussian_Diffusion.jl)" title="Permalink"></a></h1><p>This example performs a resolution test for various finite difference discretization schemes applied to the 2-D temperature conservation equation, assuming constant thermal parameters and neglecting adiabatic pressure effects (i.e., a simple diffusion problem) using a Gaussian temperature anomaly.</p><p>The following discretization schemes are employed: </p><ul><li>Forward Euler</li><li>Backward Euler</li><li>Crank-Nicolson</li><li>Alternating-Direction Implicit</li><li>Defect Correction</li></ul><p>As the initial condition, a Gaussian temperature distribution with a specified width and amplitude is prescribed, centered at the midpoint of the 2-D model domain. The transient behavior of this temperature distribution can be described analytically. Thus, one can calculate the accuracy for each time step of each finite difference scheme using this analytical solution. </p><p>The 2-D analytical solution is computed using the Julia package <code>ExactFieldSolutions</code>. Using the analytical solution, the thermal boudnary conditions are updated for each time step. </p><p>For simplicity, the 2-D temperature conservation equation is solved independently for each discretization scheme over time. After each time loop, the transient solution is visualized and saved as a <em>gif</em> animation showing the temperature distribution, it&#39;s absolute deviation from the analytical solution, a vertical profile through the center of the model domain, and the RMS. </p><p>For more details on the different numerical discretization schemes, please see the <a href="../../DiffTwoD/">documentation</a>.</p><hr/><p>First one needs to load the required packages: </p><pre><code class="language-Julia hljs">using Plots, GeoModBox.HeatEquation.TwoD, ExtendableSparse
using Statistics, Printf, LinearAlgebra</code></pre><p>Now, let&#39;s define an array which includes the names of the different numerical schemes to be used. In the following, a loop is executed in which the individual scheme is called in the very beginning (via an if statement). Also, a mulitplication factor <code>nrnxny</code> is defined, which controlls the maximum resolution, that is <code>nrnxny*20</code>. </p><p>Within in each loop over the different numerical scheme, the resolution is consecutively increased up to the maximum defined resolution.</p><p>If <code>save_fig = -1</code>, only the final plot for the resolution test is shown and stored. For <code>save_fig = 0</code> all fields are plotted, but not stored, and for <code>save_fig = 1</code> the transient behavior for each resolution of each numerical scheme is stored in a <em>gif</em> animation. </p><pre><code class="language-Julia hljs">Schema  =   [&quot;explicit&quot;,&quot;implicit&quot;,&quot;CNA&quot;,&quot;ADI&quot;,&quot;dc&quot;]
# Schema      =   [&quot;ADI&quot;]
ns          =   size(Schema,1)
nrnxny      =   6
save_fig    =   -1</code></pre><p>Now, one needs to define the geometrical and physical parameters for the problem. </p><pre><code class="language-Julia hljs"># Physical Parameters ------------------------------------------------ #
P       = ( 
    L       =   200e3,          #   Length [ m ]
    H       =   200e3,          #   Height [ m ]
    k       =   3,              #   Thermal Conductivity [ W/m/K ]
    cp      =   1000,           #   Specific Heat Capacity [ J/kg/K ]
    ρ       =   3200,           #   Density [ kg/m^3 ]
    K0      =   273.15,         #   Kelvin at 0 °C
    Q0      =   0               #   Heat production rate
)
P1      = (
    κ       =   P.k/P.ρ/P.cp,   #   Thermal Diffusivity [ m^2/s ] 
    Tamp    =   500,            #   Temperaturamplitude [K]
    σ       =   20e3,           #   
    Xc      =   0.0,            #   x-Coordinate of the Anomalycenter
    Zc      =   0.0             #   y-Coordinate of the Anomalycenter
)
P       =   merge(P,P1)
# -------------------------------------------------------------------- #</code></pre><p>Here, the arrays for the resolution test are initialized. </p><pre><code class="language-Julia hljs"># Statistical Parameter ---------------------------------------------- #
St      = (
    ε           =   zeros(size(Schema,1),nrnxny),    
    nxny        =   zeros(size(Schema,1),nrnxny),
    Tmax        =   zeros(size(Schema,1),nrnxny),
    Tmean       =   zeros(size(Schema,1),nrnxny),
    Tanamax     =   [0.0],
    Tanamean    =   [0.0]
)
# -------------------------------------------------------------------- #</code></pre><p>Now, one can start the loop over the different numerical discretization schemes (<code>m</code>) and over the different resolutions (<code>l</code>). </p><pre><code class="language-Julia hljs"># Loop over different discretization schemes ------------------------- #
for m = 1:ns
    FDSchema = Schema[m]
    display(FDSchema)
    for l = 1:nrnxny</code></pre><p>Within these loops, one needs to refine the grid parameter. </p><pre><code class="language-Julia hljs">        # Numerical Parameters --------------------------------------- #
        NC  = (
            x       =   l*20,       #   Number of Centroids in x
            y       =   l*20        #   Number of Centroids in y
        )
        Δ   = (
            x       =   P.L/NC.x,   #   Grid spacing in x
            y       =   P.H/NC.y    #   Grid Spacing in y
        )
        display(string(&quot;nx = &quot;,NC.x,&quot;, ny = &quot;,NC.y))
        # ------------------------------------------------------------ #</code></pre><p>Since the name of the animation does contain the resolution, one needs to define it here new as well. </p><pre><code class="language-Julia hljs">        # Animationssettings ----------------------------------------- #
        path        =   string(&quot;./examples/DiffusionEquation/2D/Results/&quot;)
        anim        =   Plots.Animation(path, String[] )
        filename    =   string(&quot;Gaussian_Diffusion_&quot;,FDSchema,
                            &quot;_nx_&quot;,NC.x,&quot;_ny_&quot;,NC.y)
        # ------------------------------------------------------------ #</code></pre><p>The grid coordinates are also defined. </p><pre><code class="language-Julia hljs">        # Grid coordinates ------------------------------------------- #
        x       = (
            c       =   LinRange(-P.L/2+ Δ.x/2.0, P.L/2 - Δ.x/2.0, NC.x),
        )
        y       = (
            c       =   LinRange(-P.H/2 + Δ.y/2.0, P.H/2 - Δ.y/2.0, NC.y),
        )
        # ------------------------------------------------------------ #</code></pre><p>For the sake of simplicity, the calculation of the time step is kept the same for each numerical scheme. Thus, it needs to fulfill the diffusion stability criterion and needs to be newly defined within each resolution loop. </p><pre><code class="language-Julia hljs">        # Time Parameters -------------------------------------------- #
        T       = (
            year        =   365.25*3600*24,     #   Seconds per year
            Δfac        =   1.0,                #   Factor for Explicit Stability Criterion
        )
        T1      = (
            tmax        =   10 * 1e6 * T.year,  #   Maximum Time in [ s ]
            Δ           =   [0.0]            
        )
        T       =   merge(T,T1)
        T.Δ[1]  =   T.Δfac * (1.0 / ( 2.0 * P.κ * ( 1 /Δ.x^2 + 1 / Δ.y^2 )))
        
        nt      =   ceil(Int,T.tmax/T.Δ[1])     #   Number of Time Steps
        time    =   zeros(1,nt)
        # ------------------------------------------------------------ #</code></pre><p>Next, the field arrays and initial condition are initialized. </p><pre><code class="language-Julia hljs">        # Initial Conditions  ---------------------------------------- #
        D       = (
            Q           =   zeros(NC...),
            T           =   zeros(NC...),
            T0          =   zeros(NC...),
            T_ex        =   zeros(NC.x+2,NC.y+2),
            Tana        =   zeros(NC...),
            RMS         =   zeros(1,nt),
            εT          =   zeros(NC...),
            Tmax        =   zeros(1,nt),
            Tmean       =   zeros(1,nt),
            Tmaxa       =   zeros(1,nt),
            Tprofile    =   zeros(NC.y,nt),
            Tprofilea   =   zeros(NC.y,nt),
            ρ           =   zeros(NC...),
            cp          =   zeros(NC...)            
        )
        @. D.ρ  =   P.ρ
        # Initial conditions
        AnalyticalSolution2D!(D.T, x.c, y.c, time[1], (T0=P.Tamp,K=P.κ,σ=P.σ))
        @. D.Tana                   =   D.T
        @. D.T0                     =   D.T
        D.T_ex[2:end-1,2:end-1]     .=  D.T</code></pre><p>For visualization purposes, the temperature profile through the center of the domain is stored. </p><blockquote><p><strong>Note:</strong> Even though we do not assume a radioactive heat source, one needs to initialize the field and set it to zero. This is required by the solver. </p></blockquote><pre><code class="language-Julia hljs">        D.Tprofile[:,1]     .=  (D.T[convert(Int,NC.x/2),:] + 
                                    D.T[convert(Int,NC.x/2)+1,:]) / 2
        D.Tprofilea[:,1]    .=  (D.Tana[convert(Int,NC.x/2),:] + 
                                    D.Tana[convert(Int,NC.x/2)+1,:]) / 2
        # Heat production rate ---
        @. D.Q          = P.Q0
        # Visualize initial condition ---
        # subplot 1 ---
        p = heatmap(x.c ./ 1e3, y.c ./ 1e3, (D.T.-P.K0)&#39;, 
                color=:viridis, colorbar=false, aspect_ratio=:equal, 
                xlabel=&quot;x [km]&quot;, ylabel=&quot;z [km]&quot;, 
                title=&quot;Temperature&quot;, 
                xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3), 
                clims=(minimum(D.T.-P.K0), maximum(D.T.-P.K0)),layout=(2,2),
                subplot=1)
            contour!(p,x.c./1e3,y.c/1e3,D.T&#39;.-P.K0,
                    levels=:5,linecolor=:black,subplot=1)
            contour!(p,x.c./1e3,y.c/1e3,D.Tana&#39;.-P.K0,
                    levels=:5,linestyle=:dash,linecolor=:yellow,subplot=1)
        # subplot 2 ---
        heatmap!(p,x.c ./ 1e3, y.c ./ 1e3, D.εT&#39;, 
                color=:viridis, colorbar=true, aspect_ratio=:equal, 
                xlabel=&quot;x [km]&quot;, ylabel=&quot;z [km]&quot;, 
                title=&quot;Deviation&quot;, 
                xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3),  
                clims=(-1,1),layout=(2,2),
                subplot=2)
        # subplot 3 ---
        plot!(p,D.Tprofile[:,1],y.c./1e3,
                linecolor=:black,
                xlabel=&quot;T_{x=L/2} [°C]&quot;,ylabel=&quot;Depth [km]&quot;,
                label=&quot;&quot;,
                subplot=3)
        plot!(p,D.Tprofilea[:,1],y.c./1e3,
                linestyle=:dash,linecolor=:yellow,
                xlabel=&quot;T_{x=L/2} [°C]&quot;,ylabel=&quot;Depth [km]&quot;,
                label=&quot;&quot;,
                subplot=3)
        # subplot 4 ---
        plot!(p,time[1:end]./T.year./1e6,D.RMS[1:end],
                label=&quot;&quot;,
                xlabel=&quot;Time [ Myrs ]&quot;,ylabel=&quot;RMS&quot;,
                subplot=4)
        if save_fig == 0
            display(p)
        end</code></pre><p><img src="../../../assets/Gaussian_Diffusion_Ini.svg" alt="GD2Dini"/></p><p><strong>Figure 1. Initial condition.</strong> Top left: Numerical temperature distribution (background colored field and black contour lines) overlain by the analytical solution (yellow dashed contours). Top right: Absolute deviation of the numerical from the analytical solution. Bottom left: Vertical temperature profile along the middle of the domain; black solid - numerical, yellow dashed - analytical. Bottom right: RMS over time. </p><p>Since the resolution varies, the boundary conditions must also be redefined within the loop. </p><pre><code class="language-Julia hljs">        # Boundary Conditions ---------------------------------------- #
        BC     = (type    = (W=:Dirichlet, E=:Dirichlet, 
                                N=:Dirichlet, S=:Dirichlet),
                    val     = (W=D.Tana[1,:],E=D.Tana[end,:],
                                N=D.Tana[:,end],S=D.Tana[:,1]))
        # ------------------------------------------------------------ #</code></pre><p>Depending on the numerical method, one needs to define the coefficient matrix and degrees of freedom for the linear system of equations or the iterative parameters (for the defect correction method). </p><pre><code class="language-Julia hljs">        if FDSchema == &quot;implicit&quot;
            # Linear System of Equations ----------------------------- #
            Num     =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)
            ndof    =   maximum(Num.T)
            K       =   ExtendableSparseMatrix(ndof,ndof)
            rhs     =   zeros(ndof)
        end
        if FDSchema == &quot;CNA&quot;
            # Linear System of Equations ----------------------------- #
            Num     =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)
            ndof    =   maximum(Num.T)
            K1      =   ExtendableSparseMatrix(ndof,ndof)
            K2      =   ExtendableSparseMatrix(ndof,ndof)
            rhs     =   zeros(ndof)
        end
        if FDSchema == &quot;dc&quot;
            niter       =   10
            ϵ           =   1e-10
            @. D.ρ      =   P.ρ
            @. D.cp     =   P.cp
            k           =   (x=zeros(NC.x+1,NC.x), y=zeros(NC.x,NC.x+1))
            @. k.x      =   P.k
            @. k.y      =   P.k
            Num         =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)
            ndof        =   maximum(Num.T)
            K           =   ExtendableSparseMatrix(ndof,ndof)
            R           =   zeros(NC...)
            ∂T          =   (∂x=zeros(NC.x+1, NC.x), ∂y=zeros(NC.x, NC.x+1))
            q           =   (x=zeros(NC.x+1, NC.x), y=zeros(NC.x, NC.x+1))
        end</code></pre><p>Now, all parameters are defined to solve the 2-D temperature conservation equation in a time loop using the corresponding numerical scheme. The analytical solution is calculated seperately. </p><pre><code class="language-Julia hljs">        # Time Loop -------------------------------------------------- #
        for n = 1:nt
            if n&gt;1
                if FDSchema == &quot;explicit&quot;
                    ForwardEuler2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC)
                elseif FDSchema == &quot;implicit&quot;
                    BackwardEuler2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC, rhs, K, Num)
                elseif FDSchema == &quot;CNA&quot;
                    CNA2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC, rhs, K1, K2, Num)
                elseif FDSchema == &quot;ADI&quot;
                    ADI2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC)
                elseif FDSchema == &quot;dc&quot;
                    for iter = 1:niter
                        # Evaluate residual
                        ComputeResiduals2D!(R, D.T, D.T_ex, D.T0, ∂T, q, D.ρ, D.cp, k, BC, Δ, T.Δ[1])
                        # @printf(&quot;||R|| = %1.4e\n&quot;, norm(R)/length(R))
                        norm(R)/length(R) &lt; ϵ ? break : nothing
                        # Assemble linear system
                        K  = AssembleMatrix2D(D.ρ, D.cp, k, BC, Num, NC, Δ, T.Δ[1])
                        # Solve for temperature correction: Cholesky factorisation
                        Kc = cholesky(K.cscmatrix)
                        # Solve for temperature correction: Back substitutions
                        δT = -(Kc\R[:])
                        # Update temperature
                        @. D.T += δT[Num.T]
                    end
                    D.T0    .= D.T
                end
                time[n]     =   time[n-1] + T.Δ[1]
                if time[n] &gt; T.tmax 
                    T.Δ[1]  =   T.tmax - time[n-1]
                    time[n] =   time[n-1] + T.Δ[1]
                end                
                # Exact solution on cell centroids
                AnalyticalSolution2D!(D.Tana, x.c, y.c, time[n], (T0=P.Tamp,K=P.κ,σ=P.σ))
                # Exact solution on cell boundaries
                BoundaryConditions2D!(BC, x.c, y.c, time[n], (T0=P.Tamp,K=P.κ,σ=P.σ)) 
            end
            # Maximum and Mean Temperature with time ---
            D.Tmax[n]   =   maximum(D.T)
            D.Tmean[n]  =   mean(D.T)
            # Vertical Profile along the Center of the Domain ---
            D.Tprofile[:,n]     .=  (D.T[convert(Int,NC.x/2),:] + 
                                        D.T[convert(Int,NC.x/2)+1,:]) / 2
            D.Tprofilea[:,n]    .=  (D.Tana[convert(Int,NC.x/2),:] + 
                                        D.Tana[convert(Int,NC.x/2)+1,:]) / 2
            # Deviation from the Analytical Solution ---
            @. D.εT     =   (D.Tana - D.T)
            # RMS ---
            D.RMS[n]    =   sqrt(sum(D.εT.^2)/(NC.x*NC.y))
            # Plot Solution ---
            if mod(n,2) == 0 || n == nt
                # subplot 1 ---
                p = heatmap(x.c ./ 1e3, y.c ./ 1e3, (D.T.-P.K0)&#39;, 
                    color=:viridis, colorbar=false, aspect_ratio=:equal, 
                    xlabel=&quot;x [km]&quot;, ylabel=&quot;z [km]&quot;, 
                    title=&quot;Temperature&quot;, 
                    xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3), 
                    clims=(minimum(D.T.-P.K0), maximum(D.T.-P.K0)),layout=(2,2),
                    subplot=1)

                contour!(p,x.c./1e3,y.c/1e3,D.T&#39;.-P.K0,
                            levels=:5,linecolor=:black,subplot=1)
                contour!(p,x.c./1e3,y.c/1e3,D.Tana&#39;.-P.K0,
                            levels=:5,linestyle=:dash,linecolor=:yellow,subplot=1)
                # subplot 2 ---
                heatmap!(p,x.c ./ 1e3, y.c ./ 1e3, D.εT&#39;, 
                        color=:viridis, colorbar=true, aspect_ratio=:equal, 
                        xlabel=&quot;x [km]&quot;, ylabel=&quot;z [km]&quot;, 
                        title=&quot;Deviation&quot;, 
                        xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3), 
                        clims=(-1,1),
                        subplot=2)
                # subplot 3 ---
                plot!(p,D.Tprofile[:,n],y.c./1e3,
                    linecolor=:black, ylim=(-P.H/2/1e3,P.H/2/1e3),
                    xlim=(0,P.Tamp),
                    xlabel=&quot;T_{x=L/2} [°C]&quot;,ylabel=&quot;Depth [km]&quot;,
                    label=&quot;&quot;,
                    subplot=3)
                plot!(p,D.Tprofilea[:,n],y.c./1e3,
                    linestyle=:dash,linecolor=:yellow,
                    xlabel=&quot;T_{x=L/2} [°C]&quot;,ylabel=&quot;Depth [km]&quot;,
                    label=&quot;&quot;,
                    subplot=3)
                # subplot 4 ---
                plot!(p,time[1:n]./T.year./1e6,D.RMS[1:n],
                    label=&quot;&quot;,
                    xlabel=&quot;Time [ Myrs ]&quot;,ylabel=&quot;RMS&quot;,
                    subplot=4)
                if save_fig == 1
                    Plots.frame(anim)
                elseif save_fig == 0
                    display(p)                        
                end
            end
            # End Time Loop ---
        end        
        display(&quot;Time loop finished ...&quot;)
        display(&quot;-&gt; Use new grid size...&quot;)</code></pre><p>Now, one can save the plots in a <em>gif</em> animation and store the values for the resolution test. </p><pre><code class="language-Julia hljs">        # Save Animation ---
        if save_fig == 1
            # Write the frames to a GIF file
            Plots.gif(anim, string( path, filename, &quot;.gif&quot; ), fps = 15)
        elseif save_fig == 0
            display(plot(p))
        end
        foreach(rm, filter(startswith(string(path,&quot;00&quot;)), readdir(path,join=true)))
        # ------------------------------------------------------------ #
        # Statistical Values for Each Scheme and Resolution ---
        St.ε[m,l]       =   maximum(D.RMS[:])
        St.nxny[m,l]    =   1/NC.x/NC.y
        St.Tmax[m,l]    =   D.Tmax[nt]
        St.Tmean[m,l]   =   D.Tmean[nt]
        St.Tanamax[1]   =   maximum(D.Tana)
        St.Tmean[1]     =   mean(D.Tana)
        # ------------------------------------------------------------ #
    end
end</code></pre><p><img src="../../../assets/Gaussian_Diffusion_CNA_nx_100_ny_100.gif" alt="GD2D_Evolve_example"/></p><p><strong>Figure 2. Final animation using the Crank-Nicolson approach for a resolution of 100 x 100.</strong> Top left: Numerical solution of the transient temperature field (background colored field and black contours); yellow dashed contours - analytical solution. Top right: Absolute deviation of the numerical from the analytical solution. Bottom left: Vertical temperature profile along the middle of the domain. Bottom right: RMS over time. </p><p>Finally, the results of the resolution test are plotted. </p><pre><code class="language-Julia hljs"># Visualize Statistical Values --------------------------------------- #
q   =   plot(0,0,layout=(1,3))
for m = 1:ns
#    subplot(1,3,1)
    plot!(q,St.nxny[m,:],St.ε[m,:],
                marker=:circle,markersize=3,label=Schema[m],
                xaxis=:log,yaxis=:log,
                xlabel=&quot;1/nx/ny&quot;,ylabel=&quot;ε_{T}&quot;,layout=(1,3),
                subplot=1)
    plot!(q,St.nxny[m,:],St.Tmax[m,:],
                marker=:circle,markersize=3,label=&quot;&quot;,
                xaxis=:log,
                xlabel=&quot;1/nx/ny&quot;,ylabel=&quot;T_{max}&quot;,
                subplot=2)
    plot!(q,St.nxny[m,:],St.Tmean[m,:],
                marker=:circle,markersize=3,label=&quot;&quot;,
                xaxis=:log,
                xlabel=&quot;1/nx/ny&quot;,ylabel=&quot;⟨T⟩&quot;,
                subplot=3)
    display(q)
end
# --------------------------------------------------------------------- #
# Save Final Figure --------------------------------------------------- #
if save_fig == -1
    savefig(q,&quot;./examples/DiffusionEquation/2D/Results/Gaussian_ResTest.png&quot;)
end
# --------------------------------------------------------------------- #</code></pre><p><img src="../../../assets/Gaussian_ResTest.png" alt="GD_Rest_test"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ForwardEuler_DC/">« Forward Euler (2D)</a><a class="docs-footer-nextpage" href="../PoissonRestest/">Poisson Problem (2D) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 11 September 2025 12:42">Thursday 11 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
