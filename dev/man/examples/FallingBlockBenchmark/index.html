<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Falling Block Benchmark · GeoModBox.jl</title><meta name="title" content="Falling Block Benchmark · GeoModBox.jl"/><meta property="og:title" content="Falling Block Benchmark · GeoModBox.jl"/><meta property="twitter:title" content="Falling Block Benchmark · GeoModBox.jl"/><meta name="description" content="Documentation for GeoModBox.jl."/><meta property="og:description" content="Documentation for GeoModBox.jl."/><meta property="twitter:description" content="Documentation for GeoModBox.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GeoModBox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Governing Equation</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Solution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../GESolution/">General</a></li><li><a class="tocitem" href="../../Ini/">Initial Condition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Heat Diffusion Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DiffMain/">General</a></li><li><a class="tocitem" href="../../DiffOneD/">1D</a></li><li><a class="tocitem" href="../../DiffTwoD/">2D</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Advection Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AdvectMain/">General</a></li><li><a class="tocitem" href="../../AdvOneD/">1D</a></li><li><a class="tocitem" href="../../AdvTwoD/">2D</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Momentum Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../MomentumMain/">General</a></li><li><a class="tocitem" href="../../MomentumOneD/">1D</a></li><li><a class="tocitem" href="../../MomentumTwoD/">2D</a></li></ul></li></ul></li><li><span class="tocitem">Exercises</span><ul><li><a class="tocitem" href="../../Exercises/">General</a></li><li><a class="tocitem" href="../../exercises/01_Euler_Advection/">01 - Euler Advection</a></li><li><a class="tocitem" href="../../exercises/02_1D_Heat_explicit/">02 - 1D Heat Diffusion (explicit)</a></li><li><a class="tocitem" href="../../exercises/03_1D_Heat_implicit/">03 - 1D Heat Diffusion (implicit)</a></li><li><a class="tocitem" href="../../exercises/04_2D_Diffusion_Stationary/">04 - 2D Heat Diffusion (stationary)</a></li><li><a class="tocitem" href="../../exercises/05_2D_Diffusion_TD_Plume/">05 - 2D Heat Diffusion (Plume)</a></li><li><a class="tocitem" href="../../exercises/05_2D_Diffusion_TD_Sill/">05 - 2D Heat Diffusion (Sill)</a></li><li><a class="tocitem" href="../../exercises/06_1D_Advection/">06 - 1D Advection</a></li><li><a class="tocitem" href="../../exercises/07_2D_Energy_Equation/">07 - 2D Energy Conservation</a></li><li><a class="tocitem" href="../../exercises/08_1D_Stokes/">08 - 1D Stokes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../Examples/">General</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Diffusion Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../OceanicGeotherm/">Oceanic Geotherm (1D)</a></li><li><a class="tocitem" href="../ContinentalGeotherm/">Continental Geotherm (1D)</a></li><li><a class="tocitem" href="../GaussianDiffusion1D/">Gaussian Diffusion (1D)</a></li><li><a class="tocitem" href="../BackwardEuler_DC/">Backward Euler (2D)</a></li><li><a class="tocitem" href="../ForwardEuler_DC/">Forward Euler (2D)</a></li><li><a class="tocitem" href="../GaussianDiffusion2D/">Gaussian Diffusion (2D)</a></li><li><a class="tocitem" href="../PoissonRestest/">Poisson Problem (2D)</a></li><li><a class="tocitem" href="../PoissonVariablek/">Poisson Problem; variable k (2D)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Advection Equtaion</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Advection2D/">Advection (2D)</a></li><li><a class="tocitem" href="../AdvectionRestest2D/">Advection Resolution Test (2D)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Stokes Equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ChannelFlow1D/">Channel Flow (1D)</a></li><li class="is-active"><a class="tocitem" href>Falling Block Benchmark</a></li><li><a class="tocitem" href="../FallingBlockDC/">Falling Block</a></li><li><a class="tocitem" href="../RTI/">Rayleigh Taylor Instability (RTI)</a></li><li><a class="tocitem" href="../RTI_growth_rate/">RTI - Growth Rate</a></li><li><a class="tocitem" href="../ViscousInclusion/">Viscous Inclusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Mixed Thermal Convection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BottomHeatedConvection/">Bottom Heated</a></li><li><a class="tocitem" href="../InternallyHeatedConvection/">Internally Heated</a></li><li><a class="tocitem" href="../MixedHeatedConvection/">Mixed Heated</a></li></ul></li></ul></li><li><a class="tocitem" href="../../listoffunctions/">List of functions</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Stokes Equation</a></li><li class="is-active"><a href>Falling Block Benchmark</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Falling Block Benchmark</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GeoSci-FFM/GeoModBox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/docs/src/man/examples/FallingBlockBenchmark.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="[Falling-Block-Benchmark](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockBenchmark.jl)"><a class="docs-heading-anchor" href="#[Falling-Block-Benchmark](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockBenchmark.jl)"><a href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockBenchmark.jl">Falling Block Benchmark</a></a><a id="[Falling-Block-Benchmark](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockBenchmark.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[Falling-Block-Benchmark](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockBenchmark.jl)" title="Permalink"></a></h1><p>The falling block benchmark is a well-established test for assessing the accuracy of the momentum solver and the efficiency of the advection scheme, particularly under strong viscosity and density contrasts. The model setup (Figure 1) is defined by a rectangular block with a certain viscosity and density within a matrix of a different viscosity and density. Due to the density contrast, the block sinks. If the block is less viscous than the surrounding matrix, it deforms during descent. Conversely, highly viscous blocks remain largely undeformed as they sink. </p><p><img src="../../../assets/FallingBlock_Setup.png" alt="FallingBlockSU"/></p><p><strong>Figure 1. Falling Block Setup.</strong> </p><p>The purpose of this benchmark is twofold: </p><ol><li><p>Accuracy of the variable viscosity momentum solver. Solving the momentum equation for the initial state, one can calculate the sinking velocity of the block, which follows a characteristic trend as a function of the viscosity contrast between the block and the matrix. </p></li><li><p>Accuracy of the advection scheme. Assuming a time-dependent problem, one can test the efficiency of the advection scheme. Here, all four different advection schemes can be choosen: </p><ul><li>Upwind</li><li>Staggered leapfrog</li><li>Semilagrangian </li><li>Tracers</li></ul></li></ol><blockquote><p><strong>Note:</strong> In the current state, the staggered leapfrog and semilagrangian scheme are highly ineffective to advect the density and viscosity simultaneously. Viscosity overshoots—arising from contrasts of up to six orders of magnitude—can lead to unphysical negative viscosities at the centroids. Thus, the solution of the momemtum equation is not correct anymore. This issue may be mitigated by advecting phase IDs only, then assigning viscosity and density based on the interpolated phase distribution. However, this approach requires either rounding the phase field to the nearest integer or applying weighted averaging to determine physical properties. </p></blockquote><p>This example solves the falling block benchmark across a viscosity contrast range spanning six orders of magnitude (from <span>$10^{-6}$</span> to <span>$10^6$</span>).  The simulation yields either the block’s initial sinking velocity (for steady-state problems), or its final position (for time-dependent problems with a viscosity ratio <span>$\eta_r \geq 0$</span>). For additional information on the benchmark, please refer to the <a href="https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/09_2D_Falling_Block.ipynb">exercise</a></p><p>Again, the output of the script depends on the definition of the parameters <code>save_fig</code>. </p><ul><li><code>save_fig = 0</code> - Output every plot for each time step and model (not recommended!)</li><li><code>save_fig = 1</code> - Save the animations for each model and store the final position (if the issue is steady state, this stores the sinking velocity plot) </li><li><code>save_fig = -1</code> - Only store the final position for a time-dependent problem </li></ul><hr/><p>Let&#39;s first load the required modules. </p><pre><code class="language-Julia hljs">using Plots
using ExtendableSparse
using GeoModBox.InitialCondition, GeoModBox.MomentumEquation.TwoD
using GeoModBox.AdvectionEquation.TwoD
using GeoModBox.Tracers.TwoD
using Base.Threads
using Printf</code></pre><p>In the following, one can define the range of the viscosity ratios to be calculated and the maximum time is set for each model assuming a viscosity ratio from -6 to 6 orders of magnitude. Additionally, one can define it the problem should be steady-state or time-dependent. </p><pre><code class="language-Julia hljs"># Make it time-dependent (1) or steady-state (0)
td      =   0   
# Benchmark parameter =============================================== #
ηᵣ      =   LinRange(-6.0,6.0,13)       #   Viscosity ratio
sv      =   zeros(length(ηᵣ))           #   Sinking Velocity
tmax    =   [7.115094, 7.114844, 7.256534, 7.377311, 7.738412, 
                7.673613, 9.886, 15.446, 19.623, 20.569, 20.569,
                20.569, 20.589]
# ------------------------------------------------------------------- #</code></pre><p>In the following, one can define the advection scheme and the initial configuration. For more details on how the initial condition is implement in <code>GeoModBox.jl</code>, please refere to the <a href="../../Ini/">documentaion</a>.</p><pre><code class="language-Julia hljs"># Define Numerical Scheme =========================================== #
# Advection ---
#   1) upwind, 2) slf, 3) semilag, 4) tracers
#   Attention: Tracers are the only method that work well.
FD          =   (Method     = (Adv=:semilag,),)
# ------------------------------------------------------------------- #
# Define Initial Condition ========================================== #
# Density --- 
#   1) block
Ini         =   (p=:block,) 
# ------------------------------------------------------------------- #</code></pre><p>Now, one can set the directory to safe the animaion to and some plotting parameters. </p><pre><code class="language-Julia hljs"># Animation and Plot Settings ======================================= #
path        =   string(&quot;./examples/StokesEquation/2D/Results/&quot;)
save_fig    =   1
p2          =   plot(0,0,layout=(2,3))
count       =   Int64(0)
# ------------------------------------------------------------------- #
# Plot Settings ===================================================== #
Pl  =   (
    qinc    =   1,
    qsc     =   100*(60*60*24*365.25)*5e1
)
# ------------------------------------------------------------------- #</code></pre><p>In the following, one defines the model geometry and the numerical grid parameters. </p><pre><code class="language-Julia hljs"># Geometry ========================================================== #
M       =   (
    xmin    =   0.0,
    xmax    =   500.0e3,    # [ m ]
    ymin    =   -500.0e3,   # [ m ]
    ymax    =   0.0,
)
# ------------------------------------------------------------------- #
# Grid ============================================================== #
NC      =   (
    x   =   50, 
    y   =   50,
)
NV      =   (
    x   =   NC.x + 1,
    y   =   NC.y + 1,
)
Δ       =   (
    x   =   (M.xmax - M.xmin)/NC.x,
    y   =   (M.ymax - M.ymin)/NC.y,
)
x       =   (
    c   =   LinRange(M.xmin+Δ.x/2,M.xmax-Δ.x/2,NC.x),
    ce  =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),
    v   =   LinRange(M.xmin,M.xmax,NV.x),
)
y       =   (
    c   =   LinRange(M.ymin+Δ.y/2,M.ymax-Δ.y/2,NC.y),
    ce  =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),
    v   =   LinRange(M.ymin,M.ymax,NV.y),
)
x1      =   (
    c2d     =   x.c .+ 0*y.c&#39;,
    v2d     =   x.v .+ 0*y.v&#39;, 
    vx2d    =   x.v .+ 0*y.ce&#39;,
    vy2d    =   x.ce .+ 0*y.v&#39;,
)
x   =   merge(x,x1)
y1      =   (
    c2d     =   0*x.c .+ y.c&#39;,
    v2d     =   0*x.v .+ y.v&#39;,
    vx2d    =   0*x.v .+ y.ce&#39;,
    vy2d    =   0*x.ce .+ y.v&#39;,
)
y   =   merge(y,y1)
# ------------------------------------------------------------------- #</code></pre><p>Now, one can set the physical constants of the problem. The arrays <code>ρ</code> and <code>phase</code> are used to advect the material. For more information on how this is implemented, please refer to the <a href="../../AdvectMain/">documentation</a>. Additionally, the velocity boundary conditions are set. </p><pre><code class="language-Julia hljs"># Physics =========================================================== #
g       =   9.81                #   Gravitational Acceleration

η₀      =   1.0e21              #   Background Viscosity
   
ρ₀      =   3200.0              #   Background density
ρ₁      =   3300.0              #   Block density
ρ       =   [ρ₀,ρ₁]             #   Density for phases

phase   =   [0,1]               #   Phase ID
# ------------------------------------------------------------------- #
# Boundary Conditions =============================================== #
VBC     =   (
    type    =   (E=:freeslip,W=:freeslip,S=:freeslip,N=:freeslip),
    val     =   (E=zeros(NV.y),W=zeros(NV.y),S=zeros(NV.x),N=zeros(NV.x)),
)
# ------------------------------------------------------------------- #</code></pre><p>Now, one can start the loop of the different viscosity ratio. </p><pre><code class="language-Julia hljs">for mn in eachindex(ηᵣ)     #   Loop over ηᵣ</code></pre><p>To store the animation of each model, the name of the gif file is defined in the following. </p><pre><code class="language-Julia hljs">    anim        =   Plots.Animation(path, String[] )
    filename    =   string(&quot;Falling_&quot;,Ini.p,&quot;_ηr_&quot;,round(ηᵣ[mn]),
                        &quot;_&quot;,FD.Method.Adv)
    # --------------------------------------------------------------- #</code></pre><p>Now, one can set the viscosity for the block and the viscosity array <code>η</code> for the advection scheme. </p><pre><code class="language-Julia hljs">    # Physics ======================================================= #
    η₁      =   η₀ * 10^(ηᵣ[mn])    #   Block Viscosity
    η       =   [η₀,η₁]             #   Viscosity for phases
    @show η
    # --------------------------------------------------------------- #</code></pre><p>In the following, the data arrays are initialized. </p><pre><code class="language-Julia hljs">    # Allocation ==================================================== #
    D   =   (
        vx      =   zeros(Float64,NV.x,NC.y+2),
        vy      =   zeros(Float64,NC.x+2,NV.y),
        Pt      =   zeros(Float64,NC...),
        pv      =   zeros(Float64,NV...),
        p       =   zeros(Float64,NC...),
        p_ex    =   zeros(Float64,NC.x+2,NC.y+2),
        ρ       =   zeros(Float64,NC...),
        ρ_ex    =   zeros(Float64,NC.x+2,NC.y+2),
        ρ_exo   =   zeros(Float64,NC.x+2,NC.y+2),
        vxc     =   zeros(Float64,NC...),
        vyc     =   zeros(Float64,NC...),
        vc      =   zeros(Float64,NC...),
        wt      =   zeros(Float64,(NC.x,NC.y)),
        wtv     =   zeros(Float64,(NV.x,NV.y)),
        ηc      =   zeros(Float64,NC...),
        ηv      =   zeros(Float64,NV...),
        η_ex    =   zeros(Float64,NC.x+2,NC.y+2),
        η_exo   =   zeros(Float64,NC.x+2,NC.y+2),
    )
    # --------------------------------------------------------------- #</code></pre><p>Now, one needs to initialize the time parameters. </p><pre><code class="language-Julia hljs">    # Time ========================================================== #
    T   =   ( 
        tmax    =   [0.0],  
        Δfac    =   1.0,    # Courant time factor, i.e. dtfac*dt_courant
        Δ       =   [0.0],
        time    =   [0.0,0.0],
    )
    T.tmax[1]   =   tmax[mn] * 1e6 * (60*60*24*365.25)   # [ s ] 
    if td == 0
        nt = 1
    else
        nt  =   9999
    end
    # --------------------------------------------------------------- #</code></pre><p>In case tracers are used, the tracers are initialized in the following. Alternatively, the initial density and viscosity are defined on the extended grid using the phase distribution. For more details on the initial conditions, please refer to the <a href="../../Ini/">documentation</a>. </p><pre><code class="language-Julia hljs">    # Tracer Advection ============================================== #
    if FD.Method.Adv==:tracers 
        # Tracer Initialization ---
        nmx,nmy     =   3,3
        noise       =   0
        nmark       =   nmx*nmy*NC.x*NC.y
        Aparam      =   :phase
        MPC         =   (
            c       =   zeros(Float64,(NC.x,NC.y)),
            v       =   zeros(Float64,(NV.x,NV.y)),
            th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),
            thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),
        )
        MPC1        = (
            PG_th   =   [similar(D.ρ) for _ = 1:nthreads()],    # per thread
            PV_th   =   [similar(D.ηv) for _ = 1:nthreads()],   # per thread
            wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread
            wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread
        )
        MPC     =   merge(MPC,MPC1)
        Ma      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,Ini.p,phase)
        # RK4 weights ---
        rkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging
        rkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping
        # Count marker per cell ---
        CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)
        # Interpolate from markers to cell ---
        Markers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)
        Markers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)
        Markers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)
        @. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + 
                                D.ηv[2:end-0,1:end-1] + 
                                D.ηv[1:end-1,2:end-0] + 
                                D.ηv[2:end-0,2:end-0])
    else
        # ----------------------------------------------------------- #
        # Initial Condition ========================================= #
        IniPhase!(Ini.p,D,M,x,y,NC;phase)
        for i in eachindex(phase)
            D.ρ[D.p.==phase[i]] .= ρ[i]
            D.ηc[D.p.==phase[i]] .= η[i] 
        end
        # Density ---
        D.ρ_ex[2:end-1,2:end-1]     .=  D.ρ
        D.ρ_ex[1,:]     .=  D.ρ_ex[2,:]
        D.ρ_ex[end,:]   .=  D.ρ_ex[end-1,:]
        D.ρ_ex[:,1]     .=  D.ρ_ex[:,2]
        D.ρ_ex[:,end]   .=  D.ρ_ex[:,end-1]
        D.ρ_exo         .=  D.ρ_ex
        # Viscosity ---
        # --- Centroids -
        D.η_ex[2:end-1,2:end-1]     .=  D.ηc
        D.η_ex[1,:]     .=  D.η_ex[2,:]
        D.η_ex[end,:]   .=  D.η_ex[end-1,:]
        D.η_ex[:,1]     .=  D.η_ex[:,2]
        D.η_ex[:,end]   .=  D.η_ex[:,end-1]
        D.η_exo         .=  D.η_ex
        # --- Vertices -
        @. D.ηv     =   0.25 * (D.η_ex[1:end-1,1:end-1] + 
                                D.η_ex[2:end-0,1:end-1] + 
                                D.η_ex[1:end-1,2:end-0] + 
                                D.η_ex[2:end-0,2:end-0])
    end
    # --------------------------------------------------------------- #</code></pre><p>Now, one needs to define the parameters for the linear system of equations of the momentum equation. </p><pre><code class="language-Julia hljs">    # System of Equations =========================================== #
    # Numbering, without ghost nodes! ---
    off    = [  NV.x*NC.y,                          # vx
                NV.x*NC.y + NC.x*NV.y,              # vy
                NV.x*NC.y + NC.x*NV.y + NC.x*NC.y]  # Pt

    Num    =    (
        Vx  =   reshape(1:NV.x*NC.y, NV.x, NC.y), 
        Vy  =   reshape(off[1]+1:off[1]+NC.x*NV.y, NC.x, NV.y), 
        Pt  =   reshape(off[2]+1:off[2]+NC.x*NC.y,NC...),
    )
    # --------------------------------------------------------------- #</code></pre><p>Let&#39;s start the time loop! </p><pre><code class="language-Julia hljs">    # Time Loop ===================================================== #
    for it = 1:nt</code></pre><p>First, the unknown and right-hand vector for the system of equations are defined. </p><pre><code class="language-Julia hljs">        χ       =   zeros(maximum(Num.Pt))      #   Unknown Vector
        rhs     =   zeros(maximum(Num.Pt))      #   Right-hand Side
        # Update Time ---
        T.time[1]   =   T.time[2] 
        @printf(&quot;Time step: #%04d, Time [Myr]: %04e\n &quot;,it,
                    T.time[1]/(60*60*24*365.25)/1.0e6)</code></pre><p>Now, one can solve the system of equations, for example, using the direct method. For more information on how this is solved, please refer to the <a href="../../MomentumMain/">documentation</a>. To advect the material using the first three advection scheme, the centroid velocity is calculated. </p><pre><code class="language-Julia hljs">        # Momentum Equation =======
        # Update K ---
        K       =   Assembly( NC, NV, Δ, D.ηc, D.ηv, VBC, Num )
        # Update RHS ---
        rhs     =   updaterhs( NC, NV, Δ, D.ηc, D.ηv, D.ρ, g, VBC, Num )
        # Solve System of Equations ---
        χ       =   K \ rhs
        # Update Unknown Variables ---
        D.vx[:,2:end-1]     .=  χ[Num.Vx]
        D.vy[2:end-1,:]     .=  χ[Num.Vy]
        D.Pt                .=  χ[Num.Pt]
        # ======
        # Get the velocity on the centroids ---
        for i = 1:NC.x
            for j = 1:NC.y
                D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2
                D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2
            end
        end
        @. D.vc        = sqrt(D.vxc^2 + D.vyc^2)
        # ---
        @show(maximum(D.vc))
        @show(minimum(D.Pt))
        @show(maximum(D.Pt))
        if it == 1
            sv[mn]  =   maximum(D.vc)
        end
        # ---
        if T.time[2] &gt;= T.tmax[1]
            it = nt
        end
        # ---</code></pre><p>In the following, the figures for each time step are ploted. The style of the plot varies depending on the advection scheme. </p><pre><code class="language-Julia hljs">        if mod(it,2) == 0 || it == nt || it == 1
            if FD.Method.Adv==:tracers
                p = heatmap(x.c./1e3,y.c./1e3,D.p&#39;,color=:inferno,
                            xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,colorbar=false,
                            title=&quot;Phase_c&quot;,
                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), 
                            ylims=(M.ymin/1e3, M.ymax/1e3),
                            layout=(2,2),subplot=1)
            else
                p = heatmap(x.v./1e3,y.v./1e3,log10.(abs.(D.ηv&#39;)),color=reverse(cgrad(:roma)),
                            xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,title=&quot;η_v&quot;,
                            clims=(15,27),
                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), 
                            ylims=(M.ymin/1e3, M.ymax/1e3),colorbar=true,
                            layout=(2,2),subplot=1)
            end
            if FD.Method.Adv==:tracers
                scatter!(p,Ma.x[1:Pl.qinc:end]./1e3,Ma.y[1:Pl.qinc:end]./1e3,
                            ms=1,ma=0.5,mc=Ma.phase[1:Pl.qinc:end],markerstrokewidth=0.0,
                            xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,colorbar=false,
                            title=&quot;tracers&quot;,label=&quot;&quot;,
                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), 
                            ylims=(M.ymin/1e3, M.ymax/1e3),
                            layout=(2,2),subplot=2)
            else
                heatmap!(p,x.c./1e3,y.c./1e3,D.ρ&#39;,color=:inferno,
                            xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,colorbar=false,
                            title=&quot;Density&quot;,
                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), 
                            ylims=(M.ymin/1e3, M.ymax/1e3),
                            layout=(2,2),subplot=2)
            end
            heatmap!(p,x.c./1e3,y.c./1e3,D.vc&#39;,
                        xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,colorbar=false,
                        title=&quot;V_c&quot;,color=cgrad(:batlow),
                        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),
                        ylims=(M.ymin/1e3, M.ymax/1e3),
                        layout=(2,2),subplot=4)
            quiver!(p,x.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,
                        y.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,
                        quiver=(D.vxc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc,
                                D.vyc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc),        
                        la=0.5,color=&quot;white&quot;,layout=(1,3),subplot=3)
            heatmap!(p,x.c./1e3,y.c./1e3,log10.(abs.(D.ηc&#39;)),color=reverse(cgrad(:roma)),
                        xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,title=&quot;η_c&quot;,
                        clims=(15,27),
                        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), 
                        ylims=(M.ymin/1e3, M.ymax/1e3),colorbar=true,
                        layout=(2,2),subplot=3)
            if save_fig == 1
                Plots.frame(anim)
            elseif save_fig == 0
                display(p)
            end
        end
        if T.time[2] &gt;= T.tmax[1]
            break
        end</code></pre><p>Now, one needs to calculate the time step to advect the material.</p><pre><code class="language-Julia hljs">        # Calculate Time Stepping ---
        T.Δ[1]      =   T.Δfac * minimum((Δ.x,Δ.y)) / 
                            (sqrt(maximum(abs.(D.vx))^2 + maximum(abs.(D.vy))^2))
        # ---
        @printf(&quot;\n&quot;)
        # Calculate Time ---
        T.time[2]   =   T.time[1] + T.Δ[1]
        if T.time[2] &gt; T.tmax[1] 
            T.Δ[1]      =   T.tmax[1] - T.time[1]
            T.time[2]   =   T.time[1] + T.Δ[1]
        end</code></pre><p>In the following the advection is conducted. For more details on this, please refer to the <a href="../../AdvectMain/">documentation</a>.</p><pre><code class="language-Julia hljs">        # Advection ======
        if FD.Method.Adv==:upwind
            upwindc2D!(D.ρ,D.ρ_ex,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)
            upwindc2D!(D.ηc,D.η_ex,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)
        elseif FD.Method.Adv==:slf
            slfc2D!(D.ρ,D.ρ_ex,D.ρ_exo,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)
            slfc2D!(D.ηc,D.η_ex,D.η_exo,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)
        elseif FD.Method.Adv==:semilag
            semilagc2D!(D.ρ,D.ρ_ex,D.vxc,D.vyc,[],[],x,y,T.Δ[1])
            semilagc2D!(D.ηc,D.η_ex,D.vxc,D.vyc,[],[],x,y,T.Δ[1])
        elseif FD.Method.Adv==:tracers
            # Advect tracers ---
            @printf(&quot;Running on %d thread(s)\n&quot;, nthreads())  
            AdvectTracer2D(Ma,nmark,D,x,y,T.Δ[1],Δ,NC,rkw,rkv,1)
            CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,it)
            # Interpolate phase from tracers to grid ---
            Markers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)
            Markers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)
            Markers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)
            @. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + 
                                D.ηv[2:end-0,1:end-1] + 
                                D.ηv[1:end-1,2:end-0] + 
                                D.ηv[2:end-0,2:end-0])
        end
        if FD.Method.Adv!=:tracers
            # --- Vertices -
            @. D.ηv     =   0.25 * (D.η_ex[1:end-1,1:end-1] + 
                                    D.η_ex[2:end-0,1:end-1] + 
                                    D.η_ex[1:end-1,2:end-0] + 
                                    D.η_ex[2:end-0,2:end-0])
        end
        @printf(&quot;\n&quot;)
    end     # End Time Loop</code></pre><p>If requested, the final position of the blocks are plotted and stored in the following. </p><pre><code class="language-Julia hljs">    if ηᵣ[mn] == 0.0 || ηᵣ[mn] == 1.0 || ηᵣ[mn] == 2.0 || 
                    ηᵣ[mn] == 3.0 || ηᵣ[mn] == 4.0 || ηᵣ[mn] == 6.0
        count = count + 1
        if FD.Method.Adv==:tracers
            p2  =   scatter!(p2,Ma.x[1:Pl.qinc:end]./1e3,Ma.y[1:Pl.qinc:end]./1e3,
                ms=1,ma=0.5,mc=Ma.phase[1:Pl.qinc:end],markerstrokewidth=0.0,
                xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,colorbar=false,
                title=string(&quot;tracers, η_r = &quot;,ηᵣ[mn]),label=&quot;&quot;,
                aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), 
                ylims=(M.ymin/1e3, M.ymax/1e3),
                layout=(2,3),subplot=count)
        else
            p2 = heatmap!(p2,x.c./1e3,y.c./1e3,D.ρ&#39;,color=:inferno,
                xlabel=&quot;x[km]&quot;,ylabel=&quot;y[km]&quot;,colorbar=false,
                title=&quot;Phase_c&quot;,
                aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), 
                ylims=(M.ymin/1e3, M.ymax/1e3),
                layout=(2,3),subplot=count)
        end
    end
    # Save Animation ---
    if save_fig == 1
        if td == 1
            # Write the frames to a GIF file
            Plots.gif(anim, string( path, filename, &quot;.gif&quot; ), fps = 15)
            foreach(rm, filter(startswith(string(path,&quot;00&quot;)), readdir(path,join=true)))
        end
    end
end # End ηᵣ Loop</code></pre><p>In case the problem is set to be steady-state, the sinking velocity is plotted. If the problem is time-dependent the final position is stored. </p><pre><code class="language-Julia hljs">if td == 0
    q = scatter(ηᵣ,sv,marker=4,
                    ylabel=&quot;block velocity [m/s]&quot;,
                    xlabel=&quot;log_{10}(η_{block}/η_{medium})&quot;,
                    title=&quot;Sinking Velocity&quot;,
                    label=false,
                    ylims=(0.2e-9,1.5e-9),
                    xlims=(-6,6))
    if save_fig == 1
        savefig(q,string(&quot;./examples/StokesEquation/2D/Results/FallingBlock_SinkingVeloc&quot;,
                            &quot;_&quot;,FD.Method.Adv,&quot;.png&quot;))
        foreach(rm, filter(startswith(string(path,&quot;00&quot;)), readdir(path,join=true)))
    else
        display(q)
    end
else
    if save_fig == -1 ||save_fig == 1
        savefig(p2,string(&quot;./examples/StokesEquation/2D/Results/FallingBlock_FinalStage&quot;,
                            &quot;_&quot;,FD.Method.Adv,&quot;.png&quot;))
    else
        display(p2)
    end
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ChannelFlow1D/">« Channel Flow (1D)</a><a class="docs-footer-nextpage" href="../FallingBlockDC/">Falling Block »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 11 September 2025 11:20">Thursday 11 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
