var documenterSearchIndex = {"docs":
[{"location":"man/MomentumTwoD/#Stokes-Equation-(2D)","page":"2D","title":"Stokes Equation (2D)","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The Stokes equation in two dimensions is defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n0 = -fracpartialPpartialx_i + fracpartialtau_ijpartialx_j + rho g_i \nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where P is the total pressure [Pa], rho is the density [kg/m³], g_i is the gravitational acceleration [m/s²], fracpartialpartial x_i is the spatial derivative in the x_i-direction, and tau_ij is the deviatoric stress tensor [Pa], defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\ntau_ij = 2eta dotvarepsilon_ij \nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where eta is the dynamic viscosity [Pa·s], and dotvarepsilon_ij is the strain-rate tensor [1/s], given by:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\ndotvarepsilon_ij = frac12 left( fracpartialv_ipartialx_j + fracpartialv_jpartialx_i right)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where v_i is the velocity [m/s] in the i-th direction.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The Stokes equation provides two equations for three unknowns: v_x, v_y, and P. To solve for the third unknown, one additional equation is required — the mass conservation equation.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The conservation of mass (assuming an incompressible medium) is defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\ntextdivleft(vecv right) = left(fracpartialv_ipartialx_i+fracpartialv_jpartialx_jright) = 0\nendequation","category":"page"},{"location":"man/MomentumTwoD/#Discretization","page":"2D","title":"Discretization","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The conservation equations of momentum and mass are solved in two dimensions (x and y) using a staggered finite difference grid, where the horizontal (cyan dashes) and vertical (orange dashes) velocities are defined between the regular grid points (vertices), and the pressure (red circles) within finite difference cells (centroids), as shown in Figure 1.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"A staggered grid enables conservation of stress between adjacent grid points and requires careful placement of the associated variables.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"(Image: MomentumGrid)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Figure 1. Staggered finite difference grid for the momentum equation.   Discretization of the conservation equations of momentum and mass. The horizontal and vertical velocities require ghost nodes at the North, South, East, and West boundaries, respectively.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/#Constant-Viscosity","page":"2D","title":"Constant Viscosity","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Let's first assume a special case of the Stokes equation, a constant viscosity, which simplifies equation (1) to:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n0 = -fracpartialPpartialx_i + 2etafracpartial^2v_ipartialx_i^2 + etaleft(fracpartial^2v_ipartialx_j^2+fracpartial^2v_jpartialx_i^2right) + rho g_i \nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"By applying equation (4) and neglecting horizontal gravitational acceleration, equation (5) simplifies to the following component-wise forms:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n-fracpartialPpartialx + etafracpartial^2v_xpartialx^2 + etafracpartial^2v_xpartialy^2 = 0 \nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n-fracpartialPpartialy + etafracpartial^2v_ypartialy^2 + etafracpartial^2v_ypartialx^2 = - rho g_y \nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"To discretize these equations, we define a numerical stencil indicating the grid points involved in the finite difference approximation. Each stencil is centered on the point (ij), where i and j denote indices in the horizontal and vertical directions, respectively. The central point corresponds to the equation's location in the global linear system.","category":"page"},{"location":"man/MomentumTwoD/#Stencil","page":"2D","title":"Stencil","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The numerical stencils for the momentum equations under constant viscosity are shown in Figure 2. These stencils illustrate the neighboring grid points required to evaluate each component using a finite difference scheme.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"(Image: StencilConstEta)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Figure 2. Numerical stencils for constant viscosity. a) x-component; b) y-component.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"By applying finite difference approximations to the partial derivatives, equations (6) and (7) become:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -fracP_ij-P_i-1jDeltax +   etafracv_x(i-1j)-2v_x(ij)+v_x(i+1j)Deltax^2 +    etafracv_x(ij-1)-2v_x(ij)+v_x(ij+1)Deltay^2 = 0\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Rearranging and grouping terms, we obtain:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_CP_ij + P_WP_i-1j +   Sv_x(ij-1) +  Wv_x(i-1j) +   Cv_x(ij) +   E v_x(i+1j) + N v_x(ij+1) = 0 \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where the coefficients are defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nbeginsplit\nP_C  = -frac1Deltax  \nP_W  = frac1Deltax \nS  = fracetaDeltay^2 \nW  = fracetaDeltax^2 \nC  = -2etaleft(frac1Deltax^2+frac1Deltay^2right) \nE  = fracetaDeltax^2 \nN  = fracetaDeltay^2 \nendsplit\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -fracP_ij-P_ij-1Deltay +   etafracv_y(ij-1)-2v_y(ij)+v_x(ij+1)Deltay^2 +   etafracv_y(i-1j)-2v_y(ij)+v_y(i+1j)Deltax^2 =   -fracrho_ij+rho_i+1j2 g_y\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Rearranging and grouping terms, we obtain:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_SP_ij-1 + P_CP_ij +   Sv_y(ij-1) + Wv_y(i-1j) +   Cv_y(ij) +   E v_y(i+1j) + N v_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with coefficients defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nbeginsplit\nP_S  = frac1Deltay  \nP_C  = -frac1Deltay \nS  = fracetaDeltay^2 \nW  = fracetaDeltax^2 \nC  = -2etaleft(frac1Deltax^2+frac1Deltay^2right) \nE  = fracetaDeltax^2 \nN  = fracetaDeltay^2 \nendsplit\nendequation","category":"page"},{"location":"man/MomentumTwoD/#Boundary-Conditions","page":"2D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The most commonly applied boundary conditions for the momentum equation are combinations of Dirichlet and Neumann velocity boundary conditions. These are typically referred to as free slip and no slip boundary conditions.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/#Free-slip","page":"2D","title":"Free slip","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Free slip boundary conditions allow fluid motion along the boundary while enforcing zero shear stress and no flow across the boundary. For the lateral boundaries (East, West), this translates to:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nbeginsplit\nv_x = 0 \nfracpartialv_ypartialx=0\nendsplit\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For the horizontal boundaries (North, South), the conditions are:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nbeginsplit\nv_y = 0 \nfracpartialv_xpartialy=0\nendsplit\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"When solving the momentum equation using a direct method, the system coefficients near the domain boundaries must be modified to account for these conditions. This involves specifying velocity values at ghost nodes and, if applicable, updating the right-hand side of the equations.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For the free slip condition, the horizontal velocity v_x at the ghost nodes along the South and North boundaries is defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"South","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_x(iGS) = v_x(i1)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"North","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_x(iGN) = v_x(incy)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"At the lateral boundaries (East, West), the horizontal velocity is set to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The vertical velocity v_y at the ghost nodes for the West and East boundaries is defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"West","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_y(GWj) = v_y(1j)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"East","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_y(GEj) = v_y(ncxj)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Along the North and South boundaries, v_y is set to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Using equations (16) – (19), the discretized system of equations is updated accordingly. For free slip boundaries, the right-hand side remains unchanged, but the coefficients are modified.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"South","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij+   Wv_x(i-1j)+   Cv_x(ij)+   Ev_x(i+1j)+Nv_x(ij+1) = 0\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2etaDeltax^2-fracetaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"North","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij+   Sv_x(ij-1)+ Wv_x(i-1j)+   Cv_x(ij)+   Ev_x(i+1j) = 0\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2etaDeltax^2-fracetaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"On the lateral boundaries (East, West), the central coefficient is set to:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and all other coefficients are set to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"West","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_SP_ij-1+P_CP_ij+   Sv_y(ij-1)+   Cv_y(ij)+   Ev_y(i+1j)+ Nv_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -fracetaDeltax^2-frac2etaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"East","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_SP_ij-1+P_CP_ij+   Sv_y(ij-1)+ Wv_y(i-1j)+   Cv_y(ij)+   Nv_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -fracetaDeltax^2-frac2etaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"On the North and South boundaries, the central coefficient is:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and all other coefficients are zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/#No-slip","page":"2D","title":"No slip","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"No slip boundary conditions enforce zero velocity along the boundary, effectively \"fixing\" the fluid to the boundary. That is, for all boundaries (East, West, South, North), the velocity components satisfy:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nbeginsplit\nv_x = 0 \nv_y = 0\nendsplit\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For the horizontal velocity v_x, values at the ghost nodes adjacent to the South and North boundaries are defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"South","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_x(iGS) = 2V_BCS - v_x(i1)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"North","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_x(iGN) = 2V_BCN - v_x(incy)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where V_BCS and V_BCN are the prescribed boundary velocities (typically zero for no slip).","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"At the lateral boundaries (East, West), the velocity v_x is simply set to zero, as in the free slip case.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For the vertical velocity v_y, the ghost nodes adjacent to the West and East boundaries are defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"West","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_y(GWj) = 2V_BCW - v_y(1j)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"East","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nv_y(GEj) = 2V_BCE - v_y(ncxj)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where V_BCW and V_BCE are the prescribed boundary velocities (again typically zero).","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Along the North and South boundaries, v_y = 0 directly, consistent with the free slip implementation.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Using equations (31) – (34), the system coefficients and the right-hand side of the discretized equations are modified accordingly.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"South","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij+   Wv_x(i-1j)+   Cv_x(ij)+   Ev_x(i+1j)+Nv_x(ij+1) =   -2fracetaDeltay^2V_BCS\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2etaDeltax^2-frac3etaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"North","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij+   Sv_x(ij-1)+Wv_x(i-1j)+   Cv_x(ij)+   Ev_x(i+1j) =   -2fracetaDeltay^2V_BCN\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2etaDeltax^2-frac3etaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"On the lateral boundaries (East, West), set:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with all other coefficients and the right-hand side equal to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"West","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_SP_ij-1+P_CP_ij+   Sv_y(ij-1)+   Cv_y(ij)+   Ev_y(i+1j)+Nv_y(ij+1) =   -fracrho_ij + rho_i+1j2 g_y - 2fracetaDeltax^2V_BCW\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac3etaDeltax^2-frac2etaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"East","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_SP_ij-1+P_CP_ij+   Sv_y(ij-1)+Wv_y(i-1j)+   Cv_y(ij)+   Nv_y(ij+1) =   -fracrho_ij + rho_i+1j2 g_y - 2fracetaDeltax^2V_BCW\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac3etaDeltax^2-frac2etaDeltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"On the horizontal boundaries (North, South), set:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and all other coefficients and the right-hand side to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For implementation details, please refer to the source code.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/#Variable-Viscosity","page":"2D","title":"Variable Viscosity","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"In the case of variable viscosity, the momentum equation is written in terms of the unknowns as follows:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n-fracpartialPpartialx + fracpartialpartialxleft(2eta_cfracpartialv_xpartialxright)+fracpartialpartialyleft( eta_vleft(fracpartialv_xpartialy + fracpartialv_ypartialxright)right) = 0\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n-fracpartialPpartialy + fracpartialpartialyleft(2eta_cfracpartialv_ypartialyright)+fracpartialpartialxleft( eta_vleft(fracpartialv_ypartialx + fracpartialv_xpartialyright)right) = -fracrho_ij+rho_i+1j2g_y\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where eta_c denotes the viscosity defined at the centroids, and eta_v denotes the viscosity defined at the vertices.","category":"page"},{"location":"man/MomentumTwoD/#Stencil-2","page":"2D","title":"Stencil","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The stencils for the momentum equation assuming variable viscosity illustrate the grid points (parameters) required to solve the equations for each velocity component using a finite difference discretization (Figure 3).","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"(Image: Stencil_vary_eta)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Figure 3. Numerical stencils for variable viscosity. a) x-component; b) y-component.  ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Note: In the following equations, the indices (ij) of each variable left(v_x v_y P eta_c eta_vright) refer to the central point of the respective stencil, as depicted in Figure 3. ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Using finite difference approximations, the momentum equation is expressed as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n-fracP_ij-P_i-1jDeltax+fractau_xx(ij) -tau_xx(i-1j)Deltax + fractau_xy(ij+1)-tau_xy(ij)Deltay = 0\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"or, explicitly in terms of partial derivatives:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -fracP_ij-P_i-1jDeltax+  frac2eta_c(ij)fracpartialv_xpartialxvert_ij -2eta_c(i-1j)fracpartialv_xpartialxvert_i-1jDeltax +   fraceta_v(ij+1)left(fracpartialv_xpartialyvert_ij+1+fracpartialv_ypartialxvert_ij+1right)-eta_v(ij)left(fracpartialv_xpartialyvert_ij+fracpartialv_ypartialxvert_ijright)Deltay = 0\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and in terms of the discrete velocity unknowns:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -fracP_ij-P_i-1jDeltax+   frac2eta_c(ij)Deltaxleft(fracv_x(i+1j)-v_x(ij)Deltaxright) -   frac2eta_c(i-1j)Deltaxleft(fracv_x(ij)-v_x(i-1j)Deltaxright)+   fraceta_v(ij+1)Deltayleft(fracv_x(ij+1)-v_x(ij)Deltay + fracv_y(ij+1)-v_y(i-1j+1)Deltaxright) -    fraceta_v(ij)Deltayleft(fracv_x(ij)-v_x(ij-1)Deltay + fracv_y(ij)-v_y(i-1j)Deltaxright) = 0\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Reorganizing terms yields:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij +   Sv_x(ij-1)+SWv_y(i-1j)+SEv_y(ij)+Wv_x(i-1j)+   Cv_x(ij) +   Ev_x(i+1j) + NWv_y(i-1j+1) + NEv_y(ij+1) + Nv_x(ij+1) =   0 \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with coefficients defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\nP_W  = frac1Deltax \nP_C  = -frac1Deltax \nS  = fraceta_v(ij)Deltay^2\nSW  = fraceta_v(ij)DeltaxDeltay\nSE  = -fraceta_v(ij)DeltaxDeltay\nW  = frac2eta_c(i-1j)Deltax^2\nC  = -frac2Deltax^2left(eta_c(ij)+eta_c(i-1j)right)-frac1Deltay^2left(eta_v(ij+1) + eta_v(ij) right) \nE  = frac2eta_c(ij)Deltax^2\nNW  = -fraceta_v(ij+1)DeltaxDeltay\nNE  = fraceta_v(ij+1)DeltaxDeltay\nN  = fraceta_v(ij+1)Deltay^2\nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\n-fracP_ij-P_ij-1Deltay+fractau_yy(ij) - tau_yy(ij-1)Deltay + fractau_yx(i+1j)-tau_yx(ij)Deltax = -fracrho_ij+rho_i+1j2 g_y\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"or, expanded:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -fracP_ij-P_ij-1Deltay+   frac2eta_c(ij)fracpartialv_ypartialyvert_ij -2eta_c(ij-1)fracpartialv_ypartialyvert_ij-1Deltay +   fraceta_v(i+1j)left(fracpartialv_ypartialxvert_i+1j+fracpartialv_xpartialyvert_i+1jright)-eta_v(ij)left(fracpartialv_ypartialxvert_ij+fracpartialv_xpartialyvert_ijright)Deltax =   -fracrho_ij+rho_i+1j2 g_y\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"which becomes in discrete form:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -fracP_ij-P_ij-1Deltay+   frac2eta_c(ij)Deltayleft(fracv_y(ij+1)-v_y(ij)Deltayright) -   frac2eta_c(ij-1)Deltayleft(fracv_y(ij)-v_y(ij-1)Deltayright)+   fraceta_v(i+1j)Deltaxleft(fracv_y(i+1j)-v_y(ij)Deltax + fracv_x(i+1j)-v_x(i+1j-1)Deltayright) -   fraceta_v(ij)Deltaxleft(fracv_y(ij)-v_y(i-1j)Deltax + fracv_x(ij)-v_x(ij-1)Deltayright) =   -fracrho_ij+rho_i+1j2 g_y\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Reorganized:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_CP_ij+P_SP_ij-1 +   Sv_y(ij-1)+SWv_x(ij-1)+SEv_x(i+1j-1)+Wv_y(i-1j)+   Cv_y(ij) +   Ev_y(i+1j) + NWv_x(ij) + NEv_x(i+1j) + Nv_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with coefficients:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\nP_S  = frac1Deltay \nP_C  = -frac1Deltay \nS  = frac2eta_c(ij-1)Deltay^2\nSW  = fraceta_v(ij)DeltaxDeltay\nSE  = -fraceta_v(i+1j)DeltaxDeltay\nW  = fraceta_v(ij)Deltax^2\nC  = -frac2Deltay^2left(eta_c(ij)+eta_c(ij-1)right)-frac1Deltax^2left(eta_v(i+1j) + eta_v(ij) right) \nE  = fraceta_v(i+1j)Deltax^2\nNW  = -fraceta_v(ij)DeltaxDeltay\nNE  = fraceta_v(i+1j)DeltaxDeltay\nN  = frac2eta_c(ij)Deltay^2\nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/#Boundary-Conditions-2","page":"2D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The velocities for the ghost nodes used to define the various velocity boundary conditions are the same as described for the constant viscosity case.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/#Free-Slip","page":"2D","title":"Free Slip","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Using equations (16)–(19), the coefficients of the equations adjacent to the corresponding boundaries are modified accordingly. Note that the right-hand side does not change for free slip boundary conditions.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"South","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij +  SWv_y(i-1j)+SEv_y(ij)+Wv_x(i-1j)+  Cv_x(ij)+  Ev_x(i+1j)+NWv_y(i-1j+1)+NEv_y(ij+1)+Nv_x(ij+1) = 0\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltax^2 left( eta_c(ij) + eta_c(i-1j) right) - fraceta_v(ij+1)Deltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"North","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij+  Sv_x(ij-1)+SWv_y(i-1j)+SEv_y(ij)+Wv_x(i-1j)+  Cv_x(ij)+   Ev_x(i+1j)+NWv_y(i-1j+1)+NEv_y(ij+1) = 0\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltax^2left(eta_c(ij)+eta_c(i-1j)right)-fraceta_v(ij)Deltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Along the lateral boundaries (East, West), the central coefficient is set to:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and all other coefficients are set to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"West ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_CP_ij+P_SP_ij-1 +   Sv_y(ij-1) + SWv_x(ij-1) + SEv_x(i+1j-1) +   Cv_y(ij) +   Ev_y(i+1j) + NWv_x(ij) + NEv_x(i+1j) + Nv_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltay^2left(eta_c(ij)+eta_c(ij-1)right)-fraceta_v(i+1j)Deltax^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"East ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_CP_ij + P_SP_ij-1 +   Sv_y(ij-1) + SWv_x(ij-1) + SEv_x(i+1j-1) + Wv_y(i-1j) +   Cv_y(ij) +   NWv_x(ij) + NEv_x(i+1j) + Nv_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltay^2left(eta_c(ij)+eta_c(ij-1)right)-fraceta_v(ij)Deltax^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Along the horizontal boundaries (North, South), the central coefficient is set to:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and all other coefficients are set to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/#No-Slip","page":"2D","title":"No Slip","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Using equations (31)–(34), the coefficients of the equations adjacent to the corresponding boundaries and the right-hand side change as follows.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"South","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij+   SWv_y(i-1j)+SEv_y(ij)+Wv_x(i-1j)+   Cv_x(ij)+   Ev_x(i+1j)+NWv_y(i-1j+1)+NEv_y(ij+1)+Nv_x(ij+1) =   -2fraceta_v(ij)Deltay^2V_BCS\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltax^2left(eta_c(ij)+eta_c(i-1j)right)-fraceta_v(ij+1)Deltay^2-frac2eta_v(ij)Deltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"North ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_WP_i-1j+P_CP_ij+   Sv_x(ij-1)+SWv_y(i-1j)+SEv_y(ij)+Wv_x(i-1j)+   Cv_x(ij)+   Ev_x(i+1j)+NWv_y(i-1j+1)+NEv_y(ij+1) =   -2fraceta_v(ij+1)Deltay^2V_BCN\nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltax^2left(eta_c(ij)+eta_c(i-1j)right)-frac2eta_v(ij+1)Deltay^2-fraceta_v(ij)Deltay^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Along the lateral boundaries (East, West), the central coefficient is set to:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and all other coefficients are set to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"West ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_CP_ij + P_SP_ij-1 +   Sv_y(ij-1) + SWv_x(ij-1) + SEv_x(i+1j-1) +   Cv_y(ij) +   Ev_y(i+1j) + NWv_x(ij) + NEv_x(i+1j) + Nv_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y - 2fraceta_v(ij)Deltax^2V_BCW \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltay^2left(eta_c(ij)+eta_c(ij-1)right)-fraceta_v(i+1j)Deltax^2-2fraceta_v(ij)Deltax^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"East","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n P_CP_ij + P_SP_ij-1 +   Sv_y(ij-1) + SWv_x(ij-1) + SEv_x(i+1j-1) + Wv_y(i-1j) +   Cv_y(ij) +   NWv_x(ij) + NEv_x(i+1j) + Nv_y(ij+1) =   -fracrho_ij+rho_i+1j2 g_y -2fraceta_v(i+1j)Deltax^2V_BCE \nendgather*endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationC = -frac2Deltay^2left(eta_c(ij)+eta_c(ij-1)right)-frac2eta_v(i+1j)Deltax^2-fraceta_v(ij)Deltax^2endequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Along the horizontal boundaries (North, South), the central coefficient is set to:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC = 1\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and all other coefficients are set to zero.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For more details on the implementation, please refer to the source code.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/MomentumTwoD/#Continuum-Equation","page":"2D","title":"Continuum Equation","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The continuum equation provides a third equation that helps to solve for the third unknown, P.","category":"page"},{"location":"man/MomentumTwoD/#Stencil-3","page":"2D","title":"Stencil","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The corresponding numerical stencil includes only the horizontal and vertical velocity components (Figure 4).","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"(Image: StencilContinuum)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Figure 4. Numerical stencil for the continuum equation. ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Using the finite difference operators, equation (3) is defined as:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nfracv_x(i+1j)-v_x(ij)Deltax + fracv_y(ij+1)-v_y(ij)Deltay = 0\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nC_xv_x(ij) + E_xv_x(i+1j) + C_yv_y(ij) + N_yv_y(ij+1) = 0\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"with ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nbeginsplit\n-C_x = E_x = frac1Deltax \n-C_y = N_y = frac1Deltay\nendsplit\nendequation","category":"page"},{"location":"man/MomentumTwoD/#Solution","page":"2D","title":"Solution","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"To solve the linear system, the coefficient matrix boldK must be assembled by collecting all coefficients associated with the discretized equations. Additionally, the right-hand side vector vecrhs must be constructed, typically based on boundary and body forces (e.g., gravity). This setup is required, at minimum, for a direct solution.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Construction of the coefficient matrix boldK requires assigning a unique index to each unknown variable at every relevant grid point, ensuring a one-to-one correspondence between equations and unknowns. The indexing proceeds by:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Enumerating all equations for the x-component of momentum (unknown v_x),\nFollowed by the y-component of momentum (unknown v_y),\nAnd finally the mass conservation equations (unknown P).","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The numbering for each equation is then defined as: ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-compnent (v_x) ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nii_x = 1 textrm-- left(nv_x cdot nc_yright)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component (v_y)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nii_y = left(nv_x cdot nc_y + 1 right) textrm-- left(nv_x cdot nc_y + nc_x cdot nv_yright)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"conituum equation (P)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nii_p = left(nv_x cdot nc_y + nc_x cdot nv_y + 1right) textrm-- left(nv_x cdot nc_y + nc_x cdot nv_y + nc_x cdot nc_yright)\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where nc_i and nv_i are the numbers of centroids and vertices in the i-th direction, respectively. ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Each row (ii) of the matrix boldK corresponds to one discretized equation. The nonzero entries within a row appear at columns i_k, each representing a neighboring variable involved in the stencil (see Figures 2–4). These column indices are computed relative to the row’s associated central index i_c.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Constant Viscosity","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\ni_S  = ii_x - nv_x \ni_W  = ii_x - 1 \ni_C  = ii_x \ni_E  = ii_x + 1 \ni_N  = ii_x + nv_x \nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\ni_S  = ii_y - nc_x \ni_W  = ii_y - 1 \ni_C  = ii_y \ni_E  = ii_y + 1 \ni_N  = ii_y + nc_x \nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Variable Viscosity","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"x-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\ni_S  = ii_x - nv_x \ni_SW  = ii_y - 1 \ni_SE  = ii_y \ni_W  = ii_x - 1 \ni_C  = ii_x \ni_E  = ii_x + 1 \ni_NW  = ii_y + nc_x \ni_NE  = ii_y + nc_x + 1 \ni_N  = ii_x + nv_x \nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"y-component","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\ni_S  = ii_y - nc_x \ni_SW  = ii_x - nv_x \ni_SE  = ii_x - nv_x + 1 \ni_W  = ii_y - 1 \ni_C  = ii_y \ni_E  = ii_y + 1 \ni_NW  = ii_x \ni_NE  = ii_x + 1 \ni_N  = ii_y + nc_x \nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The coefficients for the conservation of mass remain the same independent of the state of the viscosity. ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"continuum (P)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\ni_S  = ii_y \ni_W  = ii_x \ni_C  = ii_p \ni_E  = ii_x + 1 \ni_N  = ii_y + nc_x \nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"This results in a coefficient matrix boldKii_ji_k in the form of: ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"(Image: CoefficientMatrix)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Figure 5. Coefficient matrix, constant viscosity. Non-zero entries of a coefficient matrix for a resolution of nc_x=nc_y=10 and a constant viscosity. Highlighted are the areas for the different equations: v_x - x-component of the momentum equation, v_y - y-component of the momentum equation, P - continuum equation. ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"(Image: CoefficientMatrix_vary)","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Figure 6. Coefficient matrix, variable viscosity. Non-zero entries of a coefficient matrix for a resolution of nc_x=nc_y=10 and a variable viscosity. Highlighted are the areas for the different equations: v_x - x-component of the momentum equation, v_y - y-component of the momentum equation, P - continuum equation. ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The right-hand side vector vecrhs is given by the boundary and initial conditions (see equations (14) - (44)). ","category":"page"},{"location":"man/MomentumTwoD/#Direct","page":"2D","title":"Direct","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Using a direct solution method, one needs to do a right division of the coefficient matrix by the right-hand side to obtain the solution vector:","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\nboldK backslash vecrhs = vecx\nendequation","category":"page"},{"location":"man/MomentumTwoD/#Defect-Correction","page":"2D","title":"Defect Correction","text":"","category":"section"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The defect correction method is particularly effective when solving non-linear systems. First, one needs to calculate the residual for each equation, where the unknowns are given by an initial guess (usually all equal to zero and the boundary conditions): ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Residual calculation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\nR_x  = fracpartialtau_xxpartialx + fracpartialtau_xypartialy - fracpartialPpartialx \nR_y  = fracpartialtau_yypartialy + fracpartialtau_yxpartialx - fracpartialPpartialy + rho g_y \nR_p  = fracpartialv_xpartialx + fracpartialv_ypartialy\nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"and in form of the finite difference operators: ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\nR_x  = fractau_xx(ij)-tau_xx(i-1j)Deltax + fractau_xy(ij+1)-tau_xy(ij)Deltay - fracP_ij-P_i-1jDeltax \nR_y  = fractau_yy(ij)-tau_yy(ij-1)Deltay + fractau_yx(i+1j)-tau_yx(ij)Deltax - fracP_ij-P_ij-1Deltay + fracrho_ij+rho_i+1j2 g_y \nR_p  = fracv_x(i+1j)-v_x(ij)Deltax + fracv_y(ij+1)-v_y(ij)Deltay\nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"If the velocity nodes are not located directly on the boundary, the corresponding ghost node values should be computed using equations (16)–(19) for free slip and equations (31)–(34) for no slip conditions. The stresses are either calculated via the viscosity at the vertices or the centroids. Similar to the direct method, the residuals R_x R_y textrm and  R_p are stored in a vector R with the numbering of each equation as shown in equations (83) - (87). The coefficient matrix boldK is the same as described before. ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For more details on the defect correction method for the Stokes equation see the 1-D documentation.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The correction vector delta is obtained by solving the following linear system: ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequation\ndelta=- boldK backslash R\nendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"The vector delta has a length equal to the total number of unknowns, i.e., left(nv_x cdot nc_y + nc_x cdot nv_y + nc_x cdot nc_yright), corresponding to v_x, v_y, and P across the domain.","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Finally one needs to update the initial guess by the correction term: ","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\nv_x  = v_xi + deltav_x \nv_y  = v_yi + deltav_y \nP  = P_i + deltaP\nendsplitendequation","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"where the indices of the vector delta correspond to the indices of the unknowns left(v_x v_y Pright) as shown in equations (83) - (87).","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"Note: To update the array of the unknowns v_x v_y P, one needs to assign the elements of the one-dimensional vector delta to the two-dimensional array following the numbering shown in equations (83) - (87).","category":"page"},{"location":"man/MomentumTwoD/","page":"2D","title":"2D","text":"For more information on how both methods are implemented see the examples.","category":"page"},{"location":"man/examples/AdvectionRestest2D/#[Advection;-Resolution-Test-(2D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/AdvectionEquation/2D_Advection_ResolutionTest.jl)","page":"Advection Resolution Test (2D)","title":"Advection; Resolution Test (2D)","text":"","category":"section"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"This example presents a quasi-resolution test for the 2D advection schemes. The setup is the same as in the 2D advection example.","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"To evaluate the efficiency of each advection scheme as resolution increases, the script computes the following metrics: ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"the maximum deviation of advected temperature from the maximum initial temperature, \nthe maximum temperature, and \nthe mean temperature. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"The first quantity reflects the maximum information loss due to numerical diffusion during the advection process. As the resolution increases, all metrics are expected to converge toward their respective initial values. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"using Plots, Interpolations, Statistics\nusing GeoModBox.AdvectionEquation.TwoD\nusing GeoModBox.InitialCondition, GeoModBox.Tracers.TwoD\nusing Base.Threads\nusing Printf","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"The following section defines the maximum resolution and the advection schemes to be tested. The maximum resolution is given by: ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"beginequation\nnx_max = nrnxny*nx_ini \nendequation","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"where nrnxny is a simple multiplication factor and nx_ini = 20 the initial resolution. The resolution in the vertical direction is set equal to that in the horizontal direction. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"@printf(\"Running on %d thread(s)\\n\", nthreads())\n\nnrnxny      =   10\nScheme      =   [\"upwind\",\"slf\",\"semilag\",\"tracers\"]\nns          =   size(Scheme,1)\n@show ns\nsave_fig    =   -1","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"The variable save_fig controls the plotting output of the script: ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"save_fig = -1 -> only plot the final result\nsave_fig = 0 -> plot every figure (Not recommended for large resolutions!)\nsave_fig = 1 -> save the gif animation for each model","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"For every other value, no plot is shown. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Next, initialize the statistical parameters used for the resolution analysis. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"# Statistical Parameter ============================================== #\nSt      = (\n    Δ           =   zeros(size(Scheme,1),nrnxny),    \n    nxny        =   zeros(size(Scheme,1),nrnxny),\n    Tmax        =   zeros(size(Scheme,1),nrnxny),\n    Tmean       =   zeros(size(Scheme,1),nrnxny),    \n)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"The next step defines the initial conditions, model geometry, and constants for visualization. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"# Define Initial Condition =========================================== #\n# Temperature - \n#   1) circle, 2) gaussian, 3) block\n# Velocity - \n#   1) RigidBody, 2) ShearCell\nIni         =   (T=:circle,V=:RigidBody,) \n# -------------------------------------------------------------------- #\n# Model Constants ==================================================== #\nM   =   (\n    xmin    =   0.0,\n    xmax    =   1.0,\n    ymin    =   0.0,\n    ymax    =   1.0,\n)\n# -------------------------------------------------------------------- #\n# Plot constants ===================================================== #\nPl  =   (\n    inc         =   5,\n    sc          =   1.0e9,\n    Minc        =   1, \n    Msz         =   0.2,\n)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"The simulation begins with a loop over the different advection schemes. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"for m = 1:ns # Loop over advection schemes\n    # Define Numerical Scheme ======================================== #\n    FD          =   (Method     = (Adv=Scheme[m],),)    \n    @printf(\"Advection Scheme: %s\\n \",string(FD.Method.Adv))\n    # ---------------------------------------------------------------- #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"For each scheme, a nested loop is used to iterate over different grid resolutions. Within the loop, one needs to update the grid resolution and coordinates. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"    for l = 1:nrnxny # Loop over differnet resolutions\n        # Numerical Constants ======================================== #\n        NC  =   (\n            x       =   l*20,       # Number of horizontal centroids\n            y       =   l*20,       # Number of vertical centroids\n        )\n        display(string(\"nx = \",NC.x,\", ny = \",NC.y))\n        NV =   (\n            x       =   NC.x + 1,   # Number of horizontal vertices\n            y       =   NC.y + 1,   # Number of vertical vertices\n        )\n        Δ   =   (\n            x   =   (abs(M.xmin)+M.xmax)/NC.x,\n            y   =   (abs(M.ymin)+M.ymax)/NC.y,\n        )\n        # ------------------------------------------------------------ #\n        # Grid ======================================================= #\n        x   =   (\n            c       =   LinRange(M.xmin + Δ.x/2.0, M.xmax - Δ.x/2.0, NC.x),\n            ce      =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),\n            v       =   LinRange(M.xmin, M.xmax , NV.x)    \n        )\n        y       = (\n            c       =   LinRange(M.ymin + Δ.y/2.0, M.ymax - Δ.y/2.0, NC.y),\n            ce      =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),\n            v       =   LinRange(M.ymin, M.ymax, NV.y),    \n        )\n        x1      =   ( \n            c2d     =   x.c .+ 0*y.c',\n            v2d     =   x.v .+ 0*y.v', \n            vx2d    =   x.v .+ 0*y.ce',\n            vy2d    =   x.ce .+ 0*y.v',\n        )\n        x   =   merge(x,x1)\n        y1      =   (\n            c2d     =   0*x.c .+ y.c',\n            v2d     =   0*x.v .+ y.v',\n            vx2d    =   0*x.v .+ y.ce',\n            vy2d    =   0*x.ce .+ y.v',\n        )\n        y   =   merge(y,y1)\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"To enable visualization, the output path and filename for the animation are defined. In addition, memory is allocated for the required data fields. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"        # Animationsettings =0======================================== #\n        path        =   string(\"./examples/AdvectionEquation/Results/\")\n        anim        =   Plots.Animation(path, String[] )\n        filename    =   string(\"2D_advection_\",Ini.T,\"_\",Ini.V,\n                                \"_\",FD.Method.Adv,\"_\",NC.x,\"_\",NC.y,\n                                \"_nth_\",nthreads())\n        # ------------------------------------------------------------ #\n        # Array Initialization ======================================= #\n        D       =   (\n            T       =   zeros(Float64,(NC.x,NC.y)),\n            T_ex    =   zeros(Float64,(NC.x+2,NC.y+2)),\n            T_exo   =   zeros(Float64,(NC.x+2,NC.y+2)),\n            vx      =   zeros(Float64,(NV.x,NV.y+1)),\n            vy      =   zeros(Float64,(NV.x+1,NV.y)),    \n            vxc     =   zeros(Float64,(NC.x,NC.y)),\n            vyc     =   zeros(Float64,(NC.x,NC.y)),\n            vc      =   zeros(Float64,(NC.x,NC.y)),\n            wt      =   zeros(Float64,(NC.x,NC.y)),\n            wtv     =   zeros(Float64,(NV...)),\n            Tmax    =   [0.0],\n            Tmin    =   [0.0],\n            Tmean   =   [0.0],\n        )","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Now, one can calculate the initial conditions. Here, the build-in functions for the initial temperature and velocity conditions, IniTemperature!() and IniVelocity!(), respectively, are used. For more informaion please refer to the documentaion. Following the velocity initialization, one can caluclate the velocity on the centroids. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"        # Initial Condition ========================================== #\n        # Temperature ---\n        IniTemperature!(Ini.T,M,NC,Δ,D,x,y)\n        if FD.Method.Adv == \"slf\"\n            D.T_exo    .=  D.T_ex\n        end\n        # Velocity ---\n        IniVelocity!(Ini.V,D,NV,Δ,M,x,y)        \n        # Get the velocity on the centroids ---\n        @threads for i = 1:NC.x\n            for j = 1:NC.y\n                D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2\n                D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2\n            end\n        end\n        @. D.vc        = sqrt(D.vxc^2 + D.vyc^2)\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Now, one needs to define the time parameter. Here, the maximum time is set such that the one full rotation of the anomaly is achieved. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"        # Time ======================================================= #\n        T   =   ( \n            tmax    =   [0.0],  \n            Δfac    =   1.0,    # Courant time factor, i.e. dtfac*dt_courant\n            Δ       =   [0.0],\n        )\n        T.tmax[1]   =   π*((M.xmax-M.xmin)-Δ.x)/maximum(D.vc)   # t = U/v [ s ]\n        T.Δ[1]      =   T.Δfac * minimum((Δ.x,Δ.y)) / \n                    (sqrt(maximum(abs.(D.vx))^2 + maximum(abs.(D.vy))^2))\n        nt          =   ceil(Int,T.tmax[1]/T.Δ[1])\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"In case tracer are required one needs to initialize them in the following. For more information please refer to the documentation.","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"        # Tracer Advection =========================================== #\n        if FD.Method.Adv == \"tracers\"\n            # Tracer Initialization ---\n            nmx,nmy     =   3,3\n            noise       =   1\n            nmark       =   nmx*nmy*NC.x*NC.y\n            Aparam      =   :thermal\n            MPC         =   (\n                c       =   zeros(Float64,(NC.x,NC.y)),\n                v       =   zeros(Float64,(NV.x,NV.y)),\n                th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),\n                thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),\n            )\n            MPC1        = (\n                PG_th   =   [similar(D.T) for _ = 1:nthreads()],    # per thread\n                PV_th   =   [similar(D.wtv) for _ = 1:nthreads()],   # per thread\n                wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread\n                wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread\n            )\n            MPC     =   merge(MPC,MPC1)\n            Ma      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,0,0)\n            # RK4 weights ---\n            rkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\n            rkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping\n            # Interpolate on centroids ---\n            @threads for k = 1:nmark\n                Ma.T[k] =   FromCtoM(D.T_ex, k, Ma, x, y, Δ, NC)\n            end\n            # Count marker per cell ---\n            CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)\n        end\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Let's visualize the initial condition first. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"        # Visualize initial condition -------------------------------- #\n        if FD.Method.Adv == \"tracers\"\n            p = heatmap(x.c,y.c,(D.T./D.Tmax)',color=:thermal, \n                    aspect_ratio=:equal,xlims=(M.xmin, M.xmax), \n                    ylims=(M.ymin, M.ymax),clims=(0.5, 1.0),\n                    colorbar=true,layout=(1,2),subplot=1)\n            quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                    y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                    quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                            D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n                    color=\"white\",layout=(1,2),subplot=1)\n            heatmap!(p,x.c,y.c,MPC.c',color=:inferno, \n                    aspect_ratio=:equal,xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax),\n                    colorbar=true,clims=(0.0, 18.0),title=:\"Marker per cell\",\n                    layout=(1,2),subplot=2)\n        else\n            p = heatmap(x.c , y.c, (D.T./D.Tmax)', \n                    color=:thermal, colorbar=true, aspect_ratio=:equal, \n                    xlabel=\"x\", ylabel=\"z\", \n                    title=\"Temperature\", \n                    xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax), \n                    clims=(0.5, 1.0))\n            quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                    quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                            D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n                    color=\"white\")\n        end\n        if save_fig == 1\n            Plots.frame(anim)\n        elseif save_fig == 0\n            display(p)\n        end\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"(Image: APIniPlot)","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Figure 1. Initial condition. Initial rigid body rotation setup including a circular shaped temperature anomaly. The temperature field is normalized by its maximum value so that the anomaly intensity equals one. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Now, one can start the time loop and the advection. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"        # Time Loop ================================================== #\n        for i=2:nt\n            #@printf(\"Time step: #%04d\\n \",i) \n\n            if FD.Method.Adv == \"upwind\"\n                upwindc2D!(D.T,D.T_ex,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n            elseif FD.Method.Adv == \"slf\"\n                slfc2D!(D.T,D.T_ex,D.T_exo,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n            elseif FD.Method.Adv == \"semilag\"\n                semilagc2D!(D.T,D.T_ex,D.vxc,D.vyc,[],[],x,y,T.Δ[1])\n            elseif FD.Method.Adv == \"tracers\"\n                # Advect tracers ---\n                AdvectTracer2D(Ma,nmark,D,x,y,T.Δ[1],Δ,NC,rkw,rkv,1)\n                # CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,i)\n                CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,i)\n                \n                # Interpolate temperature from tracers to grid ---\n                Markers2Cells(Ma,nmark,MPC.PG_th,D.T,MPC.wt_th,D.wt,x,y,Δ,Aparam,0)           \n                D.T_ex[2:end-1,2:end-1]     .= D.T\n            end\n            \n            display(string(\"ΔT = \",((maximum(filter(!isnan,D.T))-D.Tmax[1])/D.Tmax[1])*100))\n\n            # Plot Solution ---\n            if mod(i,10) == 0 || i == nt\n                if FD.Method.Adv == \"tracers\"\n                    p = heatmap(x.c,y.c,(D.T./D.Tmax)',color=:thermal, \n                            aspect_ratio=:equal,xlims=(M.xmin, M.xmax), \n                            ylims=(M.ymin, M.ymax),clims=(0.5, 1.0),\n                            colorbar=true,layout=(1,2),subplot=1)\n                    quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                            y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                            quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                                    D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n                            color=\"white\",layout=(1,2),subplot=1)\n                    heatmap!(p,x.c,y.c,MPC.c',color=:inferno, \n                            aspect_ratio=:equal,xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax),\n                            colorbar=true,clims=(0.0, 18.0),title=:\"Marker per cell\",\n                            layout=(1,2),subplot=2)\n                else\n                    p = heatmap(x.c , y.c, (D.T./D.Tmax)', \n                            color=:thermal, colorbar=true, aspect_ratio=:equal, \n                            xlabel=\"x\", ylabel=\"z\", \n                            title=\"Temperature\", \n                            xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax), \n                            clims=(0.5, 1.0))\n                    quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                                y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                                quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                                        D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n                            color=\"white\")\n                end\n                if save_fig == 1\n                    Plots.frame(anim)\n                elseif save_fig == 0\n                    display(p)                        \n                end\n            end\n                \n        end # End Time loop","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"If wanted, a gif animation is generated in the following. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"        # Save Animation ============================================= #\n        if save_fig == 1\n            # Write the frames to a GIF file\n            Plots.gif(anim, string( path, filename, \".gif\" ), fps = 15)\n            foreach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\n        elseif save_fig == 0\n            display(plot(p))\n        end\n        # Statistical Values for Each Scheme and Resolution ---\n        St.Δ[m,l]       =   abs((maximum(filter(!isnan,D.T))-D.Tmax[1])/D.Tmax[1])*100\n        St.nxny[m,l]    =   1/NC.x/NC.y\n        St.Tmax[m,l]    =   maximum(filter(!isnan,D.T))\n        St.Tmean[m,l]   =   mean(abs.(filter(!isnan,D.T)))\n        # ------------------------------------------------------------ #\n\n    end # End resolution loop\n\nend # End method loop","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Let's visualize and store the statistical parameters. ","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"q   =   plot(0,0,layout=(1,3))\nfor m=1:ns    \n    plot!(q,St.nxny[m,:],St.Δ[m,:],\n                marker=:circle,markersize=3,label=Scheme[m],\n                xaxis=:log,yaxis=:log,\n                xlims=(minimum(St.nxny), maximum(St.nxny)), \n                ylims=(1e-15, 1e3), \n                xlabel=\"1/nx/ny\",ylabel=\"ΔT[%]\",layout=(1,3),\n                subplot=1)\n    plot!(q,St.nxny[m,:],St.Tmax[m,:],\n                marker=:circle,markersize=3,label=\"\",\n                xaxis=:log,yaxis=:log,\n                xlims=(minimum(St.nxny), maximum(St.nxny)), \n                ylims=(1e2, 1e5),\n                xlabel=\"1/nx/ny\",ylabel=\"T_{max}\",\n                subplot=2)\n    plot!(q,St.nxny[m,:],St.Tmean[m,:],\n                marker=:circle,markersize=3,label=\"\",\n                xaxis=:log,yaxis=:log,\n                xlims=(minimum(St.nxny), maximum(St.nxny)), \n                ylims=(1e2, 1e4), \n                xlabel=\"1/nx/ny\",ylabel=\"⟨T⟩\",\n                subplot=3)\n    display(q)\nend\n# --------------------------------------------------------------------- #\n# Save Final Figure =================================================== #\nif save_fig == 1 || save_fig == -1\n    savefig(q,string(\"./examples/AdvectionEquation/\",\n                        \"Results/2D_advection_\",Ini.T,\"_\",\n                        Ini.V,\"_ResTest.png\"))\nend\n# --------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"(Image: AdvResFinal)","category":"page"},{"location":"man/examples/AdvectionRestest2D/","page":"Advection Resolution Test (2D)","title":"Advection Resolution Test (2D)","text":"Figure 2. Advection Resolution Test.   Deviation, maximum, and mean temperature for each advection scheme across increasing grid resolutions. ","category":"page"},{"location":"man/exercises/04_2D_Diffusion_Stationary/#[04-2D-Heat-Diffusion-(stationary)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/04_2D_Diffusion_Stationary_en.ipynb)","page":"04 - 2D Heat Diffusion (stationary)","title":"04 - 2D Heat Diffusion (stationary)","text":"","category":"section"},{"location":"man/exercises/04_2D_Diffusion_Stationary/","page":"04 - 2D Heat Diffusion (stationary)","title":"04 - 2D Heat Diffusion (stationary)","text":"This exercise focuses on solving the stationary two-dimensional heat diffusion equation with internal heat generation. The problem setup resembles a simplified model of localized heat sources, such as radioactive waste disposal in a salt dome. The stationary case is particularly useful for introducing matrix assembly and boundary-condition handling in two dimensions.  ","category":"page"},{"location":"man/exercises/04_2D_Diffusion_Stationary/","page":"04 - 2D Heat Diffusion (stationary)","title":"04 - 2D Heat Diffusion (stationary)","text":"The main objectives are:  ","category":"page"},{"location":"man/exercises/04_2D_Diffusion_Stationary/","page":"04 - 2D Heat Diffusion (stationary)","title":"04 - 2D Heat Diffusion (stationary)","text":"Formulating the stationary heat diffusion equation in two dimensions,  \nDiscretizing the equation on a structured grid using finite differences,  \nImplementing boundary conditions (Dirichlet and Neumann) with ghost nodes,  \nAssembling and solving the resulting linear system of equations, and  \nVisualizing the stationary temperature field.  ","category":"page"},{"location":"man/exercises/04_2D_Diffusion_Stationary/","page":"04 - 2D Heat Diffusion (stationary)","title":"04 - 2D Heat Diffusion (stationary)","text":"The resulting stationary solution is illustrated in Figure 1.  ","category":"page"},{"location":"man/exercises/04_2D_Diffusion_Stationary/","page":"04 - 2D Heat Diffusion (stationary)","title":"04 - 2D Heat Diffusion (stationary)","text":"(Image: Exercise04)  ","category":"page"},{"location":"man/exercises/04_2D_Diffusion_Stationary/","page":"04 - 2D Heat Diffusion (stationary)","title":"04 - 2D Heat Diffusion (stationary)","text":"Figure 1. Stationary two-dimensional temperature distribution.","category":"page"},{"location":"man/examples/ContinentalGeotherm/#[Continental-Geotherm](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/1D/ContinentalGeotherm_1D.jl)","page":"Continental Geotherm (1D)","title":"Continental Geotherm","text":"","category":"section"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"The 1-D temperature profile of a continental geotherm can be calculated by solving the conductive part of the 1-D temperature equation using variable thermal parameters within a conservative finite difference scheme (currently only including a radiogenic heat source). We use the 1-D solver for variable thermal parameters, since the thermal conductivity varies within each lithospheric layer. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"In a conservative 1-D finite difference scheme, temperature is defined at the centroids, while the vertical heat flux and thermal conductivity k are defined at the vertices.","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"The 1-D temperature equation is given by: ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"beginequation\nrho c_p fracpartialTpartialt = fracpartialq_ypartialy + rho H\nendequation","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"where the heat flux q_y is defined as:","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"beginequation\nleft q_ym = -k_m fracpartial Tpartial yrightvert_m textrmfor m = 1nv \nendequation","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"where rho, c_p, T, t, k, H, y, and nv represent the density [kg/m³], the specific heat capacity [J/kg/K], the temperature [K], the time [s], the thermal conductivity [W/m/K], the heat generation rate per mass [W/kg], the depth [m], and the number of vertices, respectively. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"For more details on how to discretize the equation using an explicit, forward Euler finite difference scheme see the documentation.","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"using Plots\nusing GeoModBox.HeatEquation.OneD","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Let's start with the definition of the geometrical, numerical, and physical constants: ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Constants --------------------------------------------------------- #\nH           =   200e3               #   Hight of the model [ m ]\nyUC         =   10e3                #   Depth of the upper crust [ m ]\nyLC         =   35e3                #   Depth of the lower crust [ m ]\n        \nnc          =   200                 #   Number of grid points\nΔy          =   H/nc                #   Grid resolution\n\n# Depth [m] ---\nyc          =   LinRange(-H + Δy/2.0,0.0 - Δy/2.0,nc)     \nyv          =   LinRange(-H,0,nc+1)\n        \nPy  =   (\n    # Mantle properties ---\n    ρM      =   3000,               #   Density [ kg/m^3 ]\n    cpM     =   1000,               #   Heat capacity [ J/kg/K ]\n    kM      =   2.3,                #   Conductivity [ W/m/K ]\n    HM      =   2.3e-12,            #   Heat generation rate [W/kg]; Q = ρ*H;2.3e-12\n        \n    # Upper crust properties ---\n    ρUC     =   2700,               #   [ kg/m^3 ]\n    kUC     =   3.0,                #   [ W/m/K ]\n    HUC     =   617e-12,            #   [ W/kg ]\n    cpUC    =   1000,\n        \n    # Lower crust properties ---\n    ρLC     =   2900,               #   [ kg/m^3 ]\n    kLC     =   2.0,                #   [ W/m/K ]\n    HLC     =   43e-12,             #   [ W/kg ]\n    cpLC    =   1000,\n)                \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"In the following, one needs to define the initial and boundary condition: ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Temperature at the surface and bottom.\nLinear increasing temperature profile assuming a certain adiabatic gradient and potential mantle temperature.","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Initial Condition ------------------------------------------------- #\nT   =   (\n    Tpot    =   1315 + 273.15,      #   Potential temperautre [ K ]\n    ΔTadi   =   0.5,                #   Adiabatic temperature gradient [ K/km ]\n    Ttop    =   273.15,             #   Surface temperature [ K ]\n    T_ex    =   zeros(nc+2,1),    \n)\nT1  =   (\n    Tbot    =   T.Tpot + T.ΔTadi*abs(H/1e3),    # Bottom temperature [ K ]\n    T       =   T.Tpot .+ abs.(yc./1e3).*T.ΔTadi,   # Initial T-profile [ K ]\n)\nT   =   merge(T,T1)\n\nTini                =   zeros(nc,1)\nTini                .=   T.T\nT.T_ex[2:end-1]     .=  T.T\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Either Dirichlet or Neumann thermal boundary conditions can be applied at the surface and bottom. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Boundary conditions ----------------------------------------------- #\nBC      =   (\n    type    = (N=:Dirichlet, S=:Dirichlet),\n    val     = (N=T.Ttop,S=T.Tbot)\n)\n# If Neumann boundary conditions are choosen, the following values result in the given heatflux for the given thermal conductivity k. \n# S      =   -0.03;          # c     =   -k/q -> 90 mW/m^2\n# N      =   -0.0033;        # c     =   -k/q -> 10 mW/m^2\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Now, one needs to define the multiplication factor fac of the diffusion stability criterion for the explicit thermal solver. This factor controls the stability criterion. If fac exceeds 1, the solver becomes unstable.  ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Time stability criterion ------------------------------------------ #\nfac     =   0.9                 #   Courant criterion\ntmax    =   1000                 #   Lithosphere age [ Ma ]\ntsca    =   60*60*24*365.25     #   Seconds per year\n\nage     =   tmax*1e6*tsca        #   Age in seconds    \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"To verify that the initial and boundary conditions are properly defined by plotting the temperature profile. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Plot Initial condition -------------------------------------------- #\np = plot(T.T,yc./1e3, \n    label=\"\", \n    xlabel=\"T [ K ]\", ylabel=\"z [ km ]\", \n    title=\"Initial Temperature\",\n    xlim=(T.Ttop,T.Tbot),ylim=(-H/1e3,0))\ndisplay(p)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"(Image: CG1D_ini)","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Figure 1. Initial temperature profile.","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Define the fields for the thermal parameters and assign the corresponding values of each lithospheric layer (upper and lower crust, and lithospheric mantle) to them. Additionally, the thermal diffusivity kappa and initialize the vertical heat flux q need to be defined. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Setup fields ------------------------------------------------------ #\nPy1     =   (\n    k            =   zeros(nc+1,1),\n    ρ            =   zeros(nc,1),\n    cp           =   zeros(nc,1),\n    H            =   zeros(nc,1),\n    )\nPy  = merge(Py,Py1)\n    \n# Upper Crust ---\nPy.k[yv.>=-yUC]     .=   Py.kUC\nPy.ρ[yc.>=-yUC]     .=   Py.ρUC\nPy.cp[yc.>=-yUC]    .=   Py.cpUC\nPy.H[yc.>=-yUC]     .=   Py.HUC    \n# Lower Crust ---\nPy.k[yv.>=-yLC .&& yv.<-yUC]     .=   Py.kLC\nPy.ρ[yc.>=-yLC .&& yc.<-yUC]     .=   Py.ρLC\nPy.cp[yc.>=-yLC .&& yc.<-yUC]    .=   Py.cpLC\nPy.H[yc.>=-yLC .&& yc.<-yUC]     .=   Py.HLC   \n# Mantle ---\nPy.k[yv.<-yLC]  .=   Py.kM\nPy.ρ[yc.<-yLC]  .=   Py.ρM\nPy.cp[yc.<-yLC] .=   Py.cpM\nPy.H[yc.<-yLC]  .=   Py.HM\n\nPy2     =   (\n    # Thermal diffusivity [ m^2/s ] \n    κ       =  maximum(Py.k)/minimum(Py.ρ)/minimum(Py.cp),     \n    )\nPy  =   merge(Py,Py2)\nT2  =   (\n    q   =   zeros(nc+1,1),\n    )\nT   =   merge(T,T2)  \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Now, one can calculate the time stability criterion. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Time stability criterion ------------------------------------------ #\nΔtexp   =   Δy^2/2/Py.κ             #   Stability criterion for explicit\nΔt      =   fac*Δtexp               #   total time step\n\nnit     =   ceil(Int64,age/Δt)      #   Number of iterations    \n\ntime    =   zeros(1,nit)            #   Time array\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"With all parameters and constants defined to solve the 1-D temperature equation for each time step in a for loop. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"The temperature conservation equation is solved via the function ForwardEuler1D!(), which updates the temperature profile T.T for each time step using the extended temperautre field T.T_ex, which include the ghost nodes. The temperature profile is plotted for a certain time.  ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Time Loop --------------------------------------------------------- #\ncount   =   1\nfor i = 1:nit\n    if i > 1\n        time[i]     =   time[i-1] + Δt\n    elseif time[i] > age\n        Δt          =   age - time[i-1]\n        time[i]     =   time[i-1] + Δt\n    end\n    ForwardEuler1D!(T,Py,Δt,Δy,nc,BC)\n    if i == nit || abs(time[i]/1e6/tsca - count*100.0) < Δt/1e6/tsca        \n        println(string(\"i = \",i,\", time = \", time[i]/1e6/tsca))                    \n        p = plot!(T.T.-T.Ttop,yc./1e3, \n            label=string(\"t = \",ceil(time[i]/1e6/tsca),\"[Ma]\"), \n            xlabel=\"T [°C]\", ylabel=\"z [m]\", \n            title=\"Continental Geotherm\",\n            xlim=(0,T.Tbot-T.Ttop),ylim=(-H/1e3,0))\n        display(p)\n        count = count + 1\n    end\nend\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"(Image: CG1D_evolve)","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Figure 2. Evolution of the temperature profile with depth in 5 Ma steps.","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"For the final time step, a depth profile for the vertical heat flux is calculated. Therefore, one needs to update the temperature at the ghost nodes to calculate the heat flux at the boundary. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Calculate heaf flow ----------------------------------------------- #\n# South ---\nT.T_ex[1]   =   (BC.type.S==:Dirichlet) * (2 * BC.val.S - T.T_ex[2]) + \n                (BC.type.S==:Neumann) * (T.T_ex[2] - BC.val.S*Δy)\n# North ---\nT.T_ex[end] =   (BC.type.N==:Dirichlet) * (2 * BC.val.N - T.T_ex[nc+1]) +\n                (BC.type.N==:Neumann) * (T.T_ex[nc+1] + BC.val.N*Δy)\nif size(Py.k,1)==1\n    for j=1:nc+1\n        T.q[j]  =   -Py.k * \n            (T.T_ex[j+1] - T.T_ex[j])/Δy\n    end    \nelse\n    for j=1:nc+1\n        T.q[j]  =   -Py.k[j] * \n            (T.T_ex[j+1] - T.T_ex[j])/Δy\n    end\nend\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Finally, compute the temperature profile for a continental geotherm using the analytical expression of an infinite half-space cooling model for a certain age. The analytical solution is plotted in the final figure, together with the final numerical temperature profile and the heat flux profile. ","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"# Plot profile if requested ----------------------------------------- #\nq = plot(T.T.-T.Ttop,yc./1e3, \n        label=string(\"t = \",ceil(maximum(time)/1e6/tsca),\"[Ma]\"), \n        xlabel=\"T [°C]\", ylabel=\"z [m]\",\n        title=\"Continental Geotherm\",\n        xlim=(0,T.Tbot-T.Ttop),ylim=(-H/1e3,0),\n        layout=(1,3),subplot=1)    \nq = plot!(T.q.*1e3,yv./1e3, \n        label=\"\", \n        xlabel=\"q [ mW ]\", ylabel=\"z [m]\", \n        title=\"Heat Flux\",\n        ylim=(-H/1e3,0),\n        subplot=2) \nq = plot!(Py.k,yv./1e3,label=\"k [W/m/K]\",\n        xlabel=\"k,ρ,cp,Q\", ylabel=\"z [km]\",\n        title=\"Thermal parameters\",\n        subplot=3)       \nq = plot!(Py.cp./1e3,yc./1e3,label=\"cp [kJ/kg/K]\",\n        subplot=3)\nq = plot!(Py.ρ,yc./1e3,label=\"ρ [kg/m³]\",                \n        subplot=3)\nq = plot!(Py.H.*(Py.ρ./1e3),yc./1e3,label=\"Q [mW/m³]\",\n        subplot=3)\ndisplay(q)\n# Save figures ---\nsavefig(q,\"./examples/DiffusionEquation/1D/Results/ContinentalGeotherm_1D.png\")\nsavefig(p,\"./examples/DiffusionEquation/1D/Results/ContinentalGeotherm_1D_evolve.png\")\n# ======================================================================= #","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"(Image: CG1D_final)","category":"page"},{"location":"man/examples/ContinentalGeotherm/","page":"Continental Geotherm (1D)","title":"Continental Geotherm (1D)","text":"Figure 3. Final temperature, heat flux, and thermal parameter depth profiles.","category":"page"},{"location":"man/examples/PoissonVariablek/#[Poisson-Problem-(variable-k)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Poisson_variable_k.jl)","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem (variable k)","text":"","category":"section"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"This example solves the steady-state 2-D temperature equation—i.e., the Poisson equation—assuming a variable thermal conductivity k. ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"For more details on the model setup and the physics or the numerical scheme, please see the exercise or the documentation","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"using GeoModBox.HeatEquation.TwoD, ExtendableSparse, Plots","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"Now, one needs to define the geometrical and physical constants. ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"# Physikalischer Parameter ---------------------------------------------- #\nP       =   (\n    L           =   4e3,      #   [m]\n    H           =   2e3,      #   [m]\n    k1          =   3.2,      #   Waermeleitfaehigkeit, W/m/K\n    k2          =   6.2,      #   Waermeleitfaehigkeit, W/m/K\n    Wcave       =   200,      #\n    Hcave       =   200,      #\n    Dcave       =   1e3,      # \n    Xcave       =   2.0e3, \n    Q           =   0.3       # W/m³ Q = rho*H\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"Next, define the grid and its coordinates.","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"# Numerische Parameter -------------------------------------------------- #\nNC      =   (\n    x           =   641,      #   Gitterpunkte in x-Richtung\n    y           =   321       #   Gitterpunkte in y-Richtung\n)\nNV      =   (\n    x           =   NC.x + 1, \n    y           =   NC.y + 1\n)\n# Initialize grid spacing ----------------------------------------------- #\nΔ       = (\n    x       =   P.L/NC.x,\n    y       =   P.H/NC.y\n)\n# ----------------------------------------------------------------------- #\n# Generate the grid ----------------------------------------------------- #\nx       = (\n    c       =   LinRange(0.0 + Δ.x/2.0, P.L - Δ.x/2.0, NC.x),\n    v       =   LinRange(0.0, P.L, NV.x)\n)\ny       = (\n    c       =   LinRange(-P.H + Δ.y/2.0, 0.0 - Δ.y/2.0, NC.y),\n    v       =   LinRange(-P.H, 0.0, NV.y)\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"Dirichlet boundary conditions are applied on all sides. ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"# Boundary conditions --------------------------------------------------- #\nBC      =   (\n    type    = (W=:Dirichlet, E=:Dirichlet, N=:Dirichlet, S=:Dirichlet),\n    # type    = (W=:Dirichlet, E=:Dirichlet, N=:Dirichlet, S=:Dirichlet),\n    val     = (W=zeros(NC.y,1),E=zeros(NC.y,1),N=zeros(NC.x,1),S=zeros(NC.x,1))\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"In addition to temperature and heat source terms, two fields must be defined for thermal conductivity—one for the horizontal and one for the vertical components. The heat source and thermal conductivity must be assigned to their corresponding grid nodes. ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"# Initialcondition ------------------------------------------------------ #\nD       = ( \n    Q       =   zeros(NC...),           # (row,col) \n    T       =   zeros(NC...),\n    kx      =   zeros(NV.x,NC.y),\n    ky      =   zeros(NC.x,NV.y)\n)\n# Heat production rate in the anomaly ---\nfor i = 1:NC.x, j = 1:NC.y\n    if x.c[i] >= (P.Xcave-P.Wcave/2.0) && x.c[i] <=(P.Xcave+P.Wcave/2.0) && \n        y.c[j] >= -P.Dcave-P.Hcave/2.0 && y.c[j] <= -P.Dcave+P.Hcave/2.0 \n        D.Q[i,j]    = P.Q\n    end\nend\nD.kx[:,y.c.>=-P.H/2.0]      .=  P.k1\nD.kx[:,y.c.<-P.H/2.0]       .=  P.k2\nD.ky[x.c.>=P.L/2.0,:]       .=  P.k1\nD.ky[x.c.<P.L/2.0,:]        .=  P.k2\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"To solve the linear system of equations, define the coefficient matrix, determine the degrees of freedom, and initialize the right-hand side vector. ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"# Linear System of Equations -------------------------------------------- #\nNum     =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)\nndof    =   maximum(Num.T)\nK       =   ExtendableSparseMatrix(ndof,ndof)\nrhs     =   zeros(ndof)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"With all parameters defined, the linear system can now be solved using the function Poisson2D!(). ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"# Solve equation -------------------------------------------------------- #\nPoisson2D!(D.T, D.Q, D.kx, D.ky, Δ.x, Δ.y, NC, BC, K, rhs, Num )\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"Finally, the steady-state temperature solution is visualized along with the horizontal and vertical thermal conductivity fields for comparison.  ","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"# Plot solution --------------------------------------------------------- #\np = heatmap(x.c ./ 1e3, y.c ./ 1e3, D.T', \n        color=:viridis, colorbar=true, aspect_ratio=:equal, \n        xlabel=\"x [km]\", ylabel=\"z [km]\", \n        title=\"Stationary temperature field\", \n        xlims=(0, P.L/1e3), ylims=(-P.H/1e3, 0.0), \n        clims=(0, 900))\n\ncontour!(p, x.c ./ 1e3, y.c ./ 1e3, D.T', \n    levels=100:100:1500, linecolor=:black,subplot=1)\n\nq = heatmap(x.v ./ 1e3, y.c ./ 1e3, D.kx', \n    color=:viridis, colorbar=true, aspect_ratio=:equal, \n    xlabel=\"x [km]\", ylabel=\"z [km]\", \n    title=\"horizontal conductivity\", \n    xlims=(0, P.L/1e3), ylims=(-P.H/1e3, 0.0), \n    layout=(1,2),subplot=1)\nheatmap!(q,x.c ./ 1e3, y.v ./ 1e3, D.ky', \n    color=:viridis, colorbar=true, aspect_ratio=:equal, \n    xlabel=\"x [km]\", ylabel=\"z [km]\", \n    title=\"vertical conductivity\", \n    xlims=(0, P.L/1e3), ylims=(-P.H/1e3, 0.0), \n    subplot=2)\n\ndisplay(p)\ndisplay(q)\n\nsavefig(p,\"./examples/DiffusionEquation/2D/Results/Poisson_variable_k_01.png\")\nsavefig(q,\"./examples/DiffusionEquation/2D/Results/Poisson_variable_k_02.png\")\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"(Image: PPvari)","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"Figure 1. Temperature distribution for variable thermal parameters.","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"(Image: PPvari)","category":"page"},{"location":"man/examples/PoissonVariablek/","page":"Poisson Problem; variable k (2D)","title":"Poisson Problem; variable k (2D)","text":"Figure 2. Thermal conductivity distribution.","category":"page"},{"location":"man/license/","page":"License","title":"License","text":"MIT License","category":"page"},{"location":"man/license/","page":"License","title":"License","text":"Copyright (c) 2024 Goethe Universität Frankfurt, Institut für Geowissenschaften","category":"page"},{"location":"man/license/","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"man/license/","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"man/license/","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/#[05-2D-Heat-Diffusion-(transient,-plume)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/05_2D_Diffusion_TD_Plume_en.ipynb)","page":"05a - 2D Heat Diffusion (Plume)","title":"05 - 2D Heat Diffusion (transient, plume)","text":"","category":"section"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"This exercise focuses on solving the transient two-dimensional heat diffusion equation in the presence of a localized plume at the base of the domain. The setup represents a simplified geodynamic scenario where a plume head heats the lithosphere over time. The transient case is particularly useful to compare explicit and implicit time integration schemes and to understand their numerical properties.","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"The main objectives are:","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"Formulating and discretizing the transient 2D heat diffusion equation,  \nImplementing explicit (Forward Euler) and implicit (Backward Euler) schemes,  \nApplying Dirichlet and Neumann boundary conditions with ghost nodes,  \nExploring stability constraints of the explicit scheme versus the unconditional stability of the implicit scheme, and  \nVisualizing the temporal evolution of the temperature field and extracting diagnostic profiles.  ","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"The evolution of the temperature field due to plume heating is illustrated in Figure 1. The vertical profiles and the maximum temperature over time are illustrated in Figure 2. ","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"(Image: Exercise05_1)  ","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"Figure 1. Time-dependent evolution of the two-dimensional temperature field with basal plume heating using the explicit scheme. ","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"(Image: Exercise_05_2)","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Plume/","page":"05a - 2D Heat Diffusion (Plume)","title":"05a - 2D Heat Diffusion (Plume)","text":"Figure 2. Temperature-Depth profiles over time and the evolution of the maximum temperature with time. ","category":"page"},{"location":"man/listoffunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listoffunctions/","page":"List of functions","title":"List of functions","text":"Here an overview of all functions:","category":"page"},{"location":"man/listoffunctions/#GeoModBox.DataFields","page":"List of functions","title":"GeoModBox.DataFields","text":"DataFields()\n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.Geometry","page":"List of functions","title":"GeoModBox.Geometry","text":"Geometry()\n\nStructure to initialize the geometry of the model domain. \n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.GridSpacing","page":"List of functions","title":"GeoModBox.GridSpacing","text":"GridSpacing()\n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.Physics","page":"List of functions","title":"GeoModBox.Physics","text":"Physics()\n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.TimeParameter","page":"List of functions","title":"GeoModBox.TimeParameter","text":"TimeParameter()\n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.Dani_Solution_vec!-NTuple{9, Any}","page":"List of functions","title":"GeoModBox.Dani_Solution_vec!","text":"Dani_Solution_vec!(type,D,M,x,y,rad,mus_i,NC,NV)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Scaling.Constants","page":"List of functions","title":"GeoModBox.Scaling.Constants","text":"Constants\n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.Scaling.ScaleParameters!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.Scaling.ScaleParameters!","text":"ScaleParameters!(S,M,Δ,T,P,D)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Scaling.ScalingConstants!-Tuple{Any, Any}","page":"List of functions","title":"GeoModBox.Scaling.ScalingConstants!","text":"ScalingConstants!(M,P)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.OneD.AssembleMatrix1Dc!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.OneD.AssembleMatrix1Dc!","text":"AssembleMatrix1Dc!( κ, Δx, Δt, nc, BC, K )\n\nSetup the coefficient matrix for the linear system of equations. \n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.OneD.BackwardEuler1Dc!-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.OneD.BackwardEuler1Dc!","text":"BackwardEuler1Dc!( implicit, κ, Δx, Δt, nc, BC , K)\n\nSolves the onedimensional heat diffusion equation assuming no internal heating and constant thermal parameters using an implicit, backward euler finite difference scheme.\n\nThe temperature is defined on central nodes and the heat flux on the vertices.  Boundary conditions are currently limited to Dirichlet and Neumann. Using central  temperature nodes requires external ghost nodes, which are used to define the  boundary conditions. \n\nimplicit    : Tuple, containing the current temperature array T0 and \n              the new temperature array T\nκ           : Diffusivity [ m²/s ]\nΔt          : Time step [ s ]\nnc          : Number of central nodes\nΔx          : Grid spacing [ m ]\nBC          : Tuple for the boundary condition\nK           : Coefficient matrix for linear system of equations\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.OneD.CNA1Dc!-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.OneD.CNA1Dc!","text":"CNA1Dc!( cna, κ, Δx, Δt, nc, BC, K1, K2 )\n\nSolves the onedimensional heat diffusion equation assuming no internal heating and constant thermal parameters using Crank-Nicolson finite difference scheme.\n\nThe temperature is defined on central nodes and the heat flux on the vertices.  Boundary conditions are currently limited to Dirichlet and Neumann. Using central  temperature nodes requires external ghost nodes, which are used to define the  boundary conditions. \n\ncna         : Tuple, containing the current temperature array T0 and \n              the new temperature array T\nκ           : Diffusivity [ m²/s ]\nΔt          : Time step [ s ]\nnc          : Number of central nodes\nΔx          : Grid spacing [ m ]\nBC          : Tuple for the boundary condition\nK1          : Coefficient matrix for the unknow variables \nK2          : Coefficient matrix for the know variables\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.OneD.ComputeResiduals1Dc!-NTuple{5, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.OneD.ComputeResiduals1Dc!","text":"ComputeResiduals1Dc!( cna, κ, Δx, Δt, nc, BC, K1, K2 )\n\nComputes the residual of the onedimensional heat diffusion equation assuming  no internal heating and constant thermal parameters.\n\nThe temperature is defined on central nodes and the heat flux on the vertices.  Boundary conditions are currently limited to Dirichlet and Neumann. Using central  temperature nodes requires external ghost nodes, which are used to define the  boundary conditions. \n\ndc          : Tuple, containing the current temperature array T, \n              the temperature array with ghost nodes T_ex,\n              the partial derivatives ∂T2∂x2, and the\n              residual R\nκ           : Diffusivity [ m²/s ]\nΔx          : Grid spacing [ m ]\nΔt          : Time step [ s ]       \nBC          : Tuple for the boundary condition\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.OneD.ForwardEuler1D!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.OneD.ForwardEuler1D!","text":"ForwardEuler1D!( explicit, κ, Δx, Δt, nc, BC)\n\nSolves the onedimensional heat diffusion equation assuming internal heating and variable thermal parameters using an explicit, forward euler finite difference scheme.\n\nThe temperature is defined on central nodes and the heat flux on the vertices.  Boundary conditions are currently limited to Dirichlet and Neumann. Using central  temperature nodes requires external ghost nodes, which are used to define the  boundary conditions. \n\nT           : Tuple, containing the regular temperature array T and \n              array containing the ghost nodes T_ex\nPy          : Tuple, containing the thermal parameters ρ, k, cp, and H [ W/kg ]\nΔt          : Time step [ s ]\nΔy          : Grid spacing [ m ]\nnc          : Number of central nodes\nBC          : Tuple for the boundary condition\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.OneD.ForwardEuler1Dc!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.OneD.ForwardEuler1Dc!","text":"ForwardEuler1Dc!( explicit, κ, Δx, Δt, nc, BC)\n\nSolves the onedimensional heat diffusion equation assuming no internal heating and constant thermal parameters using an explicit, forward euler finite difference scheme.\n\nThe temperature is defined on central nodes and the heat flux on the vertices.  Boundary conditions are currently limited to Dirichlet and Neumann. Using central  temperature nodes requires external ghost nodes, which are used to define the  boundary conditions. \n\nexplicit    : Tuple, containing the regular temperature array T and \n              array containing the ghost nodes T_ex\nκ           : Diffusivity [ m²/s ]\nΔt          : Time step [ s ]\nnc          : Number of central nodes\nΔx          : Grid spacing [ m ]\nBC          : Tuple for the boundary condition\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.ADI2Dc!-NTuple{9, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.ADI2Dc!","text":"ADI2Dc!(T, κ, Δx, Δy, Δt, ρ, cp, NC, BC)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.AnalyticalSolution2D!-NTuple{5, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.AnalyticalSolution2D!","text":"AnalyticalSolution!(Te, x, y, t)\n\nCalls 2D analytical solution for a 2D diffusion problem:\n\nTe     : 2D matrix \nx      : x coordinate array\ny      : y coordinate array\nt      : time\n\nExamples\n\njulia> a = zeros(2,2); x = [0, 1]; y = [0, 1];\njulia> AnalyticalSolution!(a, x, y, 0.0)\n2×2 Matrix{Float64}:\n 100.0          6.04202e-67\n   6.04202e-67  3.6506e-135\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.AssembleMatrix2D-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.AssembleMatrix2D","text":"AssembleMatrix2D(rho, cp, k, BC, Num, nc, Δ, Δt)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.BackwardEuler2Dc!-NTuple{12, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.BackwardEuler2Dc!","text":"BackwardEuler2Dc!(D, κ, Δx, Δy, Δt, ρ, cp, NC, BC, rhs, K, Num)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.CNA2Dc!-NTuple{13, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.CNA2Dc!","text":"CNA2Dc!(D, κ, Δx, Δy, Δt, ρ, cp, NC, BC, rhs, K1, K2, Num)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.ComputeResiduals2D!-NTuple{12, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.ComputeResiduals2D!","text":"ComputeResiduals2D!(R, T, T_ex, T0, ∂T, q, ρ, Cp, k, BC, Δ, Δt)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.ForwardEuler2Dc!-NTuple{9, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.ForwardEuler2Dc!","text":"ForwardEuler2Dc!(D, κ, Δx, Δy, Δt, ρ, cp, NC, BC)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.Poisson2D!-NTuple{11, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.Poisson2D!","text":"Poisson2D!( T, Q, kx, ky, Δx, Δy, NC, BC, K, rhs, Num )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.HeatEquation.TwoD.Poisson2Dc!-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.HeatEquation.TwoD.Poisson2Dc!","text":"Poisson2Dc!(D,NC,P,BC,Δ,K,rhs,Num)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.OneD.RK4O1D!-NTuple{5, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.OneD.RK4O1D!","text":"RK4O1D!( x, Δt, vx, xmin, xmax )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.OneD.lax1D!-NTuple{4, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.OneD.lax1D!","text":"lax1D!( A, vx, Δt, Δx )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.OneD.semilag1D!-NTuple{5, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.OneD.semilag1D!","text":"semilag1D!( A, xc, vx, Δt, Δx )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.OneD.slf1D!-NTuple{5, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.OneD.slf1D!","text":"slf1D!( A, Aold2, vx, Δt, Δx )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.OneD.upwind1D!-NTuple{4, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.OneD.upwind1D!","text":"upwind1D!( A, vx, Δt, Δx )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.TwoD.semilagc2D!-NTuple{9, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.TwoD.semilagc2D!","text":"semilagc2D!()\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.TwoD.slfc2D!-NTuple{9, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.TwoD.slfc2D!","text":"slfc2D!\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.AdvectionEquation.TwoD.upwindc2D!-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.AdvectionEquation.TwoD.upwindc2D!","text":"upwindc2D!()\n\nUsing the velocity on the centroids!\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.InitialCondition.IniPhase!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.InitialCondition.IniPhase!","text":"IniPhase!(type,D,M,x,y,NC;phase=0)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.InitialCondition.IniTemperature!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.InitialCondition.IniTemperature!","text":"IniTemperature!(type,M,NC,D,x,y;Tb=1000,Ta=1200,Ampl=200,σ=0.05)\n\nFunction to setup an initial temperature condition for a two dimensional  problem. The temperature is defined on the centroids of a regular finite  difference grid. \n\ntype    : \nM       : \nNC      : \nΔ       : \nD       : \nx       : \ny       : \n\nTb      : Hintergrund Temperatur\nTa      : Amplitude der Anomalie\nσ       : Breite der Gaussian Anomalie\n\nPossible initial temperature conditions are: \n\n1) Circle/elliptical anomaly\n2) Gaussian anomaly\n3) Block anomaly\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.InitialCondition.IniVelocity!-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.InitialCondition.IniVelocity!","text":"IniVelocity!(type,D,NC,Δ,M,x,y)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.OneD.Itp1D_Centers2Markers!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.Tracers.OneD.Itp1D_Centers2Markers!","text":"Itp1D_Centers2Markers!( Tm, xm, Tc, xc, Δx, xmin )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.OneD.Itp1D_Markers2Centers!-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.Tracers.OneD.Itp1D_Markers2Centers!","text":"Itp1D_Markers2Centers!( Tc, xc, Tm, xm, dx, xmin )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.Markers","page":"List of functions","title":"GeoModBox.Tracers.TwoD.Markers","text":"Markers()\n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.TMarkers","page":"List of functions","title":"GeoModBox.Tracers.TwoD.TMarkers","text":"TMarkers()\n\n\n\n\n\n","category":"type"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.AdvectTracer2D-NTuple{11, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.AdvectTracer2D","text":"FromCtoM(Prop, Ma, x, y, Δ, NC)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.CountMPC-NTuple{10, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.CountMPC","text":"CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,it)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.FromCtoM-NTuple{7, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.FromCtoM","text":"FromCtoM(Prop, Ma, x, y, Δ, NC)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.IniTracer2D-NTuple{9, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.IniTracer2D","text":"IniTracer2D(nmx,nmy,Δ,M,NC,noise)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.Markers2Cells-NTuple{11, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.Markers2Cells","text":"Markers2Cells(Ma,nmark,PG,weight,x,y,Δ,param)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.Markers2Vertices-NTuple{11, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.Markers2Vertices","text":"Markers2Vertices(Ma,nmark,PG,weight,x,y,Δ,param)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.VxFromVxNodes-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.VxFromVxNodes","text":"VxFromVxNodes(Vx, k, Ma, x, y, Δ, NC, new)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.VxVyFromPrNodes-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.VxVyFromPrNodes","text":"VxVyFromPrNodes(Vxp ,Vyp, k, Ma, x, y, Δ, NC )\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.Tracers.TwoD.VyFromVyNodes-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.Tracers.TwoD.VyFromVyNodes","text":"VyFromVyNodes(Vy, k, Ma, x, y, Δ, NC, new)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.OneD.AssembleStokesMatrix1D-NTuple{5, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.OneD.AssembleStokesMatrix1D","text":"AssembleStokesMatrix1D(nc, η, Δy, BC, K)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.OneD.ComputeStokesResiduals1D!-NTuple{4, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.OneD.ComputeStokesResiduals1D!","text":"ComputeStokesResiduals1D!( D, ∂P∂x, Δy, BC)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.OneD.Stokes_1D_direct-NTuple{7, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.OneD.Stokes_1D_direct","text":"Stokes_1D_direct(vₓ,η,Δy,nc,BC,K,rhs)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.TwoD.Assembly-NTuple{7, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.TwoD.Assembly","text":"Assembly(NC, NV, Δ, ηc, ηv, BC, Num)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.TwoD.Assemblyc-NTuple{6, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.TwoD.Assemblyc","text":"Assemblyc(NC, NV, Δ, η, BC, Num)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.TwoD.Residuals2D!-NTuple{11, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.TwoD.Residuals2D!","text":"Residuals2D!(D,BC,ε,τ,divV,Δ,ηc,ηv,g,Fm,FPt)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.TwoD.Residuals2Dc!-NTuple{10, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.TwoD.Residuals2Dc!","text":"Residuals2Dc!(D,BC,ε,τ,divV,Δ,η,g,Fm,FPt)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.TwoD.updaterhs-NTuple{9, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.TwoD.updaterhs","text":"updaterhs(NC, NV, Δ, ηc, ηv, ρ, g, BC, Num)\n\n\n\n\n\n","category":"method"},{"location":"man/listoffunctions/#GeoModBox.MomentumEquation.TwoD.updaterhsc-NTuple{8, Any}","page":"List of functions","title":"GeoModBox.MomentumEquation.TwoD.updaterhsc","text":"updaterhsc(NC, NV, Δ, η, ρ, g, BC, Num)\n\n\n\n\n\n","category":"method"},{"location":"man/exercises/06_1D_Advection/#[06-1D-Advection-(schemes-and-stability)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/06_1D_Advection_en.ipynb)","page":"06 - 1D Advection","title":"06 - 1D Advection (schemes & stability)","text":"","category":"section"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"This exercise investigates the one-dimensional advection equation (pure transport, no diffusion) and compares several time–space discretizations on two initial conditions (Gaussian vs. block anomaly). The case highlights numerical stability, diffusion, and dispersion and how they depend on the scheme and the Courant number.","category":"page"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"The main objectives are:","category":"page"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"Formulate the 1D advection equation and the Courant–Friedrichs–Lewy (CFL) stability constraint.\nImplement and compare multiple schemes:\nFTCS (Forward Time–Centered Space) — note: unstable for pure advection,\nUpwind (1st order), Downwind, Lax–Friedrichs,\nLeapfrog (SLF), Semi-Lagrangian, and a tracer method.\nApply periodic boundary conditions using ghost cells and verify mass/shape transport.\nAssess numerical diffusion/dispersion by contrasting results for a Gaussian (smooth) vs. block (sharp) profile.\nVisualize the time evolution and simple diagnostics (e.g., peak amplitude).","category":"page"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"An example animation of the evolving profile using the upwind scheme and the semi-lagrangian scheme is shown in Figure 1 and Figure 2, respectively.","category":"page"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"(Image: Exercise06_1)","category":"page"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"Figure 1. Advection of Gaussian temperature anomaly using the upwind scheme.","category":"page"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"(Image: Exercise06_2)","category":"page"},{"location":"man/exercises/06_1D_Advection/","page":"06 - 1D Advection","title":"06 - 1D Advection","text":"Figure 2. Advection of Gaussian temperature anomaly using the semi-lagrangian scheme.","category":"page"},{"location":"man/exercises/01_Euler_Advection/#[01-Euler-Advection-(1D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/01_1D_Euler_Advection_en.ipynb)","page":"01 - Euler Advection","title":"01 - Euler Advection (1D)","text":"","category":"section"},{"location":"man/exercises/01_Euler_Advection/","page":"01 - Euler Advection","title":"01 - Euler Advection","text":"This exercise introduces programming with Julia and the numerical solution of a partial differential equation.  ","category":"page"},{"location":"man/exercises/01_Euler_Advection/","page":"01 - Euler Advection","title":"01 - Euler Advection","text":"The main objectives are to understand:","category":"page"},{"location":"man/exercises/01_Euler_Advection/","page":"01 - Euler Advection","title":"01 - Euler Advection","text":"The discretization of the one-dimensional advection equation,  \nThe approximation of differential operators using finite differences, and  \nThe implementation and visualization of the solution in Julia.  ","category":"page"},{"location":"man/exercises/01_Euler_Advection/","page":"01 - Euler Advection","title":"01 - Euler Advection","text":"The equation is solved using the explicit Euler method, and the resulting particle advection is illustrated in Figure 1.  ","category":"page"},{"location":"man/exercises/01_Euler_Advection/","page":"01 - Euler Advection","title":"01 - Euler Advection","text":"(Image: Exercise1a)  ","category":"page"},{"location":"man/exercises/01_Euler_Advection/","page":"01 - Euler Advection","title":"01 - Euler Advection","text":"Figure 1. One-dimensional particle advection computed with the Euler method.","category":"page"},{"location":"man/exercises/02_1D_Heat_explicit/#[02-1D-Heat-Diffusion-(explicit)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/02_1D_Heat_explicit_en.ipynb)","page":"02 - 1D Heat Diffusion (explicit)","title":"02 - 1D Heat Diffusion (explicit)","text":"","category":"section"},{"location":"man/exercises/02_1D_Heat_explicit/","page":"02 - 1D Heat Diffusion (explicit)","title":"02 - 1D Heat Diffusion (explicit)","text":"This exercise focuses on solving the one-dimensional heat diffusion equation without internal heat generation using the explicit (FTCS) scheme. The explicit formulation is particularly useful for illustrating stability constraints that do not arise in implicit methods.  ","category":"page"},{"location":"man/exercises/02_1D_Heat_explicit/","page":"02 - 1D Heat Diffusion (explicit)","title":"02 - 1D Heat Diffusion (explicit)","text":"The main objectives are:  ","category":"page"},{"location":"man/exercises/02_1D_Heat_explicit/","page":"02 - 1D Heat Diffusion (explicit)","title":"02 - 1D Heat Diffusion (explicit)","text":"Discretization of the PDE and approximation of derivatives with finite difference operators,  \nUnderstanding and applying the diffusion time stability criterion,  \nExploring different approaches to implement the numerical scheme:   a) using a for-loop over the grid,   b) using array indexing to avoid explicit loops, and   c) employing predefined functions from GeoModBox.jl,  \nDefining Dirichlet and Neumann boundary conditions, and  \nStoring the solution as a GIF animation.  ","category":"page"},{"location":"man/exercises/02_1D_Heat_explicit/","page":"02 - 1D Heat Diffusion (explicit)","title":"02 - 1D Heat Diffusion (explicit)","text":"The resulting transient evolution of a Gaussian temperature anomaly is shown in Figure 1.  ","category":"page"},{"location":"man/exercises/02_1D_Heat_explicit/","page":"02 - 1D Heat Diffusion (explicit)","title":"02 - 1D Heat Diffusion (explicit)","text":"(Image: FinalPlot_3)  ","category":"page"},{"location":"man/exercises/02_1D_Heat_explicit/","page":"02 - 1D Heat Diffusion (explicit)","title":"02 - 1D Heat Diffusion (explicit)","text":"Figure 1. Transient behavior of a one-dimensional Gaussian temperature anomaly.","category":"page"},{"location":"man/GESolution/#Solving-Differential-Equations","page":"General","title":"Solving Differential Equations","text":"","category":"section"},{"location":"man/GESolution/#Governing-Equations","page":"General","title":"Governing Equations","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"The governing equations for solving geodynamical problems—neglecting adiabatic effects and assuming only radioactive heat sources—are given by the conservation laws of ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Momentum","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nrho left(fracpartialv_ipartialt + v_jfracpartialv_ipartialx_jright) = -fracpartialP_tpartialx_i + fracpartialtau_ijpartialx_j + rho g_i\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where  rho is the density [kg/m³],  v_i is the velocity in the i-th direction [m/s], t is time [s], partialpartialt is the time derivative,  partialpartial x_i is a directional derivative in i,  P_t is the total pressure [Pa],  tau_ij is the deviatoric stress tensor [Pa], and  boldsymbolg is the gravitational acceleration vector [m/s²]. ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Energy","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nrho c_p left(fracpartial Tpartial t + v_jfracpartialTpartialx_jright) = -fracpartial q_ipartial x_i + rho H\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where  c_p is the specific heat capacity [J/kg/K], T is temperature [K], q_i is the heat flux [W/m²] in direction i, H is the internal heat production per unit mass [W/kg]. ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Mass","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nfracpartialv_ipartialx_i = 0\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Repeated indices imply summation.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Ordinary and partial differential equations (ODEs and PDEs) can be solved through various approaches—occasionally analytically, but more commonly numerically due to their inherent complexity. Among numerical methods, prominent techniques include integral-based methods, such as the finite element and spectral methods, as well as the finite difference method.","category":"page"},{"location":"man/GESolution/#Finite-Difference-Method","page":"General","title":"Finite Difference Method","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"The GeoModBox.jl framework employs the finite difference method. While each numerical approach has its own strengths and limitations, the choice often depends on the user's familiarity and comfort with the method. Nonetheless, the finite difference method is relatively straightforward and pedagogically advantageous, as its discretized form closely resembles the original differential equations. Furthermore, it is computationally efficient, making it well-suited for performance-critical applications.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"In general, the finite difference method aims to approximate differential operators using finite differences derived from a Taylor series expansion. ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Mathematical Background","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"In infinitesimal calculus,the interest lies in how a quantity, such as u, changes in response to a small variation in the variable x. If u has a value of u_0 at position x_0 and changes to u_0 + deltau when x changes to x_0 + \\delta{x}, the incremental change can be described as follows:","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\ndeltau = fracdeltaudeltaxleft(x_0right)deltax \nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Here, delta denotes a small but finite change. When deltax decreases asymptotically toward 0 near x_0, the partial derivative is obtained:","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nlim_delta to 0 fracdeltaudeltaxleft(x_0right) = fracpartialupartialx\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"This limit is valid provided there are no discontinuities or abrupt changes in u with respect to x.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"The finite difference formulation permits the utilization of arithmetic (computational) operators to ascertain the derivatives. Finite difference formulations are predicated on a Taylor series expansion with truncation to a certain order. In general, a Taylor series expansion is given as ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nu(x) = u(x_0)+fracpartialupartialx(x_0)(x-x_0)+fracpartial^2upartialx^2(x_0)fracleft(x-x_0right)^22+fracpartial^3upartialx^3(x_0)fracleft(x-x_0right)^33+ dots + +fracpartial^nupartialx^n(x_0)fracleft(x-x_0right)^nn\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where fracpartial^2upartialx^2 is the second derivative and n describes the factorial, that is: ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nn = 1 times 2 times 3 times dots times n\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Rearranging the Taylor series extension and neglecting higher order terms one obtains an approximation of the partial derivatives using finite difference formulations as ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nfracpartialupartialx(x_0) = fracu(x_0)-u(x)left(x-x_0right) + calOleft(Deltaxright) = fracu(x_0)-u(x_0+Deltax)Deltax + calOleft(Deltaxright)\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where calO indicates the truncation error of the approximation (here, Deltax), and the formulation is, by definition, only accurate up to the first order.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"The partial derivatives can be approximated via different finite differences as ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequationbeginsplit\ntextrmforward difference  quad fracpartialupartialxvert_ij = fracu(x+Deltax)-u(x)Deltax + calOleft(Deltaxright) = fracu_i+1j-u_ijDeltax + calOleft(Deltaxright)  newline\ntextrmcentral difference  quad fracpartialupartialxvert_ij = fracu(x+Deltax)-u(x-Deltax)2Deltax + calOleft(Deltax^2right) = fracu_i+1j-u_i-1j2Deltax + calOleft(Deltax^2right)  newline\ntextrmbackward difference  quad fracpartialupartialxvert_ij = fracu(x)-u(x-Deltax)Deltax + calOleft(Deltaxright) = fracu_ij-u_i-1jDeltax + calOleft(Deltaxright) \nendsplitendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"For further details, refer to the lecture notes or see the reference below.","category":"page"},{"location":"man/GESolution/#Staggered-Finite-Difference","page":"General","title":"Staggered Finite Difference","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"To solve differential equations within a given domain using the finite difference method, it is first necessary to generate a numerical grid on which finite differences can be computed. The most straightforward approach is to discretize the domain using a regular, uniform grid, where the spacing between grid points is constant and all variables are defined at the same locations. Such grids are commonly used to solve equations like the Poisson equation, the heat equation, or advective transport equations.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"However, in many cases, physical constraints or numerical stability requirements necessitate an alternative arrangement of variable locations. For example, solving the momentum equation with variable viscosity generally requires a fully staggered grid to ensure continuity of stress across adjacent grid points. A similar consideration applies to the temperature equation when using variable thermal conductivity.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Staggered grids also offer advantages in implementing boundary conditions. For example, with Neumann thermal boundary conditions, the heat flux across a boundary can be naturally evaluated at staggered points using so-called ghost points. These ghost points can also be employed to impose Dirichlet boundary conditions. This approach helps maintain consistent accuracy and the order of the finite difference scheme both at internal and boundary points. ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"For these reasons, GeoModBox.jl adopts a staggered grid for solving the temperature equation. The complete grid structure used for the governing equations in GeoModBox.jl is illustrated below:","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"(Image: 2DGrid_total)","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Figure 1. Staggered Finite Difference Grid used in ´GeoModBox.jl`.","category":"page"},{"location":"man/GESolution/#Initial-Conditions","page":"General","title":"Initial Conditions","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"Certain initial conditions and parameter structures are already defined in GeoModBox.jl and can be called using certain functions. For more details on the variable structures and functions for initial conditions please see this documentation. ","category":"page"},{"location":"man/GESolution/#Thermal-convection","page":"General","title":"Thermal convection","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"The equations discussed here are used to solve for pressure and velocity in two-dimensional thermal convection systems. While support for variable thermodynamic parameters—such as density (rho), specific heat capacity (c_p), and thermal conductivity (k)—is forthcoming, simplifications are often employed to make the problem more tractable.","category":"page"},{"location":"man/GESolution/#Constitutive-Relation","page":"General","title":"Constitutive Relation","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"The constitutive equations of rheology delineate a relationship between the second-order tensor for the kinematics left(textStrain rate dotvarepsilon textStrain  varepsilon right) and the dynamics left(textForces textStresses sigmaright). Several constitutive models are commonly employed (e.g., viscous, elastic, viscoelastic, plastic). In GeoModBox.jl, the focus is on incompressible, viscous rheology, described by: ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\ntau_ij = 2eta cdot dotvarepsilon_ij\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where eta is the dynamic viscosity [Pa·s] and tau_ij is the deviatoric stress tensor [Pa] defined as ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\ntau_ij = sigma_ij + Pdelta_ij\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where sigma_ij is the full stress tensor [Pa], P is the pressure [Pa], and delta is the Kronecker Delta. ","category":"page"},{"location":"man/GESolution/#Approximations","page":"General","title":"Approximations","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"A commonly used simplification in thermal convection modeling is the Boussinesq approximation. This approximation assumes that all thermodynamic properties remain constant, and adiabatic temperature effects are neglected in the temperature equation. Spatial density variations are assumed to be small and are only retained in the buoyancy term of the momentum equation. Under this framework, density becomes a function of temperature and is described using an equation of state.","category":"page"},{"location":"man/GESolution/#Equation-of-State","page":"General","title":"Equation of State","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"Various forms of the equation of state are available. In this context, a linear approximation is used to relate density to temperature:","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nrho = rho_0 (1-alpha T)\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where rho_0 is the reference density [kg/m³], and alpha is the thermal expansion coefficient [1/K].","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Substituting this relation into the buoyancy term on the right-hand side of the momentum equation and using the definition of total pressure,","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nP_t = P_textdyn + P_texthydr\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where P_textdyn and P_texthydr denote the dynamic and hydrostatic pressure [Pa], respectively, along with the gradient of hydrostatic pressure,","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nfracpartialP_texthydrpartialy=rho_0 g\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"yields a modified form of the y-component of the dimensional momentum equation.","category":"page"},{"location":"man/GESolution/#Governing-equations","page":"General","title":"Governing equations","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"The following dimensional equations govern thermal convection under the Boussinesq approximation:","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Momentum equation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"x-component","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\n0 = -fracpartialP_textdynpartialx+fracpartialtau_xjpartialx_j\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"y-component","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\n0 = -fracpartialP_textdynpartialy+fracpartialtau_yjpartialx_j - rho_0 g alpha T\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where P_textdyn is the dynamic pressure [Pa], tau_ij is the deviatoric stress tensor [Pa], rho_0 is the reference density [kg/m³], g is the gravitational acceleration [m/s²], alpha is the thermal expansion coefficient [1/K], and T is the absolute temperature [K].","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Temperature equation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nleft(fracpartialTpartialt + v_j fracpartialTpartialx_jright) = kappa fracpartial^2Tpartialx^2_i + fracQrho_0 c_p\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where t is time [s], v_j is the velocity in the j-th direction [m/s], kappa = frackrho c_p is the thermal diffusivity [m²/s], Q is the volumetric heat production rate [W/m³], and c_p is the specific heat capacity [J/kg/K]. For implementation details, refer to the thermal convection examples.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Continuity equation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nfracpartialv_ipartialx_i = 0\nendequation","category":"page"},{"location":"man/GESolution/#Scaling","page":"General","title":"Scaling","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"In geodynamic modeling, it is common practice to non-dimensionalize the governing equations to generalize results across different physical scales and to enable experimental modeling (e.g., in laboratory settings). To non-dimensionalize equations (15)–(18), certain scaling constants are introduced and the associated scaling laws derived.","category":"page"},{"location":"man/GESolution/#Scaling-Constants","page":"General","title":"Scaling Constants","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"Various approaches exist for non-dimensionalization. Here, the following set of scaling constants are adopted:","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequationbeginsplit\nh_sc  = h  \nt_sc  = frach^2kappa \nv_sc  = frackappah \ntau_sc  = fraceta_0 kappah^2 \nT_sc  = DeltaT \nQ_sc  = fracDeltaTkappa rho_0 c_ph^2 \nendsplitendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"where h is the model height [m], kappa is the thermal diffusivity [m²/s], eta_0 is the reference viscosity [Pa·s], Delta T is the temperature difference between the top and bottom boundaries [K], rho_0 is the reference density [kg/m³], and c_p is the specific heat capacity [J/kg/K].","category":"page"},{"location":"man/GESolution/#Scaling-laws","page":"General","title":"Scaling laws","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"These constants are applied to transform dimensional quantities into their non-dimensional counterparts (apostrophe indicates non-dimensional parameters):","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequationbeginsplit\nh  = h cdot h_sc  \nt  = t cdot t_sc \nv  = v cdot v_sc \ntau  = tau cdot tau_sc \nT  = T cdot T_sc \nQ  = Q cdot Q_sc\nendsplitendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"When applied, many of the constants cancel out, resulting in non-dimensional equations that structurally resemble the dimensional ones.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Note: This simplification is only valid under the assumptions and approximations discussed above. Any remaining scaling terms can often be grouped into key dimensionless parameters.","category":"page"},{"location":"man/GESolution/#Rayleigh-Number","page":"General","title":"Rayleigh Number","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"The primary remaining dimensionless parameter is the Rayleigh number (Ra), which characterizes the convective behavior and replaces the buoyancy term in the momentum equation:","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nRa = fracrho_0 g alpha DeltaT h^3eta_0 kappa\nendequation","category":"page"},{"location":"man/GESolution/#Non-Dimensional-Governing-Equations","page":"General","title":"Non-Dimensional Governing Equations","text":"","category":"section"},{"location":"man/GESolution/","page":"General","title":"General","text":"The non-dimensional governing equations are then defined as: ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Momentum equation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"x-component","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\n-fracpartialPpartialx+fracpartialtau_xjpartialx_j = 0\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Or in terms of velocity: ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\n-fracpartialPpartialx+2fracpartialpartialxetafracpartialv_xpartialx+fracpartialpartialyetaleft(fracpartialv_xpartialy+fracpartialv_ypartialxright) = 0\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"y-component","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\n-fracpartialPpartialy+fracpartialtau_yjpartialx_j = Ra T\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Or in terms of velocity: ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\n-fracpartialPpartialy+2fracpartialpartialyetafracpartialv_ypartialy +fracpartialpartialxetaleft(fracpartialv_ypartialx + fracpartialv_xpartialyright) = Ra T\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Temperature equation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nleft(fracpartialTpartialt + v_j fracpartialTpartialx_jright) = fracpartial^2Tpartialx^2_i + Q\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Continuity equation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"beginequation\nfracpartialv_xpartialx + fracpartialv_ypartialy = 0\nendequation","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"When interpreting or analyzing non-dimensional models, it is essential to keep track of the scaling constants and reference values used in the transformation.","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"Compared to the dimensional equations, the non-dimensional (scaled) forms differ only slightly in structure. As a result, the same numerical solver can be used for both dimensional and non-dimensional formulations, requiring only minimal modifications when specifying the parameters. ","category":"page"},{"location":"man/GESolution/","page":"General","title":"General","text":"For an implementation example, see the thermal convection examples.","category":"page"},{"location":"man/examples/GaussianDiffusion1D/#[Gaussian-Diffusion-(1D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/1D/Heat_1D_discretization.jl)","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"","category":"section"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"This example illustrates the advantages and disadvantages of different finite difference discretization schemes for solving the 1-D temperature conservation equation. The model assumes constant thermal parameters and neglects adiabatic pressure effects, resulting in a purely diffusive problem.","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"The following discretization schemes are applied: ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Forward Euler\nBackward Euler\nCrank-Nicolson\nDefect Correction","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"As initial condition, a Gaussian temperature distribution with a certain width and amplitude is assumed along a 1-D profile. The transient evolution of this temperature distribution can be described analytically, allowing for the calculation of accuracy at each time step by comparing numerical and analytical results. The temperature distribution and error in percent are shown for each time step in a small animation. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"For more details regarding the model setup and physics or details on the different numerical discretization schemes, please see the exercises or the documentation.","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"using Plots, Printf, LinearAlgebra, ExtendableSparse\nusing GeoModBox.HeatEquation.OneD","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Now, one needs to define the geometrical and physical constants. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Physical Parameters --------------------------------------------------- #\nL           =   100.0               # Length [ m ]\nTrock       =   300.0               # Background temperature [ C ]\nTmagma      =   1200.0              # Dike temperature [ C ]\nW           =   5.0                 # Dike width [m]\nκ           =   1.0e-6              # Diffusivity [ m²/s ]\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Now, the numerical constants.","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Numerical Parameters -------------------------------------------------- #\nnc          =   100                 # Number of cenroids\nΔx          =   L/nc                # Grid spacing\nxc          =   Δx/2:Δx:(L-Δx/2)    # Coordinates\n# Iterations ---\nniter       =   10  \nϵ           =   1.0e-10       \n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"All numerical schemes are solved sequentially for their respective temperature profiles within a shared time loop. Therefore, the time step must satisfy the diffusion stability criterion, which is based on the Forward Euler (explicit) scheme. One can control the absolut time step via the multiplication factor fac.","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Time Parameters ------------------------------------------------------- #\nday         =   3600.0*24.0         # Seconds per day\ntmax        =   2.0*365.25*day      # Maximum time [ s ]\ntime        =   0.0                 # Initilalize time\n# Explicit time stability criterion ---\nΔtexp       =   Δx^2/κ/2.0\n# Absolut time step ---\nfac         =   0.9                 # Factorisation\nΔt          =   fac*Δtexp           # Absolut time step\n# Number of time steps ---\nnt          =   ceil(Int,tmax/Δt)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"As initial condition, a Gaussian temperature distribution along the x-direction is defined, assuming a certain width sigma and its peak at the middle of the profile. The initial temperature distribution is assigned to an individual temperature field for each numerical sceheme. The temperature is overwritten at each time step; it is not stored throughout the time loop. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Initial condition ----------------------------------------------------- #\nT           =   (ini = zeros(nc), ana = zeros(nc))\n# Gaussian temperature distribution ---------\nσ           =   5\nxp          =   L/2.0\n@. T.ini    =   Trock + (Tmagma-Trock)*exp(-((xc-xp)/σ)^2)\n# Setting up field memroy ---\nexplicit    =   (T = zeros(nc), T_ex = zeros(nc+2), ε = zeros(nc))\nimplicit    =   (T = zeros(nc), rhs = zeros(nc), ε = zeros(nc))\ndc          =   (T = zeros(nc), T0 = zeros(nc), T_ex = zeros(nc+2), \n                    ∂T2∂x2 = zeros(nc), R = zeros(nc), ε = zeros(nc))\ncna         =   (T = zeros(nc), ε = zeros(nc))\n# Assign initial temperature ---\nexplicit.T              .=  T.ini\nexplicit.T_ex[2:end-1]  .=  explicit.T\nimplicit.T              .=  T.ini\ndc.T0                   .=  T.ini\ncna.T                   .=  T.ini\n# Analytical solution ---\n@. T.ana    =   Trock + (Tmagma-Trock)/(sqrt(1+4*time*κ/σ^2))*\n                        exp(-(xc-xp)^2/(σ^2 + 4*time*κ))\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Now, the thermal boundary conditions.","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Boundary conditions --------------------------------------------------- #\nBC          =   (\n                    type = (W=:Dirichlet, E=:Dirichlet),\n                    #type = (W=:Neumann, E=:Neumann),\n                    val = (W=:300.0,E=:300.0)\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"For the implicit numerical scheme, one also needs to define the coefficient matrices and the degrees of freedom ndof of the linear system of equations. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Assemble Coefficient Matrix ------------------------------------------- #\nndof        =   length(T.ini)\nK           =   ExtendableSparseMatrix(ndof,ndof)    \nK1          =   ExtendableSparseMatrix(ndof,ndof)    \nK2          =   ExtendableSparseMatrix(ndof,ndof)    \n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"To visualize the transient behavior, the temperature profile and the error are stored as a gif. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Note: If one wants to plot the solution for certain time steps the parameter save_fig needs to be set to 0. This setting does not result in the generation of a gif file and the single plots are not saved! ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Animationssettings ---------------------------------------------------- #\npath        =   string(\"./examples/DiffusionEquation/1D/Results/\")\nanim        =   Plots.Animation(path, String[] )\nfilename    =   string(\"1D_comparison\")\nsave_fig    =   1\n# ----------------------------------------------------------------------- #\n\nLet's plot the initial condition first. \n\n# Plot initial condition ------------------------------------------------ #\np = plot(xc, explicit.T, label=\"explicit\", \n        xlabel=\"x [m]\", ylabel=\"T [°C]\", \n        title=\"Temperature after $(round(time / day, digits=1)) days\n        Δt = $(round(Δt / Δtexp, digits=2))*Δt_{crit}\",\n        xlim=(0,L),ylim=(0, Tmagma),layout=(1,2))\nplot!(p,xc, implicit.T,label=\"implicit\",subplot=1)\nplot!(p,xc, dc.T0,label=\"def correction\",subplot=1)\nplot!(p,xc, cna.T,label=\"cna\",subplot=1)\nplot!(p,xc, T.ana, linestyle=:dash, label=\"analytical\",subplot=1)\nplot!(p,xc, explicit.ε, xlabel=\"x [m]\", ylabel=\"ε\",\n        title=\"Error\",\n        label=\"ε_exp\",xlim=(0,L),ylim=(0,2.0),\n        subplot=2)        \nplot!(p,xc, implicit.ε, label=\"ε_imp\",subplot=2)      \nplot!(p,xc, dc.ε, label=\"ε_dc\",subplot=2)  \nplot!(p,xc, cna.ε, label=\"ε_cna\",subplot=2)  \n\nif save_fig == 1\n    Plots.frame(anim)\nelse\n    display(p)\nend\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"(Image: Diff1Dini)","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Figure 1. Initial temperature distribution.","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"With all parameters defined, the 1-D temperature conservation equation is solved iteratively for each time step using a for loop. Within the time loop, the equation is solved seperately using each of the above mentioned numerical discretization schemes. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"If the temperature field is not explicitly updated in the script after calling the solver, the solver is assumed to update it internally. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Time loop ------------------------------------------------------------- #\nfor n=1:nt\n    println(\"Zeitschritt: \",n,\", Time: $(round(time/day, digits=1)) [d]\")\n    # Explicit, Forward Euler ------------------------------------------- #\n    ForwardEuler1Dc!( explicit, κ, Δx, Δt, nc, BC )\n    # Implicit, Backward Euler ------------------------------------------ #\n    BackwardEuler1Dc!( implicit, κ, Δx, Δt, nc, BC, K, implicit.rhs )\n    # Defection correction method --------------------------------------- #\n    for iter = 1:niter\n        # Residual iteration\n        ComputeResiduals1Dc!( dc, κ, Δx, Δt, BC )\n        @printf(\"||R|| = %1.4e\\n\", norm(dc.R)/length(dc.R))            \n        norm(dc.R)/length(dc.R) < ϵ ? break : nothing\n        # Assemble linear system\n        AssembleMatrix1Dc!( κ, Δx, Δt, nc, BC, K )\n        # Solve for temperature correction: Cholesky factorisation\n        Kc = cholesky(K.cscmatrix)\n        # Solve for temperature correction: Back substitutions\n        δT = -(Kc\\dc.R[:])          \n        # Update temperature            \n        dc.T .= dc.T .+ δT            \n    end        \n    # Crank-Nicolson method --------------------------------------------- #\n    CNA1Dc!( cna, κ, Δx, Δt, nc, BC, K1, K2 )\n    # Update temperature ------------------------------------------------ #\n    dc.T0           .=  dc.T\n    # Update time ------------------------------------------------------- #\n    time    =   time + Δt\n    # Analytical Solution ----------------------------------------------- #\n    @. T.ana    =   Trock + (Tmagma-Trock)/(sqrt(1+4*time*κ/σ^2))*\n                        exp(-(xc-xp)^2/(σ^2 + 4*time*κ))\n    # Error ------------------------------------------------------------- #\n    @. explicit.ε   =   abs((T.ana-explicit.T)/T.ana)*100\n    @. implicit.ε   =   abs((T.ana-implicit.T)/T.ana)*100\n    @. dc.ε         =   abs((T.ana-dc.T0)/T.ana)*100\n    @. cna.ε        =   abs((T.ana-cna.T)/T.ana)*100\n    # Plot solution ----------------------------------------------------- #\n    if n == 1 || n % 5 == 0 || n == nt\n        # Subplot 1 ---\n        p = plot(xc, explicit.T, label=\"explicit\",\n                xlim=(0,L),ylim=(0,1300),\n                xlabel=\"x [m]\",ylabel=\"T [°C]\",\n                title=\"Temperature after $(round(time / day, digits=1)) days\n        Δt = $(round(Δt / Δtexp, digits=2))*Δt_{crit}\",\n                layout=(1,2))\n        plot!(p, xc, implicit.T,linestyle=:dash, label=\"implicit\",subplot=1)\n        plot!(p, xc, dc.T,linestyle=:dash, label=\"def correction\",subplot=1)\n        plot!(p, xc, cna.T,linestyle=:dash, label=\"cna\",subplot=1)\n        plot!(p, xc, T.ana, linestyle=:dash, label=\"analytical\",subplot=1)    \n        # Subplot 2 ---\n        plot!(p,xc, explicit.ε, label=\"ε_exp\",\n            xlim=(0,L),ylim=(0,2.0),\n            xlabel=\"x [m]\",ylabel=\"ε [%]\",\n            title=\"Error\",\n            subplot=2)\n        plot!(p, xc, implicit.ε,linestyle=:dash, label=\"ε_imp\",subplot=2)\n        plot!(p, xc, dc.ε,linestyle=:dot, label=\"ε_dc\",subplot=2)\n        plot!(p, xc, cna.ε,linestyle=:dash, label=\"ε_cna\",subplot=2)                \n        # Display the plots ---    \n        if save_fig == 1\n            Plots.frame(anim)\n        else\n            display(p)\n        end\n    end\nend","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"(Image: Diff_1D_evolve)","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Figure 2. Temperature evolution and corresponding error for each numerical scheme. exp - Forward Euler, imp - Backward Euler, dc - Defect correction, cna - Crank-Nicolson. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"Finally, the plots are compiled into an animation, and individual PNG files corresponding to specific time steps are deleted. ","category":"page"},{"location":"man/examples/GaussianDiffusion1D/","page":"Gaussian Diffusion (1D)","title":"Gaussian Diffusion (1D)","text":"# Speicher Animation ---------------------------------------------------- #\nif save_fig == 1\n    # Write the frames to a GIF file\n    Plots.gif(anim, string( path, filename, \".gif\" ), fps = 15)\nelse\n    display(plot(p))\nend\nforeach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/MixedHeatedConvection/#[Mixed-Heated-Convection](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/MixedHeatedConvection/MixedHeated.jl)","page":"Mixed Heated","title":"Mixed Heated Convection","text":"","category":"section"},{"location":"man/examples/MixedHeatedConvection/","page":"Mixed Heated","title":"Mixed Heated","text":"... tba ...","category":"page"},{"location":"man/Exercises/#Exercises","page":"General","title":"Exercises","text":"","category":"section"},{"location":"man/Exercises/","page":"General","title":"General","text":"GeoModBox.jl contains 13 interactive exercises designed to introduce and practice the numerical solution of partial differential equations. The focus is on the finite difference method for solving governing equations in geodynamics.","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"The sequence of exercises begins with a simple 1-D Euler advection problem and proceeds to the discretization and solution of the 1-D heat diffusion equation using different numerical schemes. The heat equation is then extended to two dimensions, allowing students to analyze and compare the advantages and disadvantages of various approaches.","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"Next, the pure 1-D advection equation is revisited and solved with different numerical schemes, followed by coupling of the advection and diffusion equations using the operator-splitting method.","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"The exercises then move on to the 1-D Stokes equation, solved using both direct and iterative defect-correction methods, before progressing to the steady-state and time-dependent solutions of a full Stokes problem.","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"The final section addresses the three fundamental conservation laws in geodynamics:  ","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"Conservation of energy,  \nConservation of momentum, and  \nConservation of mass.  ","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"These exercises investigate 2-D thermal convection, first in dimensional form and then in a scaled (non-dimensional) version.  ","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"The series concludes with a reproduction of the Blankenbach benchmark.","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"Below, the runtimes for each exercise and their individual options are listed.   All exercises were performed on a single CPU: AMD Ryzen 7 7735U with Radeon Graphics.  ","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"The first runtime corresponds to the initial execution, including compilation and memory allocation.  \nThe runtime in parentheses corresponds to a second execution, where compilation and allocation overhead are avoided.  ","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"Exercise Number Type Total Runtime [s]\n1 Euler Advection 5.741\n2 1-D Heat Diffusion <br/> (explicit) 1) 9.342 (1.14) <br/> 2) 9.975 (1.087) <br/> 3) 9.616 (1.017)\n3 1-D Heat Diffusion <br/> (implicit) 1) 12.641 (1.749) <br/> 2) 13.537 (1.720) <br/> 3) 12.157 (1.731)\n4 2-D Steady State Heat Equation 13.471 (2.069)\n5a 2-D Time-dep. Heat Equation (Plume) 1) Explicit: 18.632 (4.799) <br/> 2) Implicit: 78.201 (60.828)\n5b 2-D Time-dep. Heat Equation (Sill) 1) Explicit: 17.856 (4.566) <br/> 2) Implicit: 39.626 (22.679)\n6 1-D Advection Scheme 1) FTCS: 11.644 (4.019) <br/> 2) Upwind: 11.03 (4.042) <br/> 3) Downwind: 11.465 (3.343) <br/> 4) LAX: 11.272 (3.405) <br/> 5) SLF: 11.312 (3.48) <br/> 6) Semilag: 14.318 (3.604) <br/> 7) Tracers: 15.662 (4.944)\n7 2-D Energy Equation 1) Upwind+explicit: 17.468 (2.979) <br/> 2) Upwind+implicit: 31.441 (10.842) <br/> 3) Upwind+CNA: 32.065 (12.222) <br/> 4) Upwind+ADI: 121.665 (99.807) <br/> 5) Upwind+dc: 30.45 (11.401) <br/> 6) SLF+explicit: 22.002 (2.872) <br/> 7) SLF+implicit: 28.751 (8.911) <br/> 8) SLF+CNA: 29.876 (9.28) <br/> 9) SLF+ADI: 120.018 (98.74) <br/> 10) SLF+dc: 28.179 (9.379) <br/> 11) SL+explicit: 22.969 (6.334) <br/> 12) SL+implicit: 30.634 (9.682) <br/> 13) SL+CNA: 32.415 (11.566) <br/> 14) SL+ADI: 133.871 (110.704) <br/> 15) SL+dc: 35.364 (12.301) <br/> 16) Tracers+explicit: 89.499 (65.913) <br/> 17) Tracers+implicit: 108.464 (84.209) <br/> 18) Tracers+CNA: 112.171 (89.219) <br/> 19) Tracers+ADI: 186.71 (161.611) <br/> 20) Tracers+dc: 115.737 (89.089)\n8 1-D Stokes Equation 8.489 (0.212)\n9 2-D Falling Block (steady state) 20.764 (0.891)\n10 2-D Falling Block (time-dep.) 1) Upwind: 33.295 (3.68) <br/> 2) SLF: 32.333 (3.629) <br/> 3) SL: 37.537 (3.755) <br/> 4) Tracers: 36.291 (6.12)\n11<sup>1</sup> Thermal Convection (dim) Ra = 1e4 (Diff+Adv+Momentum) <br/> 1) Explicit+upwind+direct: 262.912 (1703) <br/> 2) Implicit+upwind+direct: 283.031 (1709) <br/> 3) CNA+upwind+direct: 284.944 (1708) <br/> 4) ADI+upwind+direct: 645.181 (1708) <br/> 5) DC+upwind+direct: 294.1 (1710) <br/> 6) Explicit+SLF+direct: 354.35 (2341) <br/> 7) Implicit+SLF+direct: 382.307 (2345) <br/> 8) CNA+SLF+direct: 386.764 (2344) <br/> 9) ADI+SLF+direct: 892.411 (2344) <br/> 10) DC+SLF+direct: 492.168 (2346) <br/> 11) Explicit+semilag+direct: 334.941 (1743) <br/> 12) Implicit+semilag+direct: 367.501 (1746) <br/> 13) CNA+semilag+direct: 371.289 (1744) <br/> 14) ADI+semilag+direct: 704.852 (1744) <br/> 15) DC+semilag+direct: 390.767 (1749) <br/> 16) Explicit+upwind+DC: 371.091 (1703) <br/> 17) Implicit+upwind+DC: 358.323 (1709) <br/> 18) CNA+upwind+DC: 338.862 (1708) <br/> 19) ADI+upwind+DC: 654.069 (1708) <br/> 20) DC+upwind+DC: 316.456 (1710) <br/> 21) Explicit+SLF+DC: 394.471 (2341) <br/> 22) Implicit+SLF+DC: 417.712 (2345) <br/> 23) CNA+SLF+DC: 412.717 (2344) <br/> 24) ADI+slf+DC: 890.714 (2344) <br/> 25) DC+SLF+DC: 403.217 (2346) <br/> 26) Explicit+semilag+DC: 286.046 (1743) <br/> 27) Implicit+semilag+DC: 295.961 (1746) <br/> 28) CNA+semilag+DC: 288.067 (1744) <br/> 29) ADI+semilag+DC: 671.159 (1744) <br/> 30) DC+semilag+DC: 357.894 (1749) <br/> <br/> Ra = 1e5 (Diff+Adv+Momentum) <br/> 1) Explicit+semilag+dc: 489.869 (2433) <br/> 2) CNA+semilag+dc: 515.539 (2448) <br/> 3) CNA+upwind+dc: 1327.856 (8000) <br/><br/> Ra = 1e6 (Diff+Adv+Momentum) <br/> 4) Explicit+semilag+dc: 1280.077 (8000) <br/> 5) CNA+semilag+dc: 1324.29 (8000) <br/> 6) CNA+upwind+dc: 1272.997 (8000)\n12 Thermal Convection (scaled) Ra = 1e4 (Diff+Adv+Momentum) <br/> 1) Explicit+upwind+direct: 310.208 (1950) <br/> 2) Implicit+upwind+direct: 333.82 (1957) <br/> 3) CNA+upwind+direct: 331.791 (1955) <br/> 4) ADI+upwind+direct: 739.821 (1955) <br/> 5) DC+upwind+direct: 352.163 (1953) <br/> 6) Explicit+SLF+direct: 437.435 (2704) <br/> 7) Implicit+SLF+direct: 468.642 (2708) <br/> 8) CNA+SLF+direct: 464.97 (2707) <br/> 9) ADI+SLF+direct: 1013.196 (2707) <br/> 10) DC+SLF+direct: 476.063 (2706) <br/> 11) Explicit+semilag+direct: 358.84 (1999) <br/> 12) Implicit+semilag+direct: 341.811 (2002) <br/> 13) CNA+semilag+direct: 384.29 (2000) <br/> 14) ADI+semilag+direct: 754.453 (2000) <br/> 15) DC+semilag+direct: 359.703 (2001) <br/> 16) Explicit+upwind+DC: 683.465 (1950) <br/> 17) Implicit+upwind+DC: 614.899 (1957) <br/> 18) CNA+upwind+DC:  649.386 (1955) <br/> 19) ADI+upwind+DC: 1048.092 (1955) <br/> 20) DC+upwind+DC:  640.199 (1953) <br/> 21) Explicit+SLF+DC:  835.568 (2704) <br/> 22) Implicit+SLF+DC:  862.991 (2708) <br/> 23) CNA+SLF+DC:  868.07 (2707) <br/> 24) ADI+slf+DC:  1402.997 (2707) <br/> 25) DC+SLF+DC: 876.505 (2706) <br/> 26) Explicit+semilag+DC: 613.413 (1999) <br/> 27) Implicit+semilag+DC: 652.126 (2002) <br/> 28) CNA+semilag+DC: 638.264 (2000) <br/> 29) ADI+semilag+DC:  1027.153 (2000) <br/> 30) DC+semilag+DC: 620. 945 (2001) <br/> <br/> Ra = 1e5 (Diff+Adv+Momentum) <br/> 31) Explicit+semilag+dc:  3502.72 (8000) <br/>  32) CNA+semilag+dc: 3175.01 (8000) <br/> 33) CNA+upwind+dc: 3330.177 (8000) <br/><br/> Ra = 1e6 (Diff+Adv+Momentum) <br/> 34) Explicit+semilag+dc: 3327.062 (8000) <br/> 35) CNA+semilag+dc: 3387.836 (8000) <br/> 36) CNA+upwind+dc: 3277.684 (8000) <br/>","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"","category":"page"},{"location":"man/Exercises/","page":"General","title":"General","text":"<sup>1</sup>: For the thermal convection, only the runtime where compilation and allocation overhead is avoided are shown, for the sake of simplicity. The number of iterations is shown in the parentheses. For the higher Ra number models only the fastest and most accurate (see here) combinations of solvers from the low Ra case haven been run. ","category":"page"},{"location":"man/examples/ChannelFlow1D/#[Channel-Flow;-Defect-correction-(1D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/1D/ChannelFlow_1D.jl)","page":"Channel Flow (1D)","title":"Channel Flow; Defect correction (1D)","text":"","category":"section"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Assuming a constant horizontal pressure gradient, and that the flow within the channel is driven solely by pressure and/or a prescribed horizontal velocity at the surface (or bottom, or both), the 1D Stokes equation describes the horizontal flow velocity within a channel and simplifies to: ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"beginequation\n0 = -fracpartialPpartialx + fracpartialtau_xypartialy\nendequation","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"where P is the pressure [Pa], fracpartialpartial x_i denotes the partial derivative in the i-th direction, and tau_xy is the horizontal shear stress [Pa], defined by:","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"beginequation\ntau_xy = 2 eta dotvarepsilon_xy\nendequation","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"with eta the viscosity [Pa·s] and dotvarepsilon_xy the shear strain-rate [1/s], given by:","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"beginequation\ndotvarepsilon_xy = frac12 fracpartialv_xpartialy\nendequation","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"In this setup, the vertical velocity is assumed to be zero, reducing the problem to the x-component of the Stokes equation.","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"This example computes the horizontal velocity for a 1D Couette–Poiseuille channel flow with either constant or depth-dependent logarithmic viscosity. To compare with the analytical solution, the depth-dependent viscosity is defined as: ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"beginequation\neta = eta_0 expleft(-log(m) fracy_vHright)\nendequation","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"where m is the viscosity ratio of fraceta_1eta_0, eta_0 and eta_1 are the bottom and surface viscosities, respectively, H is the model height, and y the depth. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Based on the viscosity definition in equation (4), the analytical velocity solution is derived by integrating the x-component of the 1D Stokes equation twice. of the horizontal velocity from the 1D Stokes equation in x-direction by twice integrating equation (1). The analytical solution with depth depends on the viscosity ratio m, the horizontal pressure gradient fracpartial Ppartial x, and the shear velocity at the surface v_x0. The analytical solution is given as: ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"beginequation\nv_xana =frac12 eta_0 fracpartialPpartialx left(y^2 + Hyright) + v_x0fracyH + v_x0quad textif  m = 1\nendequation","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"and","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"beginequation\nv_xana = \n-fracpartialPpartialx fracHeta_0 log(m) (m-1) \nleft(-y \n( m^fracy+HH - \nm^fracyH ) + \nH ( m^fracyH-1 ) \nright) +\nfracv_x0m-1left(m^fracy+HH - 1right) quad textif  m neq 1\nendequation","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"For more details on how the equations are solved using the defect correction method, please refer to the documentation","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"First, one needs to load the required moduls.","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"using Plots, ExtendableSparse, Printf, LinearAlgebra\nusing GeoModBox.MomentumEquation.OneD","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Begin by defining the model geometry and physical constants of the problem. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"# Model Parameter ------------------------------------------------------- #\nM   =   (\n    ymin        =   -400.0e3,           #   Depth [ m ]\n    ymax        =   0.0e3,              \n)\nI   =   (\n    vₓ₀         =   5/100/31536000,     #   Velocity top [ m/s ]\n    η₀          =   1.0e21,             #   Viscosity top [ Pa s ]\n    η₁          =   1.0e18,             #   Viscosity bottom [ Pa s ]\n    ∂P∂x        =   -0.1e1,             #   horizontal pressure gradient [ Pa/m ]\n)\nI1  =   (\n    m           =   I.η₁ / I.η₀,        #   Viscosity ratio\n)\nI   =   merge(I,I1)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"The following section defines the numerical parameters. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"# Numerical Parameter --------------------------------------------------- #\nNC  =   (\n    y   =   100,                        #   Number of centroids\n)\nNV  =   (\n    y   =   NC.y + 1,                   #   Number of vertices\n)\nΔ   =   (\n    y   =   (M.ymax-M.ymin)/NC.y,       #   Grid resolution\n)\n# Grid ---\ny   =   (\n    c   =   LinRange(M.ymin+Δ.y/2,M.ymax-Δ.y/2,NC.y),\n    v   =   LinRange(M.ymin,M.ymax,NV.y),\n)\n# Iterations ---\nniter   =   10\nϵ       =   1e-10\n# ----------------------------------------------------------------------- #\n# Allocations ----------------------------------------------------------- #\nD   =   (\n    η       =   zeros(NC.y+1),\n    vₓ      =   zeros(NC...),\n    vₓₐ     =   zeros(NC...),\n    Δvₓ     =   zeros(NC...),\n    vₓₑ     =   zeros(NC.y+2),\n    δvₓ     =   zeros(NC...),\n    R       =   zeros(NC...),\n    ∂τxy∂y  =   zeros(NC...),\n    τxy     =   zeros(NV...),\n    ∂vₓ∂y   =   zeros(NV...),\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Next, compute the viscosity profile and the analytical velocity solution. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"# Viscosity ------------------------------------------------------------- #\n@. D.η  =   I.η₀ * exp(-log(I.m)* y.v / (M.ymax-M.ymin))\n# ----------------------------------------------------------------------- #\n# Analytical Solution --------------------------------------------------- #\nif I.m  == 1.0\n    @. D.vₓₐ    =   1.0/2.0/I.η₀ * I.∂P∂x * \n                    (y.c^2 + (M.ymax-M.ymin).*y.c) + \n                    I.vₓ₀*y.c/(M.ymax-M.ymin) + I.vₓ₀\nelse\n    @. D.vₓₐ    =   -I.∂P∂x * (M.ymax-M.ymin) / I.η₀ / log(I.m) / (I.m-1) * \n        (-y.c * \n            (I.m^((y.c + (M.ymax-M.ymin))/(M.ymax-M.ymin)) - \n            I.m^(y.c/(M.ymax-M.ymin))) + \n            (M.ymax-M.ymin)*(I.m^(y.c/(M.ymax-M.ymin)) - 1) \n        ) + \n        I.vₓ₀ / (I.m-1) * (I.m ^ ((y.c+(M.ymax-M.ymin))/(M.ymax-M.ymin)) - 1)\nend\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Define the boundary conditions for the velocity. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"# Boundary Conditions --------------------------------------------------- #\nVBC     =   (\n    type    = (S=:Dirichlet, N=:Dirichlet),\n    val     = (S=0.0,N=I.vₓ₀)\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Define the arrays required to construct the linear system of equations. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"# Coeffficientmatrix ---------------------------------------------------- #\nNum     =   (Vx=1:NC.y,)\nndof    =   maximum(Num.Vx)\nK       =   ExtendableSparseMatrix(ndof,ndof)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Solve the linear system using the defect correction method. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"# Solution -------------------------------------------------------------- #\nfor iter=1:niter\n    # Evaluate residual ---\n    ComputeStokesResiduals1D!(D, I.∂P∂x, Δ.y, VBC)\n    @printf(\"||R|| = %1.4e\\n\", norm(D.R)/length(D.R))\n    norm(D.R)/length(D.R) < ϵ ? break : nothing\n    # Assemble linear system ---\n    K  = AssembleStokesMatrix1D(NC.y, D.η, Δ.y, VBC, K)\n    # Solve for temperature correction: Back substitutions ---\n    D.δvₓ .= -(K\\D.R[:]) \n    # Update temperature ---\n    @. D.vₓ += D.δvₓ[Num.Vx]\nend\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Finally, compute the relative deviation from the analytical solution and generate a multi-panel plot of the results. ","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"# Deviation from the analytical solution -------------------------------- #\n@. D.Δvₓ    =   ((D.vₓₐ - D.vₓ) / D.vₓₐ) * 100.0\n# ----------------------------------------------------------------------- #\n# Plotting -------------------------------------------------------------- #\nq   =   plot(D.vₓ,y.c./1e3,label=\"numerical\",\n            xlabel=\"vₓ\", ylabel=\"y [km]\",\n            title=\"Velocity Profile\",\n            xlim=(0,I.vₓ₀*1.5),ylim=(M.ymin/1e3,M.ymax/1e3),\n            layout=(1,3),subplot=1)\nplot!(q,D.vₓₐ,y.c./1e3,label=\"analytical\",linestyle=:dash,\n        subplot=1)\nplot!(q,D.Δvₓ,y.c./1e3,label=\"\",\n        xlabel=\"Δvₓ [%]\",ylabel=\"z [km]\",\n        title=\"Error\",\n        subplot=2)\nplot!(q,log10.(D.η),y.v./1e3,label=\"\",\n        xlabel=\"η [Pa s]\",ylabel=\"z [km]\",\n        title=\"Viscosity\",\n        subplot=3)\ndisplay(q)\n# ----------------------------------------------------------------------- #\nsavefig(\"./examples/StokesEquation/1D/Results/ChannelFlow.png\")","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"(Image: Stokes1D_profiles)","category":"page"},{"location":"man/examples/ChannelFlow1D/","page":"Channel Flow (1D)","title":"Channel Flow (1D)","text":"Figure 1. 1D Poiseuille–Couette Flow. Velocity profiles (left), relative deviation between analytical and numerical solutions (center), and depth-dependent viscosity (right) for a 1D channel flow simulation. ","category":"page"},{"location":"man/examples/OceanicGeotherm/#[Oceanic-Geotherm](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/1D/OceanicGeotherm_1D.jl)","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm","text":"","category":"section"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"The 1-D temperature profile of an oceanic geotherm can be calculated by solving the conductive part of the 1-D temperature conservation equation using variable thermal parameters with a conservative finite difference scheme (so far only including a radiogenic heat source). For the sake of continuity, we use the 1-D solver for variable thermal parameters, even though a constant thermal conductivity is assumed in this example.","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"In a conservative finite difference scheme for 1-D conduction, temperature is defined at the centroids, while vertical heat flux q_y and thermal conductivity k are defined at the vertices.","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"The 1-D temperature equation is given by: ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"beginequation\nrho c_p fracpartialTpartialt = fracpartialq_ypartialy + rho H\nendequation","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"where the heat flux is defined as:","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"beginequation\nleft q_ym = -k_m fracpartial Tpartial yrightvert_m textrmfor m = 1nv \nendequation","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"where rho, c_p, T, t, k, H, y, and nv denote the density [kg/m³], the specific heat capacity [J/kg/K], the temperature [K], the time [s], the thermal conductivity [W/m/K], the heat generation rate per mass [W/kg], the depth [m], and the number of vertices, respectively. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"For more details on how to discretize the equation using an explicit, forward Euler finite difference scheme, please see the documentation.","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"First, one needs to load the required packages: ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"using Plots, SpecialFunctions\nusing GeoModBox.HeatEquation.OneD","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Let's start with the definition of the geometrical, numerical, and physical constants: ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Constants --------------------------------------------------------- #\nH           =   200e3               #   Hight of the model [ m ]\nnc          =   200                 #   Number of central grid points    \nΔy          =   H/nc                #   Grid resolution\n\n# Depth ---\nyc          =   LinRange(-H + Δy/2.0,0.0 - Δy/2.0,nc)     \nyv          =   LinRange(-H,0,nc+1)\n    \nPy  =   (\n    ρm      =   3000,               #   Density [ kg/m^3 ]\n    cpm     =   1000,               #   Heat capacity [ J/kg/K ]\n    km      =   3.0,                #   Conductivity [ W/m/K ]\n    HM      =   0,                  #   Heat generation rate [W/kg]; Q = ρ*H0\n)    \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"In the following, one needs to define the initial and boundary condition: ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Temperature at the surface and bottom.\nLinear increasing temperature profile assuming a certain adiabatic gradient and potential mantle temperature.","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Initial Condition ------------------------------------------------- #\nT   =   (\n    Tpot    =   1315 + 273.15,      #   Potential temperautre [ K ]\n    ΔTadi   =   0.5,                #   Adiabatic temperature gradient [ K/km ]\n    Ttop    =   273.15,             #   Surface temperature [ K ]\n    T_ex    =   zeros(nc+2,1),    \n)\nT1  =   (\n    Tbot    =   T.Tpot + T.ΔTadi*abs(H/1e3),    # Bottom temperature [ K ]\n    T       =   T.Tpot .+ abs.(yc./1e3).*T.ΔTadi,   # Initial T-profile [ K ]\n)\nT   =   merge(T,T1)\n     \nTini                =   zeros(nc,1)\nTini                .=   T.T\nT.T_ex[2:end-1]     .=   T.T\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Either Dirichlet or Neumann thermal boundary conditions can be applied at the surface and bottom. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Boundary conditions ----------------------------------------------- #\nBC      =   (\n    type    = (N=:Dirichlet, S=:Dirichlet),\n    val     = (N=T.Ttop[1],S=T.Tbot[1])\n)\n# If Neumann boundary conditions are choosen, the following values result in the given heatflux for the given thermal conductivity k. \n# S      =   -0.03;          # c     =   -k/q -> 90 mW/m^2\n# N      =   -0.0033;        # c     =   -k/q -> 10 mW/m^2\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Next, define the multiplicative factor fac for the diffusion stability criterion for the explicit thermal solver. This factor controls the stability criterion. If fac exceeds 1, the solver becomes unstable.  ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Time stability criterion ------------------------------------------ #\nfac     =   0.8                 #   Courant criterion\ntmax    =   60                  #   Lithosphere age [ Ma ]\ntsca    =   60*60*24*365.25     #   Seconds per year\n\nage     =   tmax*1e6*tsca        #   Age in seconds    \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"To verify the initial and boundary conditions by plotting the temperature profile. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Plot Initial condition -------------------------------------------- #\nplotparam   =   1\nq = plot(Tini,yc./1e3, \n    label=\"\", \n    xlabel=\"T [ K ]\", ylabel=\"z [ km ]\", \n    title=\"Initial Temperature\",\n    xlim=(T.Ttop,T.Tbot),ylim=(-H/1e3,0))\ndisplay(q)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"(Image: OG1D_ini)","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Figure 1. Initial temperature profile.","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Since a thermal solver for variable thermal parameters is used, one needs to expand the scalar to a vector with the dimensions of the number of centroids nc. Additionally, the thermal diffusivity kappa and initialize the vertical heat flux q need to be defined. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Setup Fields ------------------------------------------------------ #\nPy1     =   (\n    ρ       =   Py.ρm.*ones(nc,1),\n    cp      =   Py.cpm.*ones(nc,1),\n    k       =   Py.km.*ones(nc+1,1),\n    H       =   Py.HM.*ones(nc,1)\n)\nPy  =   merge(Py,Py1)\nPy2     =   (\n    # Thermal diffusivity [ m^2/s ] \n    κ       =  maximum(Py.k)/minimum(Py.ρ)/minimum(Py.cp),     \n)\nPy  =   merge(Py,Py2)\nT2  =   (\n    q   =   zeros(nc+1,1),\n)\nT   =   merge(T,T2)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Now, one can calculate the time stability criterion. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Time stability criterion ------------------------------------------ #\nΔtexp   =   Δy^2/2/Py.κ             #   Stability criterion for explicit\nΔt      =   fac*Δtexp               #   total time step\n\nnit     =   ceil(Int64,age/Δt)      #   Number of iterations    \n\ntime    =   zeros(1,nit)            #   Time array\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"With all parameters and constants defined, the equation can now be solved the 1-D temperature equation for each time step in a for loop. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"The temperature conservation equation is solved via the function ForwardEuler1D!(), which updates the temperature profile T.T for each time step using the extended temperature field T.T_ex, which include the ghost nodes. The temperature profile is plotted for a certain time.  ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Calculate 1-D temperature profile --------------------------------- #\ncount   =   1\nfor i = 1:nit\n    if i > 1\n        time[i]     =   time[i-1] + Δt\n    elseif time[i] > age\n        Δt          =   age - time[i-1]\n        time[i]     =   time[i-1] + Δt\n    end\n    ForwardEuler1D!(T,Py,Δt,Δy,nc,BC)\n    if i == nit || abs(time[i]/1e6/tsca - count*5.0) < Δt/1e6/tsca        \n        println(string(\"i = \",i,\", time = \", time[i]/1e6/tsca))        \n        q = plot!(T.T,yc./1e3, \n            label=string(\"t = \",ceil(time[i]/1e6/tsca),\"[Ma]\"), \n            xlabel=\"T [ K ]\", ylabel=\"z [ km ]\", \n            title=\"Oceanic Geotherm\",\n            xlim=(T.Ttop,T.Tbot),ylim=(-H/1e3,0))\n        display(q)\n        count = count + 1\n    end\nend\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"(Image: OG1D_evolve)","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Figure 2. Evolution of the temperature profile with depth in 5 Ma steps.","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"For the final time step, a depth profile for the vertical heat flux is calculated. Therefore, one needs to update the temperature at the ghost nodes to calculate the heat flux at the boundary. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Calculate heaf flow ----------------------------------------------- #\n# South ---\nT.T_ex[1]   =   (BC.type.S==:Dirichlet) * (2 * BC.val.S - T.T_ex[2]) + \n                (BC.type.S==:Neumann) * (T.T_ex[2] - BC.val.S*Δy)\n# North ---\nT.T_ex[end] =   (BC.type.N==:Dirichlet) * (2 * BC.val.N - T.T_ex[nc+1]) +\n                (BC.type.N==:Neumann) * (T.T_ex[nc+1] + BC.val.N*Δy)\nfor j=1:nc+1\n    T.q[j]  =   -Py.k[j] * \n        (T.T_ex[j+1] - T.T_ex[j])/Δy\nend\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Finally, compute the temperature profile for an oceanic geotherm using the analytical expression of an infinite half-space cooling model for a certain age. The analytical solution is shown in the final figure, alongside the final numerical temperature profile and the heat flux profile. ","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"# Plot -------------------------------------------------------------- #\nif BC.type.N==:Dirichlet && BC.type.S==:Dirichlet\n    Tana    =   zeros(nc,1)\n    Tana    .=   Tini .+ (T.Ttop - T.Tpot).*erfc.(-yc./(2*sqrt(age*Py.κ)))\n    Tana[end] =   T.Ttop\nend    \np = plot(T.T,yc./1e3, \n        label=string(\"t = \",ceil(maximum(time)/1e6/tsca),\"[Ma]\"), \n        xlabel=\"T [ K ]\", ylabel=\"z [ km ]\",\n        title=\"Oceanic Geotherm\",\n        xlim=(T.Ttop,T.Tbot),ylim=(-H/1e3,0),\n        layout=(1,2),subplot=1)        \nif BC.type.N==:Dirichlet && BC.type.S==:Dirichlet\n    plot!(p,Tana,yc./1e3, \n            label=\"T_HSCM\",linestyle=:dash,\n            layout=(1,2),subplot=1)        \nend        \np = plot!(T.q.*1e3,yv./1e3, \n        label=\"\", \n        xlabel=\"q [ mW ]\", ylabel=\"z [m]\", \n        title=\"Heat Flux\",\n        ylim=(-H/1e3,0),\n        subplot=2)        \ndisplay(p)\nsavefig(p,\"./examples/DiffusionEquation/1D/Results/OceanicGeotherm_1D.png\")\nsavefig(q,\"./examples/DiffusionEquation/1D/Results/OceanicGeotherm_1D_evolve.png\")\n# ======================================================================= #","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"(Image: OG1D_final)","category":"page"},{"location":"man/examples/OceanicGeotherm/","page":"Oceanic Geotherm (1D)","title":"Oceanic Geotherm (1D)","text":"Figure 3. Final temperature and heat flux profiles.","category":"page"},{"location":"man/examples/RTI_growth_rate/#[RTI-Growth-Rate-Benchmark](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/RTI_GrowthRate.jl)","page":"RTI - Growth Rate","title":"RTI - Growth Rate Benchmark","text":"","category":"section"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"This script performs a benchmark for the growth rate of a Rayleigh–Taylor instability, following Gerya (2009). The benchmark is based on the analytical solution by Ramberg (1968) and is used to assess the accuracy of the velocity field in a purely gravity-driven flow. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"While small-amplitude perturbations can be analyzed theoretically—facilitated by the use of tracers and bilinear interpolation of density onto centroids—a relatively large perturbation amplitude is employed here to accommodate practical implementation constraints. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Let's load the required modules first. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"using Plots\nusing ExtendableSparse\nusing GeoModBox\nusing GeoModBox.InitialCondition, GeoModBox.MomentumEquation.TwoD\nusing GeoModBox.AdvectionEquation.TwoD\nusing GeoModBox.Tracers.TwoD\nusing Base.Threads\nusing Printf, LinearAlgebra","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"In the following some parameters regarding the visualization can be edited. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"# Plot fields for each individual model - yes or no\nplot_fields     =:no\n# Save final figure\nsave_fig        = 1\n\nPl  =   (\n    qinc    =   5, \n    qsc     =   100*(60*60*24*365.25)*5e1,\n)","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"The parameters for an initial cosinusoidal tracer perturbation are defined for a two-layer model. For benchmarking purposes, a range of wavelengths is specified. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"# Define Initial Condition ========================================== #\nIni         =   (p=:RTI,) \n# Perturbation wavelength [ m ]\nλᵣ          =   [1 3 4 5 6 8 10 12 14]*1e3\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"The physical parameters are now defined, including the range of viscosity ratios between the two layers. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"# Physics =========================================================== #\ng           =   9.81                    #   Gravitational acceleration [ m/s^2 ]\n# Lower layer ---\nρ₁          =   2900.0                  #   Density composition 1 [ kg/m^3 ]\nη₁          =   1e19                    #   Viscosity composition 1 [ Pa s]\n# Upper layer --- \nρ₀          =   3000.0                  #   Density composition 0 [ kg/m^3 ]\n# ---\nρ           =   [ρ₀,ρ₁]                 #   Density for phases\nηᵣ          =   [1e-6 1 10 100 500]     #   Viscosity ratio\nphase       =   [0,1]\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"In the following, the parameters for the analytical solution are initialized, some scaling parameters (b1 and b2) for the visualization, and the divisional factor for the perturbation wavelength (delfac)","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"# Plotting factors following Gerya (2009) --------------------------- #\nb1          =   [0.5 1 5 50 250]\nb2          =   [0.2 0.15 0.1 0.05 0]\n# Divisional factor of the amplitude following Gerya (2009) --------- #\ndelfac      =   15 #[15 150] # [150 1500] # 1500 15\nms          =   zeros(3)\nms          =   [6,4,2]\n# Analytical Solution ----------------------------------------------- #\nλₐ          =   collect(LinRange(0.5,18,51)).*1e3        # [ m ]\nϕ₁          =   zeros(length(λₐ))\nϕ₂          =   copy(ϕ₁)\nc11         =   copy(ϕ₁)\nd12         =   copy(ϕ₁)\ni21         =   copy(ϕ₁)\nj22         =   copy(ϕ₁)\n# Arrays ---\nPP  =   (\n    ϕ       =   [0.0],\n    K       =   [0.0],\n    Q       =   [0.0],\n    ϕₐ      =   zeros(length(λₐ)),\n    Kₐ      =   zeros(length(λₐ),length(ηᵣ)),\n)\n# ------------------------------------------------------------------- #\n# Plot Settings ===================================================== #\nq   =   plot()\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Define the geometry of the model domain. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"# Geometry ========================================================== #\nM       =   Geometry(\n    ymin    =   -3.0e3,     # [ m ]\n    ymax    =   0.0,\n    xmin    =   0.0,\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"If multiple perturbation amplitudes are specified, a loop is initiated over them. For each amplitude, a nested loop iterates over different viscosity contrasts. Within that loop the viscosity for the upper layer is calculated. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"for k in eachindex(delfac)\n    for i in eachindex(ηᵣ)\n        # Physics =================================================== #\n        # 0 - upper layer; 1 - lower layer\n        η₀      =   η₁*ηᵣ[i]        #   Viscosity composition 0 [ Pa s ]\n        η       =   [η₀,η₁]         #   Viscosity for phases \n        # ----------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"The variables required for the analytical solution are calculated for each model configuration. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"        @. ϕ₁      =   (2*π*((M.ymax-M.ymin)/2))/λₐ\n        @. ϕ₂      =   (2*π*((M.ymax-M.ymin)/2))/λₐ\n        @. c11     =   (η₀*2*ϕ₁^2)/\n                        (η₁*(cosh(2*ϕ₁) - 1 - 2*ϕ₁^2)) - \n                        (2*ϕ₂^2)/\n                        (cosh(2*ϕ₂) - 1 - 2*ϕ₂^2)\n        @. d12     =   (η₀*(sinh(2*ϕ₁) - 2*ϕ₁))/\n                        (η₁*(cosh(2*ϕ₁) - 1 - 2*ϕ₁^2)) + \n                        (sinh(2*ϕ₂) - 2*ϕ₂)/\n                        (cosh(2*ϕ₂) - 1 - 2*ϕ₂^2)\n        @. i21     =   (η₀*ϕ₂*(sinh(2*ϕ₁) + 2*ϕ₁))/\n                        (η₁*(cosh(2*ϕ₁) - 1 - 2*ϕ₁^2)) + \n                        (ϕ₂*(sinh(2*ϕ₂) + 2*ϕ₂))/\n                        (cosh(2*ϕ₂) - 1 - 2*ϕ₂^2)\n        @. j22     =   (η₀*2*ϕ₁^2*ϕ₂)/\n                        (η₁*(cosh(2*ϕ₁) - 1 - 2*ϕ₁^2)) - \n                        (2*ϕ₂^3)/\n                        (cosh(2*ϕ₂) - 1 - 2*ϕ₂^2)\n        \n        @. PP.Kₐ[:,i]   =   -d12/(c11*j22 - d12*i21)\n        @. PP.ϕₐ        =   ϕ₁","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Because the analytical solution is independent of perturbation amplitude, the loop over different amplitudes is performed separately. Within that loop, both the model domain and perturbation amplitude are defined for each configuration. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"        for j in eachindex(λᵣ)\n            # Perturbation properties ---\n            λ           =   λᵣ[j]                           #   [ m ]\n            δA          =   -(M.ymax-M.ymin)/2/delfac[k]    #   Amplitude [ m ]\n            # ---\n            ar          =   Int64(round(2 * λ / (M.ymax-M.ymin)))  #   aspect ratio\n            M.xmax      =   (M.ymax-M.ymin)*ar\n            # ------------------------------------------------------- #\n            # Grid ================================================== # \n            NC  =   (\n                x   =   50*ar,\n                y   =   50,\n            )\n            NV  =   (\n                x   =   NC.x + 1,\n                y   =   NC.y + 1,\n            )\n            Δ       =   GridSpacing(\n                x   =   (M.xmax - M.xmin)/NC.x,\n                y   =   (M.ymax - M.ymin)/NC.y,\n            )\n            x       =   (\n                c   =   LinRange(M.xmin+Δ.x/2,M.xmax-Δ.x/2,NC.x),\n                ce  =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),\n                v   =   LinRange(M.xmin,M.xmax,NV.x),\n            )\n            y       =   (\n                c   =   LinRange(M.ymin+Δ.y/2,M.ymax-Δ.y/2,NC.y),\n                ce  =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),\n                v   =   LinRange(M.ymin,M.ymax,NV.y),\n            )\n            x1      =   (\n                c2d     =   x.c .+ 0*y.c',\n                v2d     =   x.v .+ 0*y.v', \n                vx2d    =   x.v .+ 0*y.ce',\n                vy2d    =   x.ce .+ 0*y.v',\n            )\n            x   =   merge(x,x1)\n            y1      =   (\n                c2d     =   0*x.c .+ y.c',\n                v2d     =   0*x.v .+ y.v',\n                vx2d    =   0*x.v .+ y.ce',\n                vy2d    =   0*x.ce .+ y.v',\n            )\n            y   =   merge(y,y1)\n            # ------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Let's initialize all the required data array in the following. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            # Allocation ============================================ #\n            D       =   (\n                ρ       =   zeros(Float64,(NC...)),\n                p       =   zeros(Float64,(NC...)),\n                cp      =   zeros(Float64,(NC...)),\n                vx      =   zeros(Float64,(NV.x,NV.y+1)),\n                vy      =   zeros(Float64,(NV.x+1,NV.y)),    \n                Pt      =   zeros(Float64,(NC...)),\n                vxc     =   zeros(Float64,(NC...)),\n                vyc     =   zeros(Float64,(NC...)),\n                vc      =   zeros(Float64,(NC...)),\n                wt      =   zeros(Float64,(NC.x,NC.y)),\n                wtv     =   zeros(Float64,(NV.x,NV.y)),\n                ηc      =   zeros(Float64,NC...),\n                ηv      =   zeros(Float64,NV...),\n            )\n            # ------------------------------------------------------- #\n            # Needed for the defect correction solution ---\n            divV        =   zeros(Float64,NC...)\n            ε           =   (\n                xx      =   zeros(Float64,NC...), \n                yy      =   zeros(Float64,NC...), \n                xy      =   zeros(Float64,NV...),\n            )\n            τ           =   (\n                xx      =   zeros(Float64,NC...), \n                yy      =   zeros(Float64,NC...), \n                xy      =   zeros(Float64,NV...),\n            )\n            # ------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Also one needs to set the velocity boudnary conditions. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            # Boundary Conditions =================================== #\n            VBC     =   (\n                type    =   (E=:freeslip,W=:freeslip,S=:noslip,N=:noslip),\n                val     =   (E=zeros(NV.y),W=zeros(NV.y),S=zeros(NV.x),N=zeros(NV.x)),\n            )\n            # ------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"To setup the perturbation, the markers are initialized in the following. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            # Tracer Advection ====================================== #\n            nmx,nmy     =   5,5\n            noise       =   0\n            nmark       =   nmx*nmy*NC.x*NC.y\n            Aparam      =   :phase\n            MPC         =   (\n                c       =   zeros(Float64,(NC.x,NC.y)),\n                v       =   zeros(Float64,(NV.x,NV.y)),\n                th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),\n                thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),\n            )\n            MPC1        = (\n                PG_th   =   [similar(D.ρ) for _ = 1:nthreads()],    # per thread\n                PV_th   =   [similar(D.ηv) for _ = 1:nthreads()],   # per thread\n                wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread\n                wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread\n            )\n            MPC     =   merge(MPC,MPC1)\n            Ma      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,Ini.p,phase;λ,δA)\n            # RK4 weights ---\n            rkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\n            rkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepπng\n            # Count marker per cell ---\n            CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)\n            # Interpolate from markers to cell ---\n            Markers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\n            Markers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\n            Markers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n            @. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                                    D.ηv[2:end-0,1:end-1] + \n                                    D.ηv[1:end-1,2:end-0] + \n                                    D.ηv[2:end-0,2:end-0])\n            # ------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"The parameters for solving the linear system using the defect correction method are now defined. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            # System of Equations =================================== #\n            # Iterations\n            niter       =   10\n            ϵ           =   1e-10\n            # Numbering, without ghost nodes! ---\n            off    = [  NV.x*NC.y,                          # vx\n                        NV.x*NC.y + NC.x*NV.y,              # vy\n                        NV.x*NC.y + NC.x*NV.y + NC.x*NC.y]  # Pt\n\n            Num    =    (\n                Vx  =   reshape(1:NV.x*NC.y, NV.x, NC.y), \n                Vy  =   reshape(off[1]+1:off[1]+NC.x*NV.y, NC.x, NV.y), \n                Pt  =   reshape(off[2]+1:off[2]+NC.x*NC.y,NC...),\n                        )\n            δx      =   zeros(maximum(Num.Pt))\n            F       =   zeros(maximum(Num.Pt))\n            # Residuals ---\n            Fm     =    (\n                x       =   zeros(Float64,NV.x, NC.y), \n                y       =   zeros(Float64,NC.x, NV.y)\n            )\n            FPt     =   zeros(Float64,NC...)      \n            # ------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"The momentum and mass conservation equations are now solved. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            # Momentum Equation ===\n            D.vx    .=  0.0\n            D.vy    .=  0.0\n            D.Pt    .=  0.0\n            for iter=1:niter\n                # Initial Residual -------------------------------------- #\n                Residuals2D!(D,VBC,ε,τ,divV,Δ,D.ηc,D.ηv,g,Fm,FPt)\n                F[Num.Vx]   =   Fm.x[:]\n                F[Num.Vy]   =   Fm.y[:]\n                F[Num.Pt]   =   FPt[:]\n                @printf(\"||R|| = %1.4e\\n\", norm(F)/length(F))\n                norm(F)/length(F) < ϵ ? break : nothing\n                # Assemble Coefficients ================================= #\n                K       =   Assembly(NC, NV, Δ, D.ηc, D.ηv, VBC, Num)\n                # ------------------------------------------------------- #\n                # Solution of the linear system ========================= #\n                δx      =   - K \\ F\n                # ------------------------------------------------------- #\n                # Update Unknown Variables ============================== #\n                D.vx[:,2:end-1]     .+=  δx[Num.Vx]\n                D.vy[2:end-1,:]     .+=  δx[Num.Vy]\n                D.Pt                .+=  δx[Num.Pt]\n            end","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"For visualization purposes, the centroid velocities are computed.","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            # ------------------------------------------------------- #\n            # Get the velocity on the centroids ---\n            for i = 1:NC.x\n                for j = 1:NC.y\n                    D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2\n                    D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2\n                end\n            end\n            @. D.vc        = sqrt(D.vxc^2 + D.vyc^2)\n            # ---","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"In the following, one defines the parameters to calculate the rising velocity at the tip of the perturbation in the center of the model domain. The vertical velocity at the perturbation tip is calculated using bilinear interpolation from surrounding velocity grid points. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            xwave       =   (M.xmax-M.xmin)/2   # [ m ]\n            ywave       =   (M.ymax-M.ymin)/2 + δA\n            \n            xn          =   Int64(floor((xwave+Δ.x/2)/Δ.x))\n            yn          =   Int64(floor(((M.ymax-M.ymin)-ywave)/Δ.y)) + 1\n\n            dx          =   (xwave+Δ.x/2)/Δ.x - xn\n            dy          =   abs(((M.ymax-M.ymin)-ywave)/Δ.y - yn)\n\n            wvy     =   (1.0-dx)*(1.0-dy) * D.vy[xn+1,yn] + \n                            dx*(1.0-dy) * D.vy[xn+1+2,yn] + \n                            (1.0-dx)*dy * D.vy[xn+1,yn-1] + \n                            dx*dy * D.vy[xn+2,yn-1]\n            \n            PP.Q[1] =   (ρ₀-ρ₁)*(M.ymax-M.ymin)/2.0*g/2.0/η₁\n            PP.K[1] =   abs(wvy)/abs(δA)/PP.Q[1]\n            PP.ϕ[1] =   2*π*(M.ymax-M.ymin)/2/λ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"If wanted, the density, tracer, and viscosity fields are plotted. To verify the position of the perturbation tip used in velocity interpolation, the tip (black circle) and surrounding vertical velocity grid points (red circles) are plotted on the tracer field. The plot is zoomed in for better visualization. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"            if plot_fields==:yes\n                p = heatmap(x.c./1e3,y.c./1e3,D.ρ',color=:inferno,\n                            xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=true,\n                            title=\"ρ\",\n                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),                             \n                            ylims=(M.ymin/1e3, M.ymax/1e3),\n                            layout=(3,1),subplot=1)\n                quiver!(p,x.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                    y.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                    quiver=(D.vxc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc,\n                            D.vyc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc),        \n                    la=0.5,color=\"white\",layout=(3,1),subplot=1)\n                scatter!(p,Ma.x[1:end]./1e3,Ma.y[1:end]./1e3,\n                    ms=3,ma=0.5,mc=Ma.phase[1:end],markerstrokewidth=0.0,\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=true,\n                    title=\"tracers\",label=\"\",\n                    xlims=(xwave/1e3-Δ.x/1e3*1.1, xwave/1e3+Δ.x/1e3*1.1), \n                    ylims=(-ywave/1e3-Δ.y/1e3*1.1, -ywave/1e3+Δ.y/1e3*1.1),\n                    layout=(3,1),subplot=3)\n                heatmap!(p,x.c./1e3,y.c./1e3,log10.(abs.(D.ηc)'),\n                            color=reverse(cgrad(:roma)),\n                            xlabel=\"x[km]\",ylabel=\"y[km]\",title=\"η_c\",\n                            clims=(15,27),\n                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),                             \n                            ylims=(M.ymin/1e3, M.ymax/1e3),colorbar=true,\n                            layout=(2,1),subplot=2)\n                scatter!(p,(xwave/1.0e3,-ywave/1.0e3),\n                        markersize=3,label=\"\",color=:black,\n                        layout=(3,1),subplot=3)\n                scatter!(p,(x1.vy2d[xn+1,yn]/1e3,y1.vy2d[xn+1,yn]/1e3),\n                        markersize=3,label=\"\",color=:red,\n                        layout=(3,1),subplot=3)\n                scatter!(p,(x1.vy2d[xn+2,yn]/1e3,y1.vy2d[xn+2,yn]/1e3),\n                        markersize=3,label=\"\",color=:red,\n                        layout=(3,1),subplot=3)\n                scatter!(p,(x1.vy2d[xn+1,yn+1]/1e3,y1.vy2d[xn+1,yn+1]/1e3),\n                        markersize=3,label=\"\",color=:red,\n                        layout=(3,1),subplot=3)\n                scatter!(p,(x1.vy2d[xn+2,yn+1]/1e3,y1.vy2d[xn+2,yn+1]/1e3),\n                        markersize=3,label=\"\",color=:red,\n                        layout=(3,1),subplot=3)\n                display(p)\n            end\n            scatter!(q,(PP.ϕ[1],b1[i]*PP.K[1] + b2[i]),\n                ms=ms[k],markershape=:circle,label=\"\",\n                color=:black)\n        end # Loop λ - j","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"(Image: Growth_Rate_Example)","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Figure 1. Example of a RTI model. Top: Centroid velocity arrows on top of the density field. Middle: Centroid viscosity. Bottom: Zoom of the tracer field on the tip of the perturbation at the center of the model domain. The black tracer marks the tip, and the red tracer mark the vertical velocity nodes from which the vertical velocity is interpolated onto the tip. This example uses a perturbation of A = h_115 and a wavelength of 12 km. The model includes 50 centroids in the vertical direction. The number of horizontal centroids is chosen such that the resolution remains consistent in both the horizontal and vertical directions for all benchmark models. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Finally, the rising velocity is plotted over the analytical solution for the given range of viscosity contrasts. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"        if k == 1\n            plot!(q,PP.ϕₐ,b1[i].*PP.Kₐ[:,i] .+ b2[i],color=:black,\n                        xlabel=\"ϕ₁ = 2πh₁/λ\",\n                        ylabel=\"b₁K + b₂\", \n                        title=\"\",\n                        xlims=(0.5,4),ylims=(0.05,0.4),\n                        label=\"\")\n        end\n    end # Loop ηᵣ - i \nend # Loop delfac - k ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"The final figure is stored in the given directory. ","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"if save_fig == 1\n    savefig(q,string(\"./examples/StokesEquation/2D/Results/RTI_Growth_Rate.png\"))\nelse\n    display(q)\nend","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"(Image: RTI_GrowthRate)","category":"page"},{"location":"man/examples/RTI_growth_rate/","page":"RTI - Growth Rate","title":"RTI - Growth Rate","text":"Figure 2. RTI Growth Rate. Growth rate of an initial cosinusoidal perturbation in a two-layer system across various wavelengths lambda. The growth rate is arbitrarily scaled using b_1 and b_2 for visualization, following the approach of Gerya (2000). The lines are the analytical solutions for different viscosity ratios eta_r and the black circles show the corresponding numerical results. The rising velocity is numerically calculated following the approach shown in Figure 1. ","category":"page"},{"location":"man/examples/BottomHeatedConvection/#[Bottom-Heated-Convection](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/MixedHeatedConvection/BottomHeated.jl)","page":"Bottom Heated","title":"Bottom Heated Convection","text":"","category":"section"},{"location":"man/examples/BottomHeatedConvection/","page":"Bottom Heated","title":"Bottom Heated","text":"... tba ...","category":"page"},{"location":"#GeoModBox.jl","page":"Home","title":"GeoModBox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Geodynamic Modelling ToolBox is a Julia package primarily intended for teaching purposes. It provides various finite difference, staggered discretization schemes to numerically solve the governing equations of two-dimensional geodynamic problems. These include the conservation equations of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Energy, \nMomentum, \nMass and Compositon. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeoModBox.jl includes a series of exercises and examples of geodynamically well-defined problems. The exercises are provided as Jupyter notebooks for students to complete. The theoretical background is documented here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The solvers for each governing equation can be used separately or in combination for dimensional or non-dimensional problems, with only minimal modifications when calling the functions. Some typical initial conditions, such as a linearly increasing temperature, are predefined and can be called using specific functions.","category":"page"},{"location":"#Staggered-Finite-Difference","page":"Home","title":"Staggered Finite Difference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To properly solve the governing equations, a staggered finite difference scheme is chosen for the energy and momentum equations. A staggered grid enables a correct and straightforward implementation of boundary conditions and ensures conservation of stress between nodes in cases of variable viscosity. This requires certain parameters to be defined on different grids.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, temperature, density, pressure, normal deviatoric stresses, and heat production rate are defined on the centroids. The deviatoric shear stresses are defined on the vertices, and velocities are defined between the vertices. Viscosity is required on both.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For further details on the implementation in GeoModBox.jl, see here.","category":"page"},{"location":"#Energy-Conservation-Equation","page":"Home","title":"Energy Conservation Equation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In geodynamics, the energy is described by the temperature and needs to be conserved within a closed system. Here, we solve the temperature conservation equation, or temperature equation, using an operator splitting method, that is, we first solve the advective part of the temperature equation, followed by the diffusive part. ","category":"page"},{"location":"#[Heat-Diffusion-Equation](./man/DiffMain.md)","page":"Home","title":"Heat Diffusion Equation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GeoModBox.jl provides several finite difference schemes for solving the diffusive part of the time-dependent or steady-state temperature equation, including radioactive heating, in both 1-D and 2-D. The solvers are located in src/HeatEquation. Currently, only Dirichlet and Neumann thermal boundary conditions are supported. Most functions assume constant thermal parameters (with the exception of the 1-D solvers and the 2-D defect correction solver).","category":"page"},{"location":"#[Heat-Advection-Equation](./man/AdvectMain.md)","page":"Home","title":"Heat Advection Equation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GeoModBox.jl provides various methods to advect properties within the model domain. The routines are structured so that any property defined on centroids (including ghost nodes at all boundaries) can be advected using the described solvers. Using passive tracers, one may choose to advect either the absolute temperature or the phase ID.","category":"page"},{"location":"#[Momentum-Conservation-Equation](./man/MomentumMain.md)","page":"Home","title":"Momentum Conservation Equation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"On geological timescales, Earth's mantle and lithosphere deform slowly due to their high viscosity, allowing us to neglect inertial forces. This simplifies the Navier-Stokes equation into the Stokes equation. GeoModBox.jl provides two main methods to solve the Stokes equation in 1-D and 2-D: the direct method and the defect correction method, applicable for both constant and variable viscosity fields. Velocity and pressure are defined on a staggered grid, and ghost nodes are included to ensure proper implementation of free-slip and no-slip boundary conditions. ","category":"page"},{"location":"#[Benchmarks-and-Examples](./man/Examples.md)","page":"Home","title":"Benchmarks and Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following are visualizations of selected examples provided by GeoModBox.jl. For further details, refer to the documentation linked in each title.","category":"page"},{"location":"#[Gaussian-Temperature-Diffusion](./man/examples/GaussianDiffusion2D.md)","page":"Home","title":"Gaussian Temperature Diffusion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GaussianDiffusion)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 1. Gaussian Diffusion. Time-dependent, diffusive solution of a 2-D Gaussian temperature anomaly at a resolution of 100 × 100, using the Crank-Nicholson approach, compared to the analytical solution.   Top Left: 2-D temperature field with numerical isotherms (solid black) and analytical isotherms (dashed yellow).   Top Right: Total deviation from the analytical solution.   Bottom Left: 1-D y-profile along x = 0.   Bottom Right: Root Mean Square (RMS) total deviation over time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: GDResTest)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 2. Resolution test. Maximum RMS error varepsilon, maximum temperature, and mean temperature for various finite difference schemes and resolutions for the diffusion example shown above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#[Rigid-Body-Rotation](./man/examples/Advection2D.md)","page":"Home","title":"Rigid-Body-Rotation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: RigidBodyI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: RigidBodyII)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: RigidBodyIII)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 3. Rigid-Body-Rotation. Time-dependent advection of a rotating circular temperature anomaly using the upwind (top), semi-Lagrangian (middle), and tracer (bottom) methods on a 100 × 100 grid. Within a circular region, the velocity field follows rigid rotation; outside, it is zero. Temperature for tracers is interpolated to the grid for visualization but not updated on the tracers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#[Falling-Block](./man/examples/FallingBlockBenchmark.md)","page":"Home","title":"Falling Block","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: FallingBlockTD)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 4. Isoviscous Falling Block. Time-dependent simulation of an isoviscous falling block at 50 × 50 resolution with 9 tracers per cell. The solver handles variable viscosities. Tracers advect the phase ID, which is used to interpolate density and viscosity on centroids and vertices, respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: FBSinkinVeloc)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 5. Falling Block Sinking Velocity. Block sinking velocity vs. initial viscosity ratio eta_r, using the same setup as above. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: FBFinalStage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 6. Falling Block Benchmark. Tracer distribution at the final stage for selected viscosity ratios eta_r ge 0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#[Rayleigh-Taylor-Instability](./man/examples/RTI.md)","page":"Home","title":"Rayleigh-Taylor Instability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: RTIani)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 7. Rayleigh-Taylor Instability. Evolution of two-layered Rayleigh-Taylor instability. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#[Thermal-Convection](./man/examples/MixedHeatedConvection.md)","page":"Home","title":"Thermal Convection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: BHTC)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 8. Bottom-Heated, Isoviscous Convection for Ra = 10^6, resolution 400 × 100.   TOP: Transient temperature field with velocity vectors.   BOTTOM: Horizontally averaged temperature–depth profiles at each time step.   Solvers: defect correction (momentum), semi-Lagrangian (advection), Crank-Nicolson (heat diffusion).   Boundary conditions: Dirichlet (top/bottom), Neumann (sides), free-slip (velocity, all sides).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: IHTC)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 9. Internally Heated Convection for Ra_Q = 15 cdot 10^6, resolution 400 × 100.   Same setup as above, but with Neumann boundary at the bottom (zero heat flux) and constant internal volumetric heat production Q approx 15.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: MHTC)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 10. Mixed-Heated Convection for Ra = , resolution 400 × 100.   Combination of the above two setups (bottom heating + internal heating).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"man/DiffMain/#Energy-Conservation-Equation","page":"General","title":"Energy Conservation Equation","text":"","category":"section"},{"location":"man/DiffMain/","page":"General","title":"General","text":"The conservation of energy is a fundamental physical principle stating that energy can neither be created nor destroyed, but only transformed. In geodynamical modeling, this principle is typically expressed in terms of temperature, which evolves due to diffusive and advective transport processes. Assuming radioactive heat sources only, the general energy equation is defined as:","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"beginequation\nleft(fracpartial Epartial t + v_jfracpartialEpartialx_jright) + fracpartial q_ipartial x_i = rho H\nendequation","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"where energy is defined as E = c_p rho T. Here  c_p is the specific heat capacity [J/kg/K], rho is the density [kg/m³], T is temperature [K], partialpartial t is the time derivative, t is time [s], v_j is the velocity [m/s] in direction j, q_i is the heat flux [W/m²] in direction i, partialpartial x_i is a directional derivative in i, H is the internal heat production per unit mass [W/kg]. Repeated indices imply summation.","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"The heat flux q_i is described by Fourier’s law:","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"beginequation\nq_i = - k fracpartialTpartialx_i\nendequation","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"where k is the thermal conductivity [W/m/K]. The flux is directed opposite to the temperature gradient and represents the amount of heat passing through a unit surface per unit time.","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"Substituting Fourier’s law into the energy equation yields the temperature conservation equation in Eulerian form:","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"beginequation\nrho c_p left(fracpartial Tpartial t + v_jfracpartialTpartialx_jright) = -fracpartial q_ipartial x_i + rho H\nendequation","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"This equation captures temperature changes due to diffusion (right-hand side) and advection (left-hand side). For simplicity and assuming a spatially constant internal heat production, these processes can be split using an operator splitting technique, solving the advection and diffusion steps sequentially. If internal heat production varies spatially, a more advanced advection scheme is required to account for source term integration.","category":"page"},{"location":"man/DiffMain/#Heat-Diffusion-Equation","page":"General","title":"Heat Diffusion Equation","text":"","category":"section"},{"location":"man/DiffMain/","page":"General","title":"General","text":"Neglecting the advection part of the temperature equation, the heat diffusion equation is defined as: ","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"beginequation\nrho c_p fracpartial Tpartial t = -fracpartial q_ipartial x_i + rho H\nendequation","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"GeoModBox.jl provides several finite difference (FD) schemes to solve the diffusive component of the time-dependent or steady-state temperature equation—including optional radioactive heating—in both 1-D and 2-D. Available methods include:","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"Forward Euler  \nBackward Euler  \nCrank–Nicolson  \nAlternating Direction Implicit (ADI)\nDefection Correction","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"See the documentation for the 1-D and 2-D solvers for detailed descriptions of each method.","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"Currently, only Dirichlet and Neumann boundary conditions are supported. Most implementations assume constant thermal properties, although certain 1-D and 2-D solvers allow for variable parameters. See the HeatEquation source directory for implementation details.","category":"page"},{"location":"man/DiffMain/#Examples","page":"General","title":"Examples","text":"","category":"section"},{"location":"man/DiffMain/","page":"General","title":"General","text":"1-D oceanic geotherm  \n1-D continental geotherm  \nComparison of FD schemes on a Gaussian anomaly  \n2-D resolution test with Gaussian anomaly  \n2-D Poisson equation resolution test","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"For more details, see the full example directory.","category":"page"},{"location":"man/DiffMain/#Exercises","page":"General","title":"Exercises","text":"","category":"section"},{"location":"man/DiffMain/","page":"General","title":"General","text":"1-D forward Euler  \n1-D backward Euler  \n2-D Poisson equation  \n2-D transient plume heating  \n2-D transient sill heating","category":"page"},{"location":"man/DiffMain/#Heat-Advection-Equation","page":"General","title":"Heat Advection Equation","text":"","category":"section"},{"location":"man/DiffMain/","page":"General","title":"General","text":"To solve the advective component of the temperature equation, GeoModBox.jl offers several schemes:","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"Upwind scheme  \nStaggered leapfrog scheme  \nSemi-Lagrangian scheme  \nPassive tracers/markers","category":"page"},{"location":"man/DiffMain/","page":"General","title":"General","text":"See the advection documentation and associated source code for method-specific details. Tracer-related functionality is located in src/Tracers, whereas other advection schemes are implemented in src/AdvectionEquation.","category":"page"},{"location":"man/DiffMain/#Examples-2","page":"General","title":"Examples","text":"","category":"section"},{"location":"man/DiffMain/","page":"General","title":"General","text":"2-D advection with constant velocity field  \nResolution test of 2-D advection","category":"page"},{"location":"man/DiffMain/#Exercises-2","page":"General","title":"Exercises","text":"","category":"section"},{"location":"man/DiffMain/","page":"General","title":"General","text":"1-D Gaussian or block anomaly advection  \n2-D coupled advection-diffusion","category":"page"},{"location":"man/DiffTwoD/#Temperature-Equation-(2D)","page":"2D","title":"Temperature Equation (2D)","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In two spatial dimensions (x and y), the diffusive part of the temperature equation, assuming only radiogenic heat production, is given by:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nrho c_p fracpartial Tpartial t = -fracpartial q_xpartial x -fracpartial q_ypartial y + rho H \nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where  rho is the density [kg/m³], c_p is the specific heat capacity [J/(kg·K)], T is the temperature [K], t is time [s], q_x and q_y are the heat flux components in the x and y directions [W/m²], and H is the volumetric heat production rate per unit mass [W/kg].","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"By applying Fourier’s law and allowing for spatially variable thermal conductivity k, the equation becomes:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nrho c_p fracpartial Tpartial t = fracpartialpartial x k fracpartial Tpartial x + fracpartialpartial y k fracpartial Tpartial y + rho H\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"If thermal parameters are assumed constant, this simplifies to:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nfracpartial Tpartial t = kappa left(fracpartial^2 Tpartial x^2 + fracpartial^2 Tpartial y^2right) + fracQrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where  kappa = frackrho c_p is the thermal diffusivity [m²/s] and Q = rho H is the volumetric heat production rate [W/m³].","category":"page"},{"location":"man/DiffTwoD/#Discretization-and-Numerical-Schemes","page":"2D","title":"Discretization and Numerical Schemes","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"To numerically solve equation (3), the spatial domain must be discretized and the relevant thermal parameters assigned to the appropriate computational nodes.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"(Image: 2DDiffusionGrid)","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Figure 1. 2D Discretization. Conservative finite difference grid for solving the 2D diffusive temperature equation. Temperature values are defined at the centroids (red circles), while heat fluxes are computed at the vertices (horizontal flux: blue crosses; vertical flux: green squares). Ghost nodes (grey circles) are used to implement Dirichlet and Neumann boundary conditions.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"A detailed implementation of various numerical schemes is provided in the example script Gaussian_Diffusion.jl. This example demonstrates the application of several methods for solving the diffusive part of the 2D temperature equation:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Explicit scheme\nFully implicit scheme\nCrank–Nicolson approach\nAlternating Direction Implicit (ADI) method\nDefect correction method","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"The numerical results are compared with the analytical solution of a Gaussian temperature distribution to assess accuracy and performance.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Each numerical scheme is briefly outlined in the following sections. For implementation details and derivations in one dimension, refer to the 1D solver documentation.","category":"page"},{"location":"man/DiffTwoD/#Explicit-Scheme:-FTCS-(Forward-Time,-Centered-Space)","page":"2D","title":"Explicit Scheme: FTCS (Forward Time, Centered Space)","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For an explicit finite difference discretization, the numerical stability criterion (heat diffusion condition) is given by:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nDeltat  frac12 kappa left(frac1Deltax^2+frac1Deltay^2right)\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where Delta x and Delta y denote the spatial grid spacing in the x and y directions, respectively. This condition must be satisfied to ensure numerical stability of the explicit scheme.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In two dimensions, the partial derivatives in equation (3) can be approximated using an explicit FTCS (Forward Time, Centered Space) finite difference scheme:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nfracT_ij^n+1 - T_ij^n Delta t = kappa left( fracT_i-1j^n - 2T_ij^n + T_i+1j^nDeltax^2 + fracT_ij-1^n - 2T_ij^n + T_ij+1^nDeltaz^2 right) + fracQ_ij^nrho c_p \nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Here, i and j are the horizontal and vertical grid indices, respectively, n is the time step index, Delta t  is the time step size and Delta x, Delta y are the grid spacings in the horizontal and vertical directions.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Rearranging this equation to solve for the temperature at the next time step yields:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_ij^n+1 = T_ij^n + aleft(T_i-1j^n - 2T_ij^n + T_i+1j^nright) + bleft(T_ij-1^n - 2T_ij^n + T_ij+1^nright) + fracQ_ij^n Deltatrho c_p \nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\na = frackappa DeltatDeltax^2 quad \nb = frackappa DeltatDeltay^2\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For implementation details, see the source code.","category":"page"},{"location":"man/DiffTwoD/#Boundary-Conditions","page":"2D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"To correctly impose boundary conditions, ghost nodes are used adjacent to the domain boundaries.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Dirichlet Boundary Conditions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Dirichlet conditions impose a fixed temperature value along the boundary. The ghost node temperatures are calculated as:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GW = 2T_BCW - T_1\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GE = 2T_BCE - T_ncx\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GS = 2T_BCS - T_1\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GN = 2T_BCN - T_ncy\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Here, T_BCW, T_BCE, T_BCS, and T_BCN are the prescribed boundary temperatures on the west, east, south, and north boundaries, respectively. The notation T_i and T_j refers to slices along rows and columns.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Neumann Boundary Conditions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Neumann conditions impose a prescribed gradient (e.g., heat flux) across the boundary. Ghost node temperatures are computed as:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GW = T_1 - c_W Deltax\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GE = T_ncx + c_E Deltax\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GS = T_1 - c_S Deltay\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nT_GN = T_ncy + c_N Deltay\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nleft c_W = fracpartialTpartialx rightvert_W left c_E = fracpartialTpartialx rightvert_E \nleft c_S = fracpartialTpartialy rightvert_S\nleft c_N = fracpartialTpartialy rightvert_N\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"are the specified temperature gradients (or fluxes) at each boundary.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Once the ghost node temperatures are defined according to the chosen boundary conditions, equation (6) can be used to update the temperature at the centroids for the next time step.","category":"page"},{"location":"man/DiffTwoD/#Implicit-Scheme:-Backward-Euler-Method","page":"2D","title":"Implicit Scheme: Backward Euler Method","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In two dimensions, the temperature equation can be discretized using the implicit (Backward Euler) method as:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nfracT_ij^n+1-T_ij^nDelta t = \nkappa left( \n    fracT_i-1j^n+1-2T_ij^n+1+T_i+1j^n+1Delta x^2 + \n    fracT_ij-1^n+1-2T_ij^n+1+T_ij+1^n+1Delta y^2 \n    right) + \nfracQ_i^nrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Here, n and n+1 denote the current and next time steps, Delta t is the time step size, Delta x and Delta y are the grid spacings, and i, j are the horizontal and vertical indices, respectively.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Rewriting this equation to separate known and unknown terms results in a linear system of equations of the form:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_ij-1^n+1 - a T_i-1j^n+1 + \nleft(2a + 2b + c right) T_ij^n+1 - \na T_i+1j^n+1 - b T_ij+1^n+1 = \nc T_ij^n + fracQ_ij^nrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\na = frackappaDeltax^2 quad\nb = frackappaDeltay^2 quad \nc = frac1Deltat\nendequation","category":"page"},{"location":"man/DiffTwoD/#Boundary-Conditions-2","page":"2D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Boundary conditions are imposed via ghost nodes, as previously described (see equations (7)–(14)). However, to ensure a symmetric coefficient matrix in the resulting linear system, both the coefficients and the right-hand side for centroids adjacent to the boundaries must be modified accordingly.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Dirichlet Boundary Conditions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_1j-1^n+1 + left(3 a + 2b + cright) T_1j^n+1 - a T_2j^n+1  - b T_1j+1^n+1 = c T_1j^n + 2 a T_BCW + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_ncxj-1^n+1 - aT_ncx-1j^n+1 + left(3 a + 2b + cright) T_ncxj^n+1 - b T_ncxj+1^n+1 = \nc T_ncxj^n + 2 a T_BCE + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-a T_i-11^n+1 + left(2a + 3b + cright) T_i1^n+1 - a T_i+11^n+1 - bT_i2^n+1 = \nc T_i1^n + 2 b T_BCS + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_incy^n+1 - aT_i-1ncy^n+1 + left(2a + 3b + cright) T_incy^n+1 - a T_i+1ncy^n+1 = \nc T_incy^n + 2 b T_BCN + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Neumann Boundary Conditions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_1j-1^n+1 + left(a + 2b + cright) T_1j^n+1 - a T_2j^n+1  - b T_1j+1^n+1 = \nc T_1j^n - a c_W Deltax + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_ncxj-1^n+1 - aT_ncx-1j^n+1 + left(a + 2b + cright) T_ncxj^n+1 - b T_ncxj+1^n+1 = \nc T_ncxj^n + a c_E Deltax + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-a T_i-11^n+1 + left(2a + b + cright) T_i1^n+1 - a T_i+11^n+1 - bT_i2^n+1 = \nc T_i1^n - b c_S Deltay + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_incy^n+1 - aT_i-1ncy^n+1 + left(2a + b + cright) T_incy^n+1 - a T_i+1ncy^n+1 = \nc T_incy^n + b c_N Deltay + fracQ_ijrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"These boundary-specific formulations ensure symmetry in the coefficient matrix and proper enforcement of Dirichlet and Neumann conditions within the implicit time-stepping scheme.","category":"page"},{"location":"man/DiffTwoD/#Defect-Correction-Method","page":"2D","title":"Defect Correction Method","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"The defect correction method reformulates the diffusive part of the temperature equation by introducing a residual term R, representing the defect (or error) in the discretized equation. This can be expressed as:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nfracpartialTpartialt - kappa left( fracpartial^2Tpartialx^2 + fracpartial^2Tpartialy^2 right) - fracQ_ij^nrho c_p = R\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Discretizing the equation in space and time using implicit finite differences yields:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nfracT_ij^n+1-T_ij^nDeltat - kappa \nleft( fracT_i-1j^n+1 - 2 T_ij^n+1 + T_i+1j^n+1Deltax^2 + fracT_ij-1^n+1 - 2 T_ij^n+1 + T_ij+1^n+1Deltay^2  \nright) - fracQ_ij^nrho c_p = R\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Rewriting this in a matrix-compatible form leads to:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n-b T_ij-1^n+1 - a T_i-1j^n+1 + \nleft(2a + 2b + c right) T_ij^n+1 - \na T_i+1j^n+1 - b T_ij+1^n+1 - \nc T_ij^n - fracQ_ij^nrho c_p = \nR\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where the coefficients are defined as:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\na = frackappaDeltax^2quad  \nb = frackappaDeltay^2 textrmand quad c = frac1Deltat \nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In this formulation, the defect R quantifies the deviation from the true solution and can be used iteratively to improve accuracy through successive correction steps.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For more background on the defect correction approach, see the 1-D example. For implementation details, refer to the source code.","category":"page"},{"location":"man/DiffTwoD/#Cranck-Nicolson-Approach-(CNA)","page":"2D","title":"Cranck-Nicolson Approach (CNA)","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In 2-D, the diffusive part of the heat equation (Equation 3) using the Crank–Nicolson method is written as:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n fracT_ij^n+1 - T_ij^nDelta t =  \nfrackappa2frac(T_i-1j^n+1-2T_ij^n+1+T_i+1j^n+1)+(T_i-1j^n-2T_ij^n+T_i+1j^n)Delta x^2 +  \nfrackappa2frac(T_ij-1^n+1-2T_ij^n+1+T_ij+1^n+1)+(T_ij-1^n-2T_ij^n+T_ij+1^n)Delta y^2 + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Rearranging into a form that separates known and unknown variables gives the linear system:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -b T_ij-1^n+1 -aT_i-1j^n+1+left(2a + 2b + cright)T_ij^n+1 -aT_i+1j^n+1 -b T_ij+1^n+1 =  b T_ij-1^n +aT_i-1j^n-left(2a + 2b - cright)T_ij^n +aT_i+1j^n +b T_ij+1^n + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where the coefficients are defined as:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\na = frackappaDelta x^2 quad \nb = frackappaDelta y^2 quad \nc = frac1Delta t\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"As with the implicit method, the boundary-adjacent centroids require modified coefficients to accommodate boundary conditions and maintain symmetry in the coefficient matrix.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Dirichlet Boundary Conditions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -b T_1j-1^n+1 +\nleft(3a + 2b + c right) T_1j^n+1 \n-a T_2j^n+1 - b T_1j+1^n+1 =  \nb T_1j-1^n - left( 3a + 2b - c right) T_1j^n + a T_2j^n + b T_1j+1^n + 4 a T_BCW + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -b T_ncxj-1^n+1 - a T_ncx-1j^n+1 +\nleft(3a + 2b + c right) T_ncxj^n+1 \n-b T_ncxj+1^n+1 =   \nb T_ncxj-1^n + a T_ncx-1j^n -\nleft( 3a + 2b - c right) T_ncxj^n + b T_ncxj+1^n + 4 a T_BCE + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -a T_i-11^n+1 +\nleft(2a + 3b + c right) T_i1^n+1 - a T_i+11^n+1 - b T_i2^n+1 =   \na T_i-11^n - left( 2a + 3b - c right) T_i1^n + a T_i+11^n + b T_i2^n + 4 b T_BCS + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -b T_incy-1^n+1 + a T_i-1ncy^n+1 + left(2a + 3b + c right) T_incy^n+1 - a T_i+1ncy^n+1 =  \nb T_incy-1^n + a T_i-1ncy^n - left( 2a + 3b - c right) T_incy^n + a T_i+1ncy^n + 4 b T_BCN + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Neumann Boundary Conditions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -b T_1j-1^n+1 + left(a + 2b + c right) T_1j^n+1 - a T_2j^n+1 - b T_1j+1^n+1 =  \nb T_1j-1^n - left( a + 2b - c right) T_1j^n + a T_2j^n + b T_1j+1^n - 2 a c_W Deltax + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -b T_ncxj-1^n+1 - a T_ncx-1j^n+1 + left(a + 2b + c right) T_ncxj^n+1 - b T_ncxj+1^n+1 =  \nb T_ncxj-1^n + a T_ncx-1j^n - left( a + 2b - c right) T_ncxj^n + b T_ncxj+1^n + 2 a c_E Deltax + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -a T_i-11^n+1 + left(2a + b + c right) T_i1^n+1 - a T_i+11^n+1 - b T_i2^n+1 =  \na T_i-11^n - left( 2a + b - c right) T_i1^n + a T_i+11^n + b T_i2^n - 2 b c_S Deltay + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbegingather*\n -b T_incy-1^n+1 + a T_i-1ncy^n+1 + left(2a + b + c right) T_incy^n+1 - a T_i+1ncy^n+1 =  \nb T_incy-1^n + a T_i-1ncy^n - left( 2a + b - c right) T_incy^n + a T_i+1ncy^n + 2 b c_N Deltay + fracQ_ij^nrho c_p\nendgather*endequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For implementation details, refer to the source code.","category":"page"},{"location":"man/DiffTwoD/#Alternating-Direction-Implicit-(ADI)","page":"2D","title":"Alternating-Direction Implicit (ADI)","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In 2-D, the diffusive part of the heat equation (Equation 3) is discretized using the Alternating-Direction Implicit (ADI) method by splitting the time step into two fractional steps. The resulting system for each half-step is:","category":"page"},{"location":"man/DiffTwoD/#First-half-step-(implicit-in-y,-explicit-in-x):","page":"2D","title":"First half-step (implicit in y, explicit in x):","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nfracT_ij^n+12-T_ij^nDelta t2 = \nkappa \n    left( \n    fracT_i-1j^n-2T_ij^n+T_i+1j^nDelta x^2 +\n    fracT_ij-1^n+12-2T_ij^n+12+T_ij+1^n+12Delta y^2\n    right) + fracQ_ij^nrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/#Second-half-step-(implicit-in-x,-explicit-in-y):","page":"2D","title":"Second half-step (implicit in x, explicit in y):","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nfracT_ij^n+1-T_ij^n+12Delta t2 = \nkappa \n    left( \n    fracT_i-1j^n+1-2T_ij^n+1+T_i+1j^n+1Delta x^2 + \n    fracT_ij-1^n+12-2T_ij^n+12+T_ij+1^n+12Delta y^2\n    right) + fracQ_ij^nrho c_p\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Each fractional step results in a tridiagonal linear system, alternating between the x- and y-directions. This decomposition improves computational efficiency while retaining the stability benefits of implicit schemes.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"As in the Crank–Nicolson approach, the coefficients and right-hand side vectors of these systems must be adjusted appropriately based on the prescribed boundary conditions (Dirichlet or Neumann). See the CNA section for examples of boundary treatment.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For implementation details, refer to the source code.","category":"page"},{"location":"man/DiffTwoD/#Variable-Thermal-Parameters","page":"2D","title":"Variable Thermal Parameters","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Note: Variable thermal parameters are currently implemented for the 1-D time-dependent and 2-D steady-state cases. The 2-D defect correction method also supports time-dependent problems with variable parameters. These capabilities will be extended in future updates.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"The solution is the same as for constant thermal parameter, except that the coefficients of the matrix vary. ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"The residual R is then calculated as ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nrho c_pfracpartialTpartialt + fracpartialq_xpartialx + fracpartialq_ypartialy - rho H = R\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where q_x and q_y are the horizontal and vertical heat fluxes, respectively, and are defined as","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\nq_x  = - k_xfracpartialTpartialx \nq_y  = - k_yfracpartialTpartialy\nendsplitendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where k_x and k_y are the horizontal and vertical thermal conductivities. ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Discretizing the equation in space and time using implicit finite differences yields: ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nrho_ij c_p(ij)left(fracT_ij^n+1 - T_ij^nDeltatright) \n+fracq_x(i+1j) - q_x(ij)Deltax \n+fracq_y(ij+1) - q_y(ij)Deltay \n-rho_ij H_ij = R_ij \nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where Deltax and Deltay are the horizontal and vertical grid resolution, respectively, Deltat is the time step length and i and j the horizontal and vertical indices, respectively. ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"By applying Fourier's law the equation results in:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nrho_ij c_p(ij)left(fracT_ij^n+1 - T_ij^nDeltatright) \n+left(\nfrac-k_x(i+1j)fracT_i+1j^n+1-T_ij^n+1Deltax \n+k_x(ij)fracT_ij^n+1-T_i-1j^n+1Deltax\nDeltax\nright)\n+left(\nfrac-k_y(ij+1)fracT_ij+1^n+1-T_ij^n+1Deltay \n+k_y(ij)fracT_ij^n+1-T_ij-1^n+1Deltay\nDeltay\nright)\n-rho_ij H_ij = R_ij\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Rewriting this in a matrix-compatible form leads to: ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\naT_ij-1^n+1 \n+bT_i-1j^n+1 \n+cT_ij^n+1 \n+dT_i+1j^n+1 \n+eT_ij+1^n+1 \n+fT_ij^n \n-rho_ij H_ij = R_ij\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\na  = -frack_y(ij)Deltay^2 \nb  = -frack_x(ij)Deltax^2 \nc  = fracrho_ij c_p(ij)Deltat \n+frack_x(i+1j)Deltax^2 + frack_x(ij)Deltax^2 \n+frack_y(ij+1)Deltay^2 + frack_y(ij)Deltay^2 \nd  = -frack_x(i+1j)Deltax^2 \ne  = -frack_y(ij+1)Deltay^2 \nf  = -fracrho_ij c_p(ij)Deltat \nendsplitendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Additional solver (explicit, implicit, CNA) for variable thermal parameter will follow in the near future. ","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/DiffTwoD/#Temperature-Field-Management","page":"2D","title":"Temperature Field Management","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In the explicit solver and the defect correction method, the extended temperature field, which includes ghost nodes, is required to compute the temperature at the new time step. The current temperature values at the centroids are assigned to this extended field to serve as the old temperature.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For the remaining solvers, the current temperature field at the centroids is used to construct the known right-hand side vector. The corresponding coefficient matrices are assembled to solve for the unknown temperature at the next time step.","category":"page"},{"location":"man/DiffTwoD/#Steady-State-Solution","page":"2D","title":"Steady State Solution","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"In steady state, the temperature field does not vary with time (i.e., partial Tpartial t = 0), and the heat equation simplifies to an elliptic partial differential equation, also known as the Poisson equation.","category":"page"},{"location":"man/DiffTwoD/#Poisson-Equation-(Constant-k)","page":"2D","title":"Poisson Equation (Constant k)","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For constant thermal conductivity, the steady-state heat equation is given by:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n0 = left( \n    fracpartial^2 Tpartial x^2 + fracpartial^2 Tpartial z^2\n    right) + fracQk\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Using central finite differences to approximate the spatial derivatives, this becomes:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\n0 = left( \nfracT_i-1j - 2T_ij + T_i+1jDelta x^2 + fracT_ij-1 - 2T_ij + T_ij+1Delta y^2\nright) + fracQk\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where i and j denote the indices in the x- and y-directions, respectively.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Rearranging the terms yields a linear system of the form:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation \nbT_ij-1 + aT_i-1j - 2(a+b)T_ij + aT_i+1j + bT_ij+1 = -fracQk\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"with","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\na = frac1Delta x^2 quad\nb = frac1Delta y^2\nendequation","category":"page"},{"location":"man/DiffTwoD/#Boundary-Conditions-3","page":"2D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Boundary conditions are enforced using ghost nodes, requiring modifications to both the coefficient matrix and the right-hand side vector.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Dirichlet Boundary Conditions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nbT_1j-1 - (3a + 2b)T_1j + bT_1j+1 + aT_2j = -fracQ_ijk_ij - 2aT_BCW\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\naT_ncx-1j + bT_ncxj-1 - (3a + 2b)T_ncxj + bT_ncxj+1 = -fracQ_ijk_ij - 2aT_BCE\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\naT_i-11 - (2a + 3b)T_11 + bT_i2 + aT_i+11 = -fracQ_ijk_ij - 2bT_BCS\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\naT_i-1ncy + bT_incy-1 - (2a + 3b)T_1ncy + aT_i+1ncy = -fracQ_ijk_ij - 2bT_BCN\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"Neumann Boundary Condtions","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"West boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\nbT_1j-1 - (a + 2b)T_1j + bT_1j+1 + aT_2j = -fracQ_ijk_ij + ac_WDeltax\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"East boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\naT_ncx-1j + bT_ncxj-1 - (a + 2b)T_ncxj + bT_ncxj+1 = -fracQ_ijk_ij - ac_EDeltax\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"South boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\naT_i-11 - (2a + b)T_11 + bT_i2 + aT_i+11 = -fracQ_ijk_ij + bc_SDeltay\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"North boundary","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\naT_i-1ncy + bT_incy-1 - (2a + b)T_1ncy + aT_i+1ncy = -fracQ_ijk_ij - bc_NDeltay\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For implementation details, refer to the source code.","category":"page"},{"location":"man/DiffTwoD/#Poisson-Equation-(variable-k)","page":"2D","title":"Poisson Equation (variable k)","text":"","category":"section"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For spatially varying thermal conductivity, the steady-state heat equation in 2-D is given by:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation \n0 = fracpartialpartial xleft(k_xfracpartial Tpartial xright) + \nfracpartialpartial yleft(k_yfracpartial Tpartial yright) + Q_ij \nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"To discretize this equation conservatively, a staggered finite difference scheme is used: the heat flux q_i = k_i fracpartial Tpartial i is defined between centroids, while the temperature is defined at the centroids.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"This yields the discretized form:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation \nb k_yij T_ij-1 + a k_xij T_i-1j + c T_ij + a k_xi+1j T_i+1j + b k_yij+1 T_ij+1 + Q_ij = 0  \nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"where:","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"beginequation\na = frac1Deltax^2 quad\nb = frac1Deltay^2 textrmand  quad\nc = -aleft(k_xi+1j+k_xijright) - bleft(k_yij+1+k_yijright)\nendequation","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"For further implementation details, see the source code.","category":"page"},{"location":"man/DiffTwoD/","page":"2D","title":"2D","text":"","category":"page"},{"location":"man/AdvTwoD/#Advection-Equation-(2D)","page":"2D","title":"Advection Equation (2D)","text":"","category":"section"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"In two dimensions (x and y), the advection equation for the temperature conservation equation, for example, is given as follows ","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"beginequation\nfracpartialTpartialt = -v_x left(fracpartialTpartialxright) - v_y left(fracpartialTpartialyright)\nendequation","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"where T is the temperature [K], t is the time [s], and v_x and v_y are the velocities in the x- and y-direction, respectively. ","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"The finite difference approximations of the different discretization schemes do not vary significantly from the 1D case. For more theoretical background, please refer to the 1D documentation.","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"The following sections provide a brief overview of the available 2D discretization schemes.","category":"page"},{"location":"man/AdvTwoD/#Discretization-Schemes","page":"2D","title":"Discretization Schemes","text":"","category":"section"},{"location":"man/AdvTwoD/#Upwind","page":"2D","title":"Upwind","text":"","category":"section"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"In 2D, the advection equation can be discretized using the upwind scheme as:","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"beginequation\nfracT_ij^n+1-T_ij^nDelta t = -v_xij\nbegincases\nfracT_ij^n-T_i-1j^nDelta x textif  v_xij gt 0  fracT_i+1j^n-T_ij^nDelta x textif  v_xij lt 0\nendcases \n-v_yij\nbegincases\nfracT_ij^n-T_ij-1^nDelta y textif  v_yij  0  \nfracT_ij+1^n-T_ij^nDelta y textif  v_yij0\nendcases\nendequation","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"where T is the temperature, v the velocity, n is the current time step, Delta t the time step increment, and i, j are the spatial indices in the x- and y-directions, respectively. For implementation details, see the source code.","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"This method is stable and effective but introduces numerical diffusion if the Courant condition is not satisfied. It is also only first-order accurate in space.","category":"page"},{"location":"man/AdvTwoD/#Staggered-Leapfrog","page":"2D","title":"Staggered Leapfrog","text":"","category":"section"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"The 2D staggered leapfrog discretization is given by:","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"beginequation\nfracT_ij^n+1 - T_ij^n-12Delta t = \n-v_xijfracT_i+1j^n - T_i-1j^n2Delta x \n-v_yijfracT_ij+1^n - T_ij-1^n2Delta y\nendequation","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"For implementation details, see the source code.","category":"page"},{"location":"man/AdvTwoD/#Semi-lagragian","page":"2D","title":"Semi-lagragian","text":"","category":"section"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"In 2D, velocity can vary significantly in space and time. Therefore, a modified version of the 1D semi-Lagrangian scheme is used, employing an iterative midpoint method to determine the origin of the characteristic trajectory. The following steps are performed:","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"1. Mid-point (half time step) origin  Estimate the intermediate position X at time t_n+12 using the velocity at t_n+1 at point (ij).","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"2. Mid-point velocity  Compute the velocity at X using temporal averaging:","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"beginequation\nvleft(t_n+12(ij)right) = fracvleft(t_n+1(ij)right) + vleft(t_n(ij)right)2\nendequation","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"The velocity at X can be interpolated linearly from the surrounding grid points.","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"3. Actual origin point ","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"Calculate the actual origin X(t) for the position x(t_n+1(ij)) using:","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"beginequation\nX(t) = xleft(t+1(ij)right) - Deltatvleft(t_n+12Xright)\nendequation","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"This step is performed iteratively (e.g., five iterations or until convergence).","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"4. Update temperature  Use cubic interpolation to determine the temperature at the origin X(t), which defines the temperature at the final position x(t_n+1(ij)).","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"This scheme assumes no heat sources during advection. It is free from numerical diffusion but introduces interpolation-based inaccuracies. For implementation details, see the source code.   ","category":"page"},{"location":"man/AdvTwoD/#Passive-tracers","page":"2D","title":"Passive tracers","text":"","category":"section"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"Tracers are advected in 2D using fourth-oder Runge-Kutta method: ","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"beginequationbeginsplit\nx_p^n+1  = x_p^n + frac16k_1 + frac13k_2 + frac13k_3 + frac16k_4 \ny_p^n+1  = y_p^n + frac16m_1 + frac13m_2 + frac13m_3 + frac16m_4\nendsplit\nendequation","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"where:","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"beginequation\nbeginsplit\nk_1  = Deltat cdot v_x(t^n(x_p^ny_p^n)) \nm_1  = Deltat cdot v_y(t^n(x_p^ny_p^n))  newline\nk_2  = Deltat cdot v_x(t^n+Deltat2(x_p^n+k_12y_p^n+m_12)) \nm_2  = Deltat cdot v_y(t^n+Deltat2(x_p^n+k_12y_p^n+m_12))  newline\nk_3  = Deltat cdot v_x(t^n+Deltat2(x_p^n+k_22y_p^n+m_22)) \nm_3  = Deltat cdot v_y(t^n+Deltat2(x_p^n+k_22y_p^n+m_22))  newline\nk_4  = Deltat cdot v_x(t^n+Deltat(x_p^n+k_3y_p^n+m_3)) \nm_4  = Deltat cdot v_y(t^n+Deltat(y_p^n+k_3y_p^n+m_3)) \nendsplit\nendequation","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"Per default, the tracers are advected by the velocity of the staggered velocity vertices. However, if required the velocity on the centroids or a combination of both is possible. The tracer velocity is calculated using a bilinear interpolation scheme. ","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"The tracers can also be advected parallel by defining the maximum number of threads in the VScode julia extension settings (\"julia.NumThreads\"). ","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"Tracers can carry different properties such as absolute temperature or phase identification number (ID). For temperature, interpolation between centroids and tracer positions is required. Note that this implementation currently does not support fully coupled temperature-momentum simulations.","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"Alternatively, phase IDs (linked to properties like constant density or viscosity) can be advected to simulate compositional heterogeneity. Property interpolation is performed at vertices or centroids depending on the required context (e.g., viscosity for the momentum equations).","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"Caution is required when interpolating properties between the grid and tracers, especially when those properties influence the governing equations (e.g., viscosity in momentum conservation).","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"Currently, no new tracers are inserted where needed, limiting the applicability of this approach for coupled temperature-momentum models.","category":"page"},{"location":"man/AdvTwoD/","page":"2D","title":"2D","text":"For implementation details, please refer to the source code.","category":"page"},{"location":"man/exercises/03_1D_Heat_implicit/#[03-1D-Heat-Diffusion-(implicit)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/03_1D_Heat_implicit_en.ipynb)","page":"03 - 1D Heat Diffusion (implicit)","title":"03 - 1D Heat Diffusion (implicit)","text":"","category":"section"},{"location":"man/exercises/03_1D_Heat_implicit/","page":"03 - 1D Heat Diffusion (implicit)","title":"03 - 1D Heat Diffusion (implicit)","text":"This exercise focuses on solving the one-dimensional heat diffusion equation without internal heat generation using the implicit (backward Euler) scheme. The implicit approach is unconditionally stable and thus avoids the restrictive time-step limitation of explicit methods. However, stability does not imply higher accuracy, and the scheme requires solving a linear system at each time step.  ","category":"page"},{"location":"man/exercises/03_1D_Heat_implicit/","page":"03 - 1D Heat Diffusion (implicit)","title":"03 - 1D Heat Diffusion (implicit)","text":"The main objectives are:  ","category":"page"},{"location":"man/exercises/03_1D_Heat_implicit/","page":"03 - 1D Heat Diffusion (implicit)","title":"03 - 1D Heat Diffusion (implicit)","text":"Discretization of the PDE and approximation of derivatives with finite difference operators,  \nDefining Dirichlet and Neumann boundary conditions,  \nSetting up the coefficient matrix,  \nExploring different approaches to implement the numerical scheme:   a) using a for-loop over the grid and solving the linear system with a direct method,   b) employing predefined functions from GeoModBox.jl, and   c) solving the linear system iteratively with the defect correction method,  \nStoring the solution as a GIF animation.  ","category":"page"},{"location":"man/exercises/03_1D_Heat_implicit/","page":"03 - 1D Heat Diffusion (implicit)","title":"03 - 1D Heat Diffusion (implicit)","text":"The resulting transient evolution of a Gaussian temperature anomaly is shown in Figure 1.  ","category":"page"},{"location":"man/exercises/03_1D_Heat_implicit/","page":"03 - 1D Heat Diffusion (implicit)","title":"03 - 1D Heat Diffusion (implicit)","text":"(Image: FinalPlot_3)  ","category":"page"},{"location":"man/exercises/03_1D_Heat_implicit/","page":"03 - 1D Heat Diffusion (implicit)","title":"03 - 1D Heat Diffusion (implicit)","text":"Figure 1. Transient behavior of a one-dimensional Gaussian temperature anomaly.","category":"page"},{"location":"man/Ini/#Initial-Conditions","page":"Initial Condition","title":"Initial Conditions","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"GeoModBox.jl includes several routines or structures to define certain parameters or initialize specific anomalies. The initial conditions can be specified for properties defined on their corresponding grid (i.e., temperature, velocity, or phase) or for tracers. ","category":"page"},{"location":"man/Ini/#Initial-Temperature","page":"Initial Condition","title":"Initial Temperature","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"IniTemperature!(type,M,NC,D,x,y;Tb=600.0,Ta=1200.0,σ=0.1)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Currently, there are five different initial temperature conditions available: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"A circular anomaly with a constant background (circle)\nA Gaussian anomaly (gaussian)\nA rectangular shaped anomaly with a constant background (block)\nA linear increasing temperature with depth (linear)\nA linear increasing temperature with depth including an elliptical anomaly (lineara)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The input parameters are: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"type - Parameter defining the type (see above)\nM - Structure or tuple containing the geometry\nNC - Structure or tuple containing the centroids parameter \nD - Structure or tuple containing the field arrays\nx - Structure or tuple containing the x-coordinates\ny - tructure or tuple containing the y-coordinates","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Certain default values can be modified as well: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Tb - Scalar value for the background temperature\nTa - Scalar value for the maximum (anomaly) temperature\nσ - Width of the Gaussian temperature anomaly","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The temperature is initialized on the extended centroid grid. The corresponding field without ghost nodes is updated accordingly.","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The function is called, for example, like here: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"IniTemperature!(Ini.T,M,NC,D,x,y;Tb=P.Tbot,Ta=P.Ttop)","category":"page"},{"location":"man/Ini/#Initial-Velocity","page":"Initial Condition","title":"Initial Velocity","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"IniVelocity!(type,D,VBC,NC,NV,Δ,M,x,y;ε=1e-15)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The following velocity configurations are currently supported: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"A rigid-body rotation (RigidBody)\nA shear cell (ShearCell)\nSimple Shear (SimpleShear) \nPure Shear (PureShear)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The input parameters are: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"type - Parameter defining the type (see above)\nD - Structure or tuple containing the field arrays\nVBC - Structure or tuple containing the velocity boundary conditions\nNC - Structure or tuple containing the centroids parameter \nNV - Structure or tuple containing the vertices parameter \nΔ - Structure or tuple containing the grid resolution\nM - Structure or tuple containing the geometry\nx - Structure or tuple containing the x-coordinates\ny - tructure or tuple containing the y-coordinates","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Certain default values can be modified as well: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"ε - Background strain rate for pure shear or simple shear","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The function is called, for example, like here: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"IniVelocity!(Ini.V,D,VBC,NC,NV,Δ,M,x,y)","category":"page"},{"location":"man/Ini/#Initial-Phase","page":"Initial Condition","title":"Initial Phase","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"IniPhase!(type,D,M,x,y,NC;phase=0)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Currently, only one initial phase configuration is available: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"A rectangular shaped anomaly (block)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The input parameters are: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"type - Parameter defining the type (see above)\nD - Structure or tuple containing the field arrays\nM - Structure or tuple containing the geometry\nx - Structure or tuple containing the x-coordinates\ny - Structure or tuple containing the y-coordinates\nNC - Structure or tuple containing the centroids parameter","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Certain default values can be modified as well: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"phase - Vector containing the phase ID numbers (e.g. phase=[0,1])","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The phase is initialized on the extended centroid grid. The corresponding field without ghost nodes is updated accordingly.","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The function is called, for example, like here: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"IniPhase!(Ini.p,D,M,x,y,NC;phase)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The density on the extended, centroid grid is then, for example, updated via the phase ID: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"for i in eachindex(phase)\n    D.ρ[D.p.==phase[i]] .= ρ[i]\nend","category":"page"},{"location":"man/Ini/#Tracer-Calculations","page":"Initial Condition","title":"Tracer Calculations","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Because tracer advection can be performed in parallel, additional parameters must be defined. However, GeoModBox.jl provides functionality to initialize tracer positions and rectangular phase anomalies, if needed. Additional initial configuration methods are encouraged and can be integrated. ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The following steps are required to use tracers: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"1. Tracer initialization","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"To initialize the tracers, one needs to define the number per cell, wanted noise, and what property should be advected. The remaining parameters are the general tuples or structures used in GeoModBox.jl. ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Following the definition of the required parameters for the tracer advection, the initial tracer position can be defined via the function ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,ini,phase;λ=1.0e3,δA=5e2/15)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The function initializes the position, phase, and memory of the tracers. As initial tracer phase distribution one can choose: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"ini=:block - a rectangular block\nini=:RTI - a cosine perturbation with wavelength λ and amplitude δA ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The input parameters are: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Aparam - defines if temperature (thermal) or phase (phase) is advected\nnmx - number of horizontal tracers per cell\nnmy - number of vertical tracers per cell\nΔ - Structure or tuple containing the grid resolution\nM - Structure or tuple containing the geometry\nNC - Structure or tuple containing centroids parameter\nnoise - add noise; 1 - yes, 0 - no\nini - Initial phase distribution (block)\nphase - Vector with phase IDs, (e.g. [0,1])\nλ - Wavelength [m] for a cosine perturbation, e.g. for the RTI\nδA - Amplitude [m] of the perturbation","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"To advect the temperature, the initialization is called, for example, like here: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"# Tracer Initialization ---\nnmx,nmy     =   3,3         # tracer per cell in x and y direction\nnoise       =   1           # add noise to the initial position\nnmark       =   nmx*nmy*NC.x*NC.y   # total number of tracers\nAparam      =   :thermal    # Property to be advected\n# Tuple required for the tracer count \nMPC         =   (\n    c       =   zeros(Float64,(NC.x,NC.y)),             # per centroid\n    v       =   zeros(Float64,(NV.x,NV.y)),             # per vertices\n    th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),  # per thread\n    thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),  # per thread\n)\n# Tuple for the tracer count and the weighting\nMPC1        = (\n    PG_th   =   [similar(D.T) for _ = 1:nthreads()],        # per thread\n    PV_th   =   [similar(D.wtv) for _ = 1:nthreads()],      # per thread\n    wt_th   =   [similar(D.wt) for _ = 1:nthreads()],       # per thread\n    wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],      # per thread\n)\nMPC     =   merge(MPC,MPC1)\n# Function to initialize tracer distribution\nMa      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,0,0)\n# RK4 weights ---\nrkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\nrkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping\n# Interpolate on centroids ---\n@threads for k = 1:nmark\n    Ma.T[k] =   FromCtoM(D.T_ex, k, Ma, x, y, Δ, NC)\nend\n# Count tracer per cell ---\nCountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"To advect the phase, the initialization is called, for example, like here: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"# Tracer Advection ================================================== #\nnmx,nmy     =   3,3\nnoise       =   0\nnmark       =   nmx*nmy*NC.x*NC.y\nAparam      =   :phase\nMPC         =   (\n    c       =   zeros(Float64,(NC.x,NC.y)),\n    v       =   zeros(Float64,(NV.x,NV.y)),\n    th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),\n    thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),\n)\nMPC1        = (\n    PG_th   =   [similar(D.ρ) for _ = 1:nthreads()],    # per thread\n    PV_th   =   [similar(D.ηv) for _ = 1:nthreads()],   # per thread\n    wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread\n    wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread\n)\nMPC     =   merge(MPC,MPC1)\nMa      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,Ini.p,phase)\n# RK4 weights ---\nrkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\nrkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping\n# Count tracer per cell ---\nCountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)\n# Interpolate from tracers to cell ---\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\nMarkers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n@. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                        D.ηv[2:end-0,1:end-1] + \n                        D.ηv[1:end-1,2:end-0] + \n                        D.ηv[2:end-0,2:end-0])","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"2. Tracer advection ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The tracers are advected using Runge-Kutta 4th order. This is conducted using the function","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"AdvectTracer2D(Ma,nmark,D,x,y,dt,Δ,NC,rkw,rkv,style)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The input parameters are: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Ma - Structure containing the tracer information\nnmark - Total number of tracers\nD - Structure or tuple containing the field arrays\nx - Structure or tuple containing the x-coordinates\ny - Structure or tuple containing the y-coordinates\ndt - Time step\nΔ - Structure or tuple containing the grid resolution\nNC - Structure or tuple containing the centroids parameter\nrkw - Runge-Kutta weights for averaging\nrkv - Runge-Kutta weights for time stepping\nstyle - Defines which velocity is used for the advection","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"For more details please refer to the source code.","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Note: Currently, temperature is not intended to be advected via tracers, as this would require the update of the tracer temperature via incremental changes rather than absolute value. Within the 2-D advection example temperature advection is only used assuming non-diffusive process. Thus, no update of the tracer temperature is required! ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The advection of temperature and the update of the temperature field on the centroids is called, for example, like here: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"# Advect tracers ---\nAdvectTracer2D(Ma,nmark,D,x,y,T.Δ[1],Δ,NC,rkw,rkv,1)\n# CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,i)\nCountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,i)\n     \n# Interpolate temperature from tracers to grid ---\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.T,MPC.wt_th,D.wt,x,y,Δ,Aparam,0)           \nD.T_ex[2:end-1,2:end-1]     .= D.T","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The advection of the phase and the update of the corresponding grid parameters is called, for example, like here: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"# Advection ===\n# Advect tracers ---\n@printf(\"Running on %d thread(s)\\n\", nthreads())  \nAdvectTracer2D(Ma,nmark,D,x,y,T.Δ[1],Δ,NC,rkw,rkv,1)\nCountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,it)\n\n# Update grid parameters from tracers distributions ---\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\nMarkers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n@. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                    D.ηv[2:end-0,1:end-1] + \n                    D.ηv[1:end-1,2:end-0] + \n                    D.ηv[2:end-0,2:end-0])","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Note: The tracer distribution and interpolation of tracer properties to the centroids or vertices is a very helpful feature to initialize different, more complex model setups. This will be part of future implementations. ","category":"page"},{"location":"man/Ini/#Mutable-Structures","page":"Initial Condition","title":"Mutable Structures","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Implementation of scaled thermal convection models in GeoModBox.jl revealed that immutable NamedTuples can be numerically limiting. Some initially defined parameters, like the model height, need to be modified in order to scale them. Thus, mutable structures (mutable struct) have been included. Luckily, the functions do not distinguish between a NamedTuple and a mutable struct in Julia. Thus, no additional modification in the functions are required. ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Mutable structures are designed so that all necessary parameters are initialized with default values. To ensure that the default values are picked if no input parameter is used calling the mutable struct the option @kwdef needs to be added when initializing the structure. For more details on this please refer to the source code.","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The following, for example, initializes a mutable structure using only the default values ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"M = Geometry()","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"If one wants to modify certain parameters within the structure, one needs to call the function like: ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"M = Geometry(\n    ymax    =   1.0,        # [ m ]\n    ymin    =   0.0,        # [ m ]\n)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"This initializes a box with a minimum and maximum depth of 0.0 [m] and 1.0 [m], respectively. The remaining parameters are defined by their default values. ","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"The following mutable structures including their default values are currently available: ","category":"page"},{"location":"man/Ini/#Geometry","page":"Initial Condition","title":"Geometry","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"M = Geometry(\n    xmin    = 0.0,              # Minimum x-coordinate [ m ]\n    xmax    = 1.0,              # Maximum x-coordinate [ m ]\n    ymin    = -1.0,             # Minimum y-coordinate [ m ]\n    ymax    = 0.0,              # Maximum y-coordinate [ m ]\n)","category":"page"},{"location":"man/Ini/#Physics","page":"Initial Condition","title":"Physics","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"P = Physics(\n    g       = 9.81,             # Gravitational acceleration [ m/s² ]\n    ρ₀      = 3300.0,           # Reference density [ kg/m³ ]\n    k       = 4.125,            # Thermal conductivity [ W/m/K ]\n    cp      = 1250.0,           # Specific heat capacity [ J/kg/K ]\n    α       = 2.0e-5,           # Thermal expansion coefficient [ 1/K ]\n    Q₀      = 0.0,              # Heat production rate [ W/m³ ]\n    η₀      = 3.947725485e23,   # Reference viscosity [ Pa s ]\n    κ       = k/ρ₀/cp,          # Thermal Diffusivity [ m²/s ]    \n    ΔT      = 2500,             # Temperature difference [ K ]\n    Ttop    = 273.15,           # Temperature at the top [ K ]\n    Tbot    = Ttop + ΔT,        # Temperature at the bottom [ K ] \n    Ra      = 1e5,              # Rayleigh number\n)","category":"page"},{"location":"man/Ini/#Grid-Spacing","page":"Initial Condition","title":"Grid Spacing","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Δ = GridSpacing(\n    x   =   0.0,                # Horizontal grid resolution \n    y   =   0.0,                # Vertical grid resolution\n)","category":"page"},{"location":"man/Ini/#Data-Fields","page":"Initial Condition","title":"Data Fields","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"D = DataFields(\n    Q       = zeros(1,1),\n    T       = zeros(1,1),\n    T0      = zeros(1,1),\n    T_ex    = zeros(1,1),\n    T_exo   = zeros(1,1),\n    ρ       = zeros(1,1),\n    cp      = zeros(1,1),\n    vx      = zeros(1,1),\n    vy      = zeros(1,1),\n    Pt      = zeros(1,1),\n    vxc     = zeros(1,1),\n    vyc     = zeros(1,1),\n    vc      = zeros(1,1),\n    wt      = zeros(1,1),\n    wtv     = zeros(1,1),\n    ΔTtop   = zeros(1),\n    ΔTbot   = zeros(1),\n    Tmax    = 0.0,\n    Tmin    = 0.0,\n    Tmean   = 0.0,\nend\n)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"If the default value for a field is used, an empty array is initialized to save memory. ","category":"page"},{"location":"man/Ini/#Time-Parameter","page":"Initial Condition","title":"Time Parameter","text":"","category":"section"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"T = TimeParameter(\n    const year  =   365.25*3600*24,      #   Seconds per year\n    tmax        =   1000.0,              #   [ Ma ]\n    Δfacc       =   0.9,                 #   Courant time factor\n    Δfacd       =   0.9,                 #   Diffusion time factor\n    Δ           =   0.0,                 #   Absolute time step\n    Δc          =   0.0,                 #   Courant time step\n    Δd          =   0.0,                 #   Diffusion time stability criterion\n    itmax       =   8000,                #   Maximum iterations; 30000\n)","category":"page"},{"location":"man/Ini/","page":"Initial Condition","title":"Initial Condition","text":"Additional mutable structure will be added. For more details on the mutable structures, please refer to the source code.","category":"page"},{"location":"man/examples/Advection2D/#[Advection-Problem-(2D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/AdvectionEquation/2D_Advection.jl)","page":"Advection (2D)","title":"Advection Problem (2D)","text":"","category":"section"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"This example evaluates the accuracy of the advection solvers implemented for two-dimensional problems. The available solvers are: ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"upwind \nstaggered leapfrog\nsemi-lagrangian \ntracers","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"The first three solvers are implemented such that any property defined on the centroids (including ghost nodes) can be advected using interpolated centroid velocities from the staggered grid. Tracers are used to advect the initial temperature anomaly, but their internal properties are not updated. Instead, the temperature is interpolated onto the centroids at each time step. For more implementation details please see the documentation.","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"The initial temperature condition can be defined using one of the following anomalies: ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"a rectangular block \na Gaussian temperature distribution\na circle","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Note: The anomaly is here defined on the temperature field. However, one could also assume a similar density anomaly. This might even be more applicable for the tracer advection test. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Two different velocity fields can be used as initial conditions: ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"a rigid body rotation \nan analytical shear cell velocity","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"The second velocity field is primarily intended for testing but may also serve as an initial condition in thermal convection problems. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"In this example, rigid body rotation is the preferred initial velocity condition. Rigid body rotation provides a useful benchmark for testing advection scheme accuracy, as it applies pure rotation, displacing the anomaly without deformation. Thus, the shape and intensity of the anomaly should be the same as in the initial condition. Any deviation from the initial condition indicates either numerical diffusion (as in the upwind method) or interpolation error, particularly for sharp gradients. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"(Image: APIni)","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Figure 1. Rigid Body Rotation. Initial setup for a rigid body rotation with a circular (dashed line) or rectangular (solid line) anomaly. The velocity (gray arrows) within the square model domain is set to zero outside the inner circle area (gray shaped) to avoid boundary effects. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Initial Velocity Condtion","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"The velocity is assumed to be constant and calculated on the staggered grid. For advection, the velocity on the cenroids is used, except for the tracers. The analytical velocity for the here given velocity fields is given as","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Rigid Body Rotation","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"beginequationbeginsplit\nv_x  = fracy_c-fracH2H \nv_y  = -fracx_c-fracL2L\nendsplitendequation","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"and","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Shear Cell ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"beginequationbeginsplit\nv_x  = -textsinleft(pi fracx_vLright)*textcosleft(pi fracy_cHright) \nv_y  = textcosleft(pi fracx_cLright)*textsinleft(pi fracy_vHright)\nendsplitendequation","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"using Plots, Interpolations\nusing GeoModBox.AdvectionEquation.TwoD, GeoModBox.Tracers.TwoD\nusing GeoModBox.InitialCondition\nusing Base.Threads\nusing Printf","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"In the following one can define the advection scheme as well as the initial conditions. Additional some plot parameters are defined in the very beginning as well. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"@printf(\"Running on %d thread(s)\\n\", nthreads())\n\nsave_fig    =   1\n\n# Define Numerical Scheme ============================================ #\n# Advection ---\n#   1) upwind, 2) slf, 3) semilag, 4) tracers\nFD          =   (Method     = (Adv=:tracers,),)\n# -------------------------------------------------------------------- #\n# Define Initial Condition =========================================== #\n# Temperature --- \n#   1) circle, 2) gaussian, 3) block\n# Velocity ---\n#   1) RigidBody, 2) ShearCell\nIni         =   (T=:circle,V=:RigidBody,) \n# -------------------------------------------------------------------- #\n# Plot constants ===================================================== #\nPl  =   (\n    inc         =   5,\n    sc          =   1.0e9,\n    Minc        =   1, \n    Msz         =   0.2,\n)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Now, one can define the geometry of the squared model domain. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Model Constants ==================================================== #\nM   =   (\n    xmin    =   0.0,\n    xmax    =   1.0,\n    ymin    =   0.0,\n    ymax    =   1.0,\n)\n# -------------------------------------------------------------------- #\n ``` \n\nIn the following the numerical grid and their coordinates are defined. \n\n ```Julia\n# Numerical Constants ================================================ #\nNC  =   (\n    x       =   100,        # Number of horizontal centroids\n    y       =   100,        # Number of vertical centroids\n)\nNV =   (\n    x       =   NC.x + 1,   # Number of horizontal vertices\n    y       =   NC.y + 1,   # Number of vertical vertices\n)\nΔ   =   (\n    x   =   (abs(M.xmin)+M.xmax)/NC.x,\n    y   =   (abs(M.ymin)+M.ymax)/NC.y,\n)\n# -------------------------------------------------------------------- #\n# Grid =============================================================== #\nx   =   (\n    c       =   LinRange(M.xmin + Δ.x/2.0, M.xmax - Δ.x/2.0, NC.x),\n    ce      =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),\n    v       =   LinRange(M.xmin, M.xmax , NV.x)    \n)\ny       = (\n    c       =   LinRange(M.ymin + Δ.y/2.0, M.ymax - Δ.y/2.0, NC.y),\n    ce      =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),\n    v       =   LinRange(M.ymin, M.ymax, NV.y),    \n)\nx1      =   ( \n    c2d     =   x.c .+ 0*y.c',\n    v2d     =   x.v .+ 0*y.v', \n    vx2d    =   x.v .+ 0*y.ce',\n    vy2d    =   x.ce .+ 0*y.v',\n)\nx   =   merge(x,x1)\ny1      =   (\n    c2d     =   0*x.c .+ y.c',\n    v2d     =   0*x.v .+ y.v',\n    vx2d    =   0*x.v .+ y.ce',\n    vy2d    =   0*x.ce .+ y.v',\n)\ny   =   merge(y,y1)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"To visualize the result, the path and name for the gif animation is set. Additional, the memory for the required data fields is initialized. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Animationsettings ================================================== #\npath        =   string(\"./examples/AdvectionEquation/Results/\")\nanim        =   Plots.Animation(path, String[] )\nfilename    =   string(\"2D_advection_\",Ini.T,\"_\",Ini.V,\n                        \"_\",FD.Method.Adv)\n# -------------------------------------------------------------------- #\n# Initialize Array =================================================== #\nD       =   (\n    T       =   zeros(Float64,(NC.x,NC.y)),\n    T_ex    =   zeros(Float64,(NC.x+2,NC.y+2)),\n    T_exo   =   zeros(Float64,(NC.x+2,NC.y+2)),\n    vx      =   zeros(Float64,(NV.x,NV.y+1)),\n    vy      =   zeros(Float64,(NV.x+1,NV.y)),    \n    vxc     =   zeros(Float64,(NC.x,NC.y)),\n    vyc     =   zeros(Float64,(NC.x,NC.y)),\n    vc      =   zeros(Float64,(NC.x,NC.y)),\n    wt      =   zeros(Float64,(NC.x,NC.y)),\n    wtv     =   zeros(Float64,(NV...)),\n    Tmax    =   [0.0],\n    Tmin    =   [0.0],\n    Tmean   =   [0.0],\n)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Now, one can calculate the initial conditions. Here, the build-in functions for the initial temperature and velocity conditions, IniTemperature!() and IniVelocity!(), respectively, are used. For more informaion please refer to the documentaion. Following the velocity initialization, one can caluclate the velocity on the centroids. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Initial Conditions ================================================= #\n# Temperature ---\nIniTemperature!(Ini.T,M,NC,Δ,D,x,y)\nif FD.Method.Adv==:slf\n    D.T_exo    .=  D.T_ex\nend\n# Velocity ---\nIniVelocity!(Ini.V,D,NV,Δ,M,x,y)            # [ m/s ]\n# Get the velocity on the centroids ---\n@threads for i = 1:NC.x\n    for j = 1:NC.y\n        D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2\n        D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2\n    end\nend\n@. D.vc        = sqrt(D.vxc^2 + D.vyc^2)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Now, one needs to define the time parameter. Here, the maximum time is set such that the one full rotation of the anomaly is achieved. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Time =============================================================== #\nT   =   ( \n    tmax    =   [0.0],  \n    Δfac    =   1.0,    # Courant time factor, i.e. dtfac*dt_courant\n    Δ       =   [0.0],\n)\nT.tmax[1]   =   π*((M.xmax-M.xmin)-Δ.x)/maximum(D.vc)   # t = U/v [ s ]\nT.Δ[1]      =   T.Δfac * minimum((Δ.x,Δ.y)) / \n            (sqrt(maximum(abs.(D.vx))^2 + maximum(abs.(D.vy))^2))\nnt          =   ceil(Int,T.tmax[1]/T.Δ[1])\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"In case tracer are required one needs to initialize them in the following. For more information please refer to the documentation.","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Tracer Advection =================================================== #\nif FD.Method.Adv==:tracers \n    # Tracer Initialization ---\n    nmx,nmy     =   3,3\n    noise       =   1\n    nmark       =   nmx*nmy*NC.x*NC.y\n    Aparam      =   :thermal\n    MPC         =   (\n        c       =   zeros(Float64,(NC.x,NC.y)),\n        v       =   zeros(Float64,(NV.x,NV.y)),\n        th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),\n        thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),\n    )\n    MPC1        = (\n        PG_th   =   [similar(D.T) for _ = 1:nthreads()],    # per thread\n        PV_th   =   [similar(D.wtv) for _ = 1:nthreads()],   # per thread\n        wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread\n        wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread\n    )\n    MPC     =   merge(MPC,MPC1)\n    Ma      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,0,0)\n    # RK4 weights ---\n    rkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\n    rkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping\n    # Interpolate on centroids ---\n    @threads for k = 1:nmark\n        Ma.T[k] =   FromCtoM(D.T_ex, k, Ma, x, y, Δ, NC)\n    end\n    # Count marker per cell ---\n    CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)\nend\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Let's visualize the initial condition first. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Visualize initial condition ======================================== #\nif FD.Method.Adv==:tracers\n    p = heatmap(x.c,y.c,(D.T./D.Tmax)',color=:thermal, \n            aspect_ratio=:equal,xlims=(M.xmin, M.xmax), \n            ylims=(M.ymin, M.ymax),clims=(0.5, 1.0),\n            colorbar=true,layout=(1,2),subplot=1)\n    quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],\n            y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n            quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                    D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n            color=\"white\",layout=(1,2),subplot=1)\n    heatmap!(p,x.c,y.c,MPC.c',color=:inferno, \n            aspect_ratio=:equal,xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax),\n            colorbar=true,clims=(0.0, 18.0),title=:\"Marker per cell\",\n            layout=(1,2),subplot=2)\nelse\n    p = heatmap(x.c , y.c, (D.T./D.Tmax)', \n            color=:thermal, colorbar=true, aspect_ratio=:equal, \n            xlabel=\"x\", ylabel=\"z\", \n            title=\"Temperature\", \n            xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax), \n            clims=(0.5, 1.0))\n    quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n            quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                    D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n            color=\"white\")\nend\nif save_fig == 1\n    Plots.frame(anim)\nelseif save_fig == 0\n    display(p)\nend\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"(Image: APIniPlot)","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Figure 2. Initial condition. Initial rigid body rotation setup including a circular shaped temperature anomaly. The temperature field is normalized by its maximum value so that the anomaly intensity equals one. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Now, one can start the time loop and the advection. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Time Loop ========================================================== #\nfor i=2:nt\n    @printf(\"Time step: #%04d\\n \",i)\n\n    # Advection ===\n    if FD.Method.Adv==:upwind\n        upwindc2D!(D.T,D.T_ex,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n    elseif FD.Method.Adv==:slf\n        slfc2D!(D.T,D.T_ex,D.T_exo,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n    elseif FD.Method.Adv==:semilag\n        semilagc2D!(D.T,D.T_ex,D.vxc,D.vyc,[],[],x,y,T.Δ[1])\n    elseif FD.Method.Adv==:tracers\n        # Advect tracers ---\n        AdvectTracer2D(Ma,nmark,D,x,y,T.Δ[1],Δ,NC,rkw,rkv,1)\n        # CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,i)\n        CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,i)\n        \n        # Interpolate temperature from tracers to grid ---\n        Markers2Cells(Ma,nmark,MPC.PG_th,D.T,MPC.wt_th,D.wt,x,y,Δ,Aparam,0)           \n        D.T_ex[2:end-1,2:end-1]     .= D.T\n    end\n    \n    display(string(\"ΔT = \",((maximum(filter(!isnan,D.T))-D.Tmax[1])/D.Tmax[1])*100))\n\n    # Plot Solution ---\n    if mod(i,10) == 0 || i == nt\n        if FD.Method.Adv==:tracers\n            p = heatmap(x.c,y.c,(D.T./D.Tmax)',color=:thermal, \n                    aspect_ratio=:equal,xlims=(M.xmin, M.xmax), \n                    ylims=(M.ymin, M.ymax),clims=(0.5, 1.0),\n                    colorbar=true,layout=(1,2),subplot=1)\n            quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                    y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                    quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                            D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n                    color=\"white\",layout=(1,2),subplot=1)\n            heatmap!(p,x.c,y.c,MPC.c',color=:inferno, \n                    aspect_ratio=:equal,xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax),\n                    colorbar=true,clims=(0.0, 18.0),title=:\"Marker per cell\",\n                    layout=(1,2),subplot=2)\n        else\n            p = heatmap(x.c , y.c, (D.T./D.Tmax)', \n                    color=:thermal, colorbar=true, aspect_ratio=:equal, \n                    xlabel=\"x\", ylabel=\"z\", \n                    title=\"Temperature\", \n                    xlims=(M.xmin, M.xmax), ylims=(M.ymin, M.ymax), \n                    clims=(0.5, 1.0))\n            quiver!(p,x.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                        y.c2d[1:Pl.inc:end,1:Pl.inc:end],\n                        quiver=(D.vxc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc,\n                                D.vyc[1:Pl.inc:end,1:Pl.inc:end].*Pl.sc),        \n                    color=\"white\")\n        end\n        if save_fig == 1\n            Plots.frame(anim)\n        elseif save_fig == 0\n            display(p)                        \n        end\n    end\nend # End Time Loop\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"In the end, the gif animation is generated. ","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"# Save Animation ===================================================== #\nif save_fig == 1\n    # Write the frames to a GIF file\n    Plots.gif(anim, string( path, filename, \".gif\" ), fps = 15)\n    foreach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\nelseif save_fig == 0\n    display(plot(p))\nend\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"(Image: APup_ani)","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Figure 3. Rigid Body Rotation using the Upwind Scheme.","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"(Image: APtracer_ani)","category":"page"},{"location":"man/examples/Advection2D/","page":"Advection (2D)","title":"Advection (2D)","text":"Figure 4. Rigid Body Rotation using Tracers.   Left: Temperature field interpolated from tracers onto the centroids.   Right: Tracer density per cell.   The simulation was performed on a single CPU. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/#[Falling-Block-Benchmark](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockBenchmark.jl)","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"","category":"section"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"The falling block benchmark is a well-established test for assessing the accuracy of the momentum solver and the efficiency of the advection scheme, particularly under strong viscosity and density contrasts. The model setup (Figure 1) is defined by a rectangular block with a certain viscosity and density within a matrix of a different viscosity and density. Due to the density contrast, the block sinks. If the block is less viscous than the surrounding matrix, it deforms during descent. Conversely, highly viscous blocks remain largely undeformed as they sink. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"(Image: FallingBlockSU)","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Figure 1. Falling Block Setup. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"The purpose of this benchmark is twofold: ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Accuracy of the variable viscosity momentum solver. Solving the momentum equation for the initial state, one can calculate the sinking velocity of the block, which follows a characteristic trend as a function of the viscosity contrast between the block and the matrix. \nAccuracy of the advection scheme. Assuming a time-dependent problem, one can test the efficiency of the advection scheme. Here, all four different advection schemes can be choosen: \nUpwind\nStaggered leapfrog\nSemilagrangian \nTracers","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Note: In the current state, the staggered leapfrog and semilagrangian scheme are highly ineffective to advect the density and viscosity simultaneously. Viscosity overshoots—arising from contrasts of up to six orders of magnitude—can lead to unphysical negative viscosities at the centroids. Thus, the solution of the momemtum equation is not correct anymore. This issue may be mitigated by advecting phase IDs only, then assigning viscosity and density based on the interpolated phase distribution. However, this approach requires either rounding the phase field to the nearest integer or applying weighted averaging to determine physical properties. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"This example solves the falling block benchmark across a viscosity contrast range spanning six orders of magnitude (from 10^-6 to 10^6).  The simulation yields either the block’s initial sinking velocity (for steady-state problems), or its final position (for time-dependent problems with a viscosity ratio eta_r geq 0). For additional information on the benchmark, please refer to the exercise","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Again, the output of the script depends on the definition of the parameters save_fig. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"save_fig = 0 - Output every plot for each time step and model (not recommended!)\nsave_fig = 1 - Save the animations for each model and store the final position (if the issue is steady state, this stores the sinking velocity plot) \nsave_fig = -1 - Only store the final position for a time-dependent problem ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Let's first load the required modules. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"using Plots\nusing ExtendableSparse\nusing GeoModBox.InitialCondition, GeoModBox.MomentumEquation.TwoD\nusing GeoModBox.AdvectionEquation.TwoD\nusing GeoModBox.Tracers.TwoD\nusing Base.Threads\nusing Printf","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In the following, one can define the range of the viscosity ratios to be calculated and the maximum time is set for each model assuming a viscosity ratio from -6 to 6 orders of magnitude. Additionally, one can define it the problem should be steady-state or time-dependent. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"# Make it time-dependent (1) or steady-state (0)\ntd      =   0   \n# Benchmark parameter =============================================== #\nηᵣ      =   LinRange(-6.0,6.0,13)       #   Viscosity ratio\nsv      =   zeros(length(ηᵣ))           #   Sinking Velocity\ntmax    =   [7.115094, 7.114844, 7.256534, 7.377311, 7.738412, \n                7.673613, 9.886, 15.446, 19.623, 20.569, 20.569,\n                20.569, 20.589]\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In the following, one can define the advection scheme and the initial configuration. For more details on how the initial condition is implement in GeoModBox.jl, please refere to the documentaion.","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"# Define Numerical Scheme =========================================== #\n# Advection ---\n#   1) upwind, 2) slf, 3) semilag, 4) tracers\n#   Attention: Tracers are the only method that work well.\nFD          =   (Method     = (Adv=:semilag,),)\n# ------------------------------------------------------------------- #\n# Define Initial Condition ========================================== #\n# Density --- \n#   1) block\nIni         =   (p=:block,) \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one can set the directory to safe the animaion to and some plotting parameters. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"# Animation and Plot Settings ======================================= #\npath        =   string(\"./examples/StokesEquation/2D/Results/\")\nsave_fig    =   1\np2          =   plot(0,0,layout=(2,3))\ncount       =   Int64(0)\n# ------------------------------------------------------------------- #\n# Plot Settings ===================================================== #\nPl  =   (\n    qinc    =   1,\n    qsc     =   100*(60*60*24*365.25)*5e1\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In the following, one defines the model geometry and the numerical grid parameters. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"# Geometry ========================================================== #\nM       =   (\n    xmin    =   0.0,\n    xmax    =   500.0e3,    # [ m ]\n    ymin    =   -500.0e3,   # [ m ]\n    ymax    =   0.0,\n)\n# ------------------------------------------------------------------- #\n# Grid ============================================================== #\nNC      =   (\n    x   =   50, \n    y   =   50,\n)\nNV      =   (\n    x   =   NC.x + 1,\n    y   =   NC.y + 1,\n)\nΔ       =   (\n    x   =   (M.xmax - M.xmin)/NC.x,\n    y   =   (M.ymax - M.ymin)/NC.y,\n)\nx       =   (\n    c   =   LinRange(M.xmin+Δ.x/2,M.xmax-Δ.x/2,NC.x),\n    ce  =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),\n    v   =   LinRange(M.xmin,M.xmax,NV.x),\n)\ny       =   (\n    c   =   LinRange(M.ymin+Δ.y/2,M.ymax-Δ.y/2,NC.y),\n    ce  =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),\n    v   =   LinRange(M.ymin,M.ymax,NV.y),\n)\nx1      =   (\n    c2d     =   x.c .+ 0*y.c',\n    v2d     =   x.v .+ 0*y.v', \n    vx2d    =   x.v .+ 0*y.ce',\n    vy2d    =   x.ce .+ 0*y.v',\n)\nx   =   merge(x,x1)\ny1      =   (\n    c2d     =   0*x.c .+ y.c',\n    v2d     =   0*x.v .+ y.v',\n    vx2d    =   0*x.v .+ y.ce',\n    vy2d    =   0*x.ce .+ y.v',\n)\ny   =   merge(y,y1)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one can set the physical constants of the problem. The arrays ρ and phase are used to advect the material. For more information on how this is implemented, please refer to the documentation. Additionally, the velocity boundary conditions are set. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"# Physics =========================================================== #\ng       =   9.81                #   Gravitational Acceleration\n\nη₀      =   1.0e21              #   Background Viscosity\n   \nρ₀      =   3200.0              #   Background density\nρ₁      =   3300.0              #   Block density\nρ       =   [ρ₀,ρ₁]             #   Density for phases\n\nphase   =   [0,1]               #   Phase ID\n# ------------------------------------------------------------------- #\n# Boundary Conditions =============================================== #\nVBC     =   (\n    type    =   (E=:freeslip,W=:freeslip,S=:freeslip,N=:freeslip),\n    val     =   (E=zeros(NV.y),W=zeros(NV.y),S=zeros(NV.x),N=zeros(NV.x)),\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one can start the loop of the different viscosity ratio. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"for mn in eachindex(ηᵣ)     #   Loop over ηᵣ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"To store the animation of each model, the name of the gif file is defined in the following. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    anim        =   Plots.Animation(path, String[] )\n    filename    =   string(\"Falling_\",Ini.p,\"_ηr_\",round(ηᵣ[mn]),\n                        \"_\",FD.Method.Adv)\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one can set the viscosity for the block and the viscosity array η for the advection scheme. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    # Physics ======================================================= #\n    η₁      =   η₀ * 10^(ηᵣ[mn])    #   Block Viscosity\n    η       =   [η₀,η₁]             #   Viscosity for phases\n    @show η\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In the following, the data arrays are initialized. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    # Allocation ==================================================== #\n    D   =   (\n        vx      =   zeros(Float64,NV.x,NC.y+2),\n        vy      =   zeros(Float64,NC.x+2,NV.y),\n        Pt      =   zeros(Float64,NC...),\n        pv      =   zeros(Float64,NV...),\n        p       =   zeros(Float64,NC...),\n        p_ex    =   zeros(Float64,NC.x+2,NC.y+2),\n        ρ       =   zeros(Float64,NC...),\n        ρ_ex    =   zeros(Float64,NC.x+2,NC.y+2),\n        ρ_exo   =   zeros(Float64,NC.x+2,NC.y+2),\n        vxc     =   zeros(Float64,NC...),\n        vyc     =   zeros(Float64,NC...),\n        vc      =   zeros(Float64,NC...),\n        wt      =   zeros(Float64,(NC.x,NC.y)),\n        wtv     =   zeros(Float64,(NV.x,NV.y)),\n        ηc      =   zeros(Float64,NC...),\n        ηv      =   zeros(Float64,NV...),\n        η_ex    =   zeros(Float64,NC.x+2,NC.y+2),\n        η_exo   =   zeros(Float64,NC.x+2,NC.y+2),\n    )\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one needs to initialize the time parameters. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    # Time ========================================================== #\n    T   =   ( \n        tmax    =   [0.0],  \n        Δfac    =   1.0,    # Courant time factor, i.e. dtfac*dt_courant\n        Δ       =   [0.0],\n        time    =   [0.0,0.0],\n    )\n    T.tmax[1]   =   tmax[mn] * 1e6 * (60*60*24*365.25)   # [ s ] \n    if td == 0\n        nt = 1\n    else\n        nt  =   9999\n    end\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In case tracers are used, the tracers are initialized in the following. Alternatively, the initial density and viscosity are defined on the extended grid using the phase distribution. For more details on the initial conditions, please refer to the documentation. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    # Tracer Advection ============================================== #\n    if FD.Method.Adv==:tracers \n        # Tracer Initialization ---\n        nmx,nmy     =   3,3\n        noise       =   0\n        nmark       =   nmx*nmy*NC.x*NC.y\n        Aparam      =   :phase\n        MPC         =   (\n            c       =   zeros(Float64,(NC.x,NC.y)),\n            v       =   zeros(Float64,(NV.x,NV.y)),\n            th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),\n            thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),\n        )\n        MPC1        = (\n            PG_th   =   [similar(D.ρ) for _ = 1:nthreads()],    # per thread\n            PV_th   =   [similar(D.ηv) for _ = 1:nthreads()],   # per thread\n            wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread\n            wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread\n        )\n        MPC     =   merge(MPC,MPC1)\n        Ma      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,Ini.p,phase)\n        # RK4 weights ---\n        rkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\n        rkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping\n        # Count marker per cell ---\n        CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)\n        # Interpolate from markers to cell ---\n        Markers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\n        Markers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\n        Markers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n        @. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                                D.ηv[2:end-0,1:end-1] + \n                                D.ηv[1:end-1,2:end-0] + \n                                D.ηv[2:end-0,2:end-0])\n    else\n        # ----------------------------------------------------------- #\n        # Initial Condition ========================================= #\n        IniPhase!(Ini.p,D,M,x,y,NC;phase)\n        for i in eachindex(phase)\n            D.ρ[D.p.==phase[i]] .= ρ[i]\n            D.ηc[D.p.==phase[i]] .= η[i] \n        end\n        # Density ---\n        D.ρ_ex[2:end-1,2:end-1]     .=  D.ρ\n        D.ρ_ex[1,:]     .=  D.ρ_ex[2,:]\n        D.ρ_ex[end,:]   .=  D.ρ_ex[end-1,:]\n        D.ρ_ex[:,1]     .=  D.ρ_ex[:,2]\n        D.ρ_ex[:,end]   .=  D.ρ_ex[:,end-1]\n        D.ρ_exo         .=  D.ρ_ex\n        # Viscosity ---\n        # --- Centroids -\n        D.η_ex[2:end-1,2:end-1]     .=  D.ηc\n        D.η_ex[1,:]     .=  D.η_ex[2,:]\n        D.η_ex[end,:]   .=  D.η_ex[end-1,:]\n        D.η_ex[:,1]     .=  D.η_ex[:,2]\n        D.η_ex[:,end]   .=  D.η_ex[:,end-1]\n        D.η_exo         .=  D.η_ex\n        # --- Vertices -\n        @. D.ηv     =   0.25 * (D.η_ex[1:end-1,1:end-1] + \n                                D.η_ex[2:end-0,1:end-1] + \n                                D.η_ex[1:end-1,2:end-0] + \n                                D.η_ex[2:end-0,2:end-0])\n    end\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one needs to define the parameters for the linear system of equations of the momentum equation. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    # System of Equations =========================================== #\n    # Numbering, without ghost nodes! ---\n    off    = [  NV.x*NC.y,                          # vx\n                NV.x*NC.y + NC.x*NV.y,              # vy\n                NV.x*NC.y + NC.x*NV.y + NC.x*NC.y]  # Pt\n\n    Num    =    (\n        Vx  =   reshape(1:NV.x*NC.y, NV.x, NC.y), \n        Vy  =   reshape(off[1]+1:off[1]+NC.x*NV.y, NC.x, NV.y), \n        Pt  =   reshape(off[2]+1:off[2]+NC.x*NC.y,NC...),\n    )\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Let's start the time loop! ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    # Time Loop ===================================================== #\n    for it = 1:nt","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"First, the unknown and right-hand vector for the system of equations are defined. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"        χ       =   zeros(maximum(Num.Pt))      #   Unknown Vector\n        rhs     =   zeros(maximum(Num.Pt))      #   Right-hand Side\n        # Update Time ---\n        T.time[1]   =   T.time[2] \n        @printf(\"Time step: #%04d, Time [Myr]: %04e\\n \",it,\n                    T.time[1]/(60*60*24*365.25)/1.0e6)","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one can solve the system of equations, for example, using the direct method. For more information on how this is solved, please refer to the documentation. To advect the material using the first three advection scheme, the centroid velocity is calculated. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"        # Momentum Equation =======\n        # Update K ---\n        K       =   Assembly( NC, NV, Δ, D.ηc, D.ηv, VBC, Num )\n        # Update RHS ---\n        rhs     =   updaterhs( NC, NV, Δ, D.ηc, D.ηv, D.ρ, g, VBC, Num )\n        # Solve System of Equations ---\n        χ       =   K \\ rhs\n        # Update Unknown Variables ---\n        D.vx[:,2:end-1]     .=  χ[Num.Vx]\n        D.vy[2:end-1,:]     .=  χ[Num.Vy]\n        D.Pt                .=  χ[Num.Pt]\n        # ======\n        # Get the velocity on the centroids ---\n        for i = 1:NC.x\n            for j = 1:NC.y\n                D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2\n                D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2\n            end\n        end\n        @. D.vc        = sqrt(D.vxc^2 + D.vyc^2)\n        # ---\n        @show(maximum(D.vc))\n        @show(minimum(D.Pt))\n        @show(maximum(D.Pt))\n        if it == 1\n            sv[mn]  =   maximum(D.vc)\n        end\n        # ---\n        if T.time[2] >= T.tmax[1]\n            it = nt\n        end\n        # ---","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In the following, the figures for each time step are ploted. The style of the plot varies depending on the advection scheme. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"        if mod(it,2) == 0 || it == nt || it == 1\n            if FD.Method.Adv==:tracers\n                p = heatmap(x.c./1e3,y.c./1e3,D.p',color=:inferno,\n                            xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                            title=\"Phase_c\",\n                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                            ylims=(M.ymin/1e3, M.ymax/1e3),\n                            layout=(2,2),subplot=1)\n            else\n                p = heatmap(x.v./1e3,y.v./1e3,log10.(abs.(D.ηv')),color=reverse(cgrad(:roma)),\n                            xlabel=\"x[km]\",ylabel=\"y[km]\",title=\"η_v\",\n                            clims=(15,27),\n                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                            ylims=(M.ymin/1e3, M.ymax/1e3),colorbar=true,\n                            layout=(2,2),subplot=1)\n            end\n            if FD.Method.Adv==:tracers\n                scatter!(p,Ma.x[1:Pl.qinc:end]./1e3,Ma.y[1:Pl.qinc:end]./1e3,\n                            ms=1,ma=0.5,mc=Ma.phase[1:Pl.qinc:end],markerstrokewidth=0.0,\n                            xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                            title=\"tracers\",label=\"\",\n                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                            ylims=(M.ymin/1e3, M.ymax/1e3),\n                            layout=(2,2),subplot=2)\n            else\n                heatmap!(p,x.c./1e3,y.c./1e3,D.ρ',color=:inferno,\n                            xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                            title=\"Density\",\n                            aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                            ylims=(M.ymin/1e3, M.ymax/1e3),\n                            layout=(2,2),subplot=2)\n            end\n            heatmap!(p,x.c./1e3,y.c./1e3,D.vc',\n                        xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                        title=\"V_c\",color=cgrad(:batlow),\n                        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),\n                        ylims=(M.ymin/1e3, M.ymax/1e3),\n                        layout=(2,2),subplot=4)\n            quiver!(p,x.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                        y.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                        quiver=(D.vxc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc,\n                                D.vyc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc),        \n                        la=0.5,color=\"white\",layout=(1,3),subplot=3)\n            heatmap!(p,x.c./1e3,y.c./1e3,log10.(abs.(D.ηc')),color=reverse(cgrad(:roma)),\n                        xlabel=\"x[km]\",ylabel=\"y[km]\",title=\"η_c\",\n                        clims=(15,27),\n                        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                        ylims=(M.ymin/1e3, M.ymax/1e3),colorbar=true,\n                        layout=(2,2),subplot=3)\n            if save_fig == 1\n                Plots.frame(anim)\n            elseif save_fig == 0\n                display(p)\n            end\n        end\n        if T.time[2] >= T.tmax[1]\n            break\n        end","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"Now, one needs to calculate the time step to advect the material.","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"        # Calculate Time Stepping ---\n        T.Δ[1]      =   T.Δfac * minimum((Δ.x,Δ.y)) / \n                            (sqrt(maximum(abs.(D.vx))^2 + maximum(abs.(D.vy))^2))\n        # ---\n        @printf(\"\\n\")\n        # Calculate Time ---\n        T.time[2]   =   T.time[1] + T.Δ[1]\n        if T.time[2] > T.tmax[1] \n            T.Δ[1]      =   T.tmax[1] - T.time[1]\n            T.time[2]   =   T.time[1] + T.Δ[1]\n        end","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In the following the advection is conducted. For more details on this, please refer to the documentation.","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"        # Advection ======\n        if FD.Method.Adv==:upwind\n            upwindc2D!(D.ρ,D.ρ_ex,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n            upwindc2D!(D.ηc,D.η_ex,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n        elseif FD.Method.Adv==:slf\n            slfc2D!(D.ρ,D.ρ_ex,D.ρ_exo,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n            slfc2D!(D.ηc,D.η_ex,D.η_exo,D.vxc,D.vyc,NC,T.Δ[1],Δ.x,Δ.y)\n        elseif FD.Method.Adv==:semilag\n            semilagc2D!(D.ρ,D.ρ_ex,D.vxc,D.vyc,[],[],x,y,T.Δ[1])\n            semilagc2D!(D.ηc,D.η_ex,D.vxc,D.vyc,[],[],x,y,T.Δ[1])\n        elseif FD.Method.Adv==:tracers\n            # Advect tracers ---\n            @printf(\"Running on %d thread(s)\\n\", nthreads())  \n            AdvectTracer2D(Ma,nmark,D,x,y,T.Δ[1],Δ,NC,rkw,rkv,1)\n            CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,it)\n            # Interpolate phase from tracers to grid ---\n            Markers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\n            Markers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\n            Markers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n            @. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                                D.ηv[2:end-0,1:end-1] + \n                                D.ηv[1:end-1,2:end-0] + \n                                D.ηv[2:end-0,2:end-0])\n        end\n        if FD.Method.Adv!=:tracers\n            # --- Vertices -\n            @. D.ηv     =   0.25 * (D.η_ex[1:end-1,1:end-1] + \n                                    D.η_ex[2:end-0,1:end-1] + \n                                    D.η_ex[1:end-1,2:end-0] + \n                                    D.η_ex[2:end-0,2:end-0])\n        end\n        @printf(\"\\n\")\n    end     # End Time Loop","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"If requested, the final position of the blocks are plotted and stored in the following. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"    if ηᵣ[mn] == 0.0 || ηᵣ[mn] == 1.0 || ηᵣ[mn] == 2.0 || \n                    ηᵣ[mn] == 3.0 || ηᵣ[mn] == 4.0 || ηᵣ[mn] == 6.0\n        count = count + 1\n        if FD.Method.Adv==:tracers\n            p2  =   scatter!(p2,Ma.x[1:Pl.qinc:end]./1e3,Ma.y[1:Pl.qinc:end]./1e3,\n                ms=1,ma=0.5,mc=Ma.phase[1:Pl.qinc:end],markerstrokewidth=0.0,\n                xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                title=string(\"tracers, η_r = \",ηᵣ[mn]),label=\"\",\n                aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                ylims=(M.ymin/1e3, M.ymax/1e3),\n                layout=(2,3),subplot=count)\n        else\n            p2 = heatmap!(p2,x.c./1e3,y.c./1e3,D.ρ',color=:inferno,\n                xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                title=\"Phase_c\",\n                aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                ylims=(M.ymin/1e3, M.ymax/1e3),\n                layout=(2,3),subplot=count)\n        end\n    end\n    # Save Animation ---\n    if save_fig == 1\n        if td == 1\n            # Write the frames to a GIF file\n            Plots.gif(anim, string( path, filename, \".gif\" ), fps = 15)\n            foreach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\n        end\n    end\nend # End ηᵣ Loop","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"In case the problem is set to be steady-state, the sinking velocity is plotted. If the problem is time-dependent the final position is stored. ","category":"page"},{"location":"man/examples/FallingBlockBenchmark/","page":"Falling Block Benchmark","title":"Falling Block Benchmark","text":"if td == 0\n    q = scatter(ηᵣ,sv,marker=4,\n                    ylabel=\"block velocity [m/s]\",\n                    xlabel=\"log_{10}(η_{block}/η_{medium})\",\n                    title=\"Sinking Velocity\",\n                    label=false,\n                    ylims=(0.2e-9,1.5e-9),\n                    xlims=(-6,6))\n    if save_fig == 1\n        savefig(q,string(\"./examples/StokesEquation/2D/Results/FallingBlock_SinkingVeloc\",\n                            \"_\",FD.Method.Adv,\".png\"))\n        foreach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\n    else\n        display(q)\n    end\nelse\n    if save_fig == -1 ||save_fig == 1\n        savefig(p2,string(\"./examples/StokesEquation/2D/Results/FallingBlock_FinalStage\",\n                            \"_\",FD.Method.Adv,\".png\"))\n    else\n        display(p2)\n    end\nend","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/#[12-–-2D-Thermal-Convection-(scaled)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/12_2D_Thermal_Convection_scaled_en.ipynb)","page":"12 - 2D Thermal Convection (scaled)","title":"12 – 2D Thermal Convection (scaled)","text":"","category":"section"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"This exercise revisits 2-D thermal convection in a fully nondimensional (scaled) framework. You will define scaling constants, transform the governing equations, and study how the flow depends on the Rayleigh number. The setup follows the Boussinesq approximation with isoviscous rheology and bottom heating.","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/#Objectives","page":"12 - 2D Thermal Convection (scaled)","title":"Objectives","text":"","category":"section"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"Define physically motivated scaling constants and apply the nondimensional transformations to the PDEs.  \nFormulate the dimensionless energy, momentum, and mass conservation equations (incl. buoyancy term RaT).  \nImplement boundary conditions (Dirichlet/Neumann for temperature; free-slip for velocity).  \nSolve the coupled system using finite differences (advection + diffusion + Stokes), leveraging GeoModBox solvers.  \nRun and compare models for Ra = 10^4 10^5 10^6; discuss plume/slab scale and flow vigor.  \nCompute diagnostics such as Nusselt number and RMS velocity; assess approach to steady state.","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/#Notes-for-students","page":"12 - 2D Thermal Convection (scaled)","title":"Notes for students","text":"","category":"section"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"In the scaled form we assume reference parameters eta_0 = 1 g = 1kappa = 1c_p = 1.  \nIf Ra is specified, adjust eta_0 accordingly; otherwise compute Ra from the reference set.  \nHigher Ra requires finer grids to maintain stability and accuracy; balance resolution vs. runtime.  \nKeep the documentation for the exercise brief: show the key equations, the scaling you used, and a visualization (animation or snapshot) of the final temperature/velocity fields.","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"(Image: Exercise12a)","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"Figure 1. Isoviscous, bottom-heated thermal convection for Ra = 10^6 with a resolution of 150x50. The initial condition is a linearly increasing temperature profile with an elliptical anomaly at the top. Thermal boundary conditions are fixed temperature at the top and bottom and zero heat flux at the sides. All velocity boundary conditions are free slip. Heat diffusion is solved using the Crank–Nicolson method, the Stokes equation using the defect correction method, and temperature advection with the semi-Lagrangian method. Models run until a steady state is reached or up to a maximum of 8000 iterations.  ","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"(Image: Exercise12b)","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"Figure 2. Time series of the surface Nusselt number and the root mean square velocity. For details on how these diagnostics are calculated, see the exercise.  ","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"(Image: Exercise12c)","category":"page"},{"location":"man/exercises/12_2D_Thermal_Convection_scaled/","page":"12 - 2D Thermal Convection (scaled)","title":"12 - 2D Thermal Convection (scaled)","text":"Figure 3. Variation in the root mean square velocity with numerical iterations. Empirically, a tolerance of 10^-15 was chosen to define steady state. Low-Ra cases typically reach steady state in fewer than 3000 iterations.  ","category":"page"},{"location":"man/examples/RTI/#[Rayleigh-Taylor-Instability-(RTI)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/RTI.jl)","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"","category":"section"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"This example demonstrates the transient behavior of a well-known problem in geodynamics: the Rayleigh–Taylor instability (RTI) in a two-layered system with different densities and viscosities. The script presents the setup and dynamic evolution of an RTI, which is also used in another script within GeoModBox.jl to benchmark the solution of the momentum equation under purely density-driven conditions. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"The RTI model consists of two horizontally layered materials, each characterized by specified thickness, viscosity, and density. No-slip boundary conditions are applied at the top and bottom, and symmetric velocity boundary conditions at the lateral boundaries. If the interface between the layers is perturbed (e.g., sinusoidally), the system becomes unstable. The more buoyant lower layer rises while the denser upper layer sinks, with velocities increasing over time until a new stable configuration is reached. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"The initial growth rate of the instability is mainly controlled by the density contrast, as well as the perturbation’s wavelength and amplitude. This can be estimated analytically. A benchmark example therefore is given in an additional script. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"In the following, the focus lies on setting up the RTI instability using tracers, solving the momentum equation, and advecting the phase field. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Let's load the required modules first. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"using Plots\nusing ExtendableSparse\nusing GeoModBox\nusing GeoModBox.InitialCondition, GeoModBox.MomentumEquation.TwoD\nusing GeoModBox.AdvectionEquation.TwoD\nusing GeoModBox.Tracers.TwoD\nusing Base.Threads\nusing Printf, LinearAlgebra","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Now one can setup the parameters to define the initial phase condition unsing the tracers. These parameters are later used in the function IniTracer2D()","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"save_fig    =   1\n# Define Initial Condition ========================================== #\nIni         =   (p=:RTI,)       #   Set RTI\nλ           =   3.0e3           #   Perturbation wavelength[ m ]\nδA          =   1500/15         #   Amplitude [ m ]\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"The following parameters are used for visualization. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Plot Settings ===================================================== #\nPl  =   (\n    qinc    =   4,\n    mainc   =   2,\n    qsc     =   100*(60*60*24*365.25)*3\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"In the following the model geometry and the numerical gridding are defined. The aspect ratio and horizontal resolution of the model domain are defined by the wavelength of the perturbation. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Geometry ========================================================== #\nM       =   Geometry(\n    ymin    =   -3.0e3,     # [ m ]\n    ymax    =   0.0,\n    xmin    =   0.0,\n)\nar          =   Int64(2 * λ / (M.ymax-M.ymin))  #   aspect ratio\nM.xmax      =   (M.ymax-M.ymin)*ar\n# -------------------------------------------------------------------- #\n# Grid =============================================================== # \nNC  =   (\n    x   =   50*ar,\n    y   =   50,\n)\nNV  =   (\n    x   =   NC.x + 1,\n    y   =   NC.y + 1,\n)\nΔ       =   GridSpacing(\n    x   =   (M.xmax - M.xmin)/NC.x,\n    y   =   (M.ymax - M.ymin)/NC.y,\n)\nx       =   (\n    c   =   LinRange(M.xmin+Δ.x/2,M.xmax-Δ.x/2,NC.x),\n    ce  =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),\n    v   =   LinRange(M.xmin,M.xmax,NV.x),\n)\ny       =   (\n    c   =   LinRange(M.ymin+Δ.y/2,M.ymax-Δ.y/2,NC.y),\n    ce  =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),\n    v   =   LinRange(M.ymin,M.ymax,NV.y),\n)\nx1      =   (\n    c2d     =   x.c .+ 0*y.c',\n    v2d     =   x.v .+ 0*y.v', \n    vx2d    =   x.v .+ 0*y.ce',\n    vy2d    =   x.ce .+ 0*y.v',\n)\nx   =   merge(x,x1)\ny1      =   (\n    c2d     =   0*x.c .+ y.c',\n    v2d     =   0*x.v .+ y.v',\n    vx2d    =   0*x.v .+ y.ce',\n    vy2d    =   0*x.ce .+ y.v',\n)\ny   =   merge(y,y1)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Next, define the physical parameters for the two layers. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Physics ============================================================ #\ng       =   10.0               #   Gravitational acceleration [ m/s^2 ]\n# 0 - upper layer; 1 - lower layer\nη₀      =   1e19                #   Viscosity composition 0 [ Pa s ]\nη₁      =   1e13                #   Viscosity composition 1 [ Pa s]\nηᵣ      =   log10(η₁/η₀)\nη       =   [η₀,η₁]             #   Viscosity for phases \n\nρ₀      =   3000.0              #   Density composition 0 [ kg/m^3 ]\nρ₁      =   2900.0              #   Density composition 1 [ kg/m^3 ]\nρ       =   [ρ₀,ρ₁]             #   Density for phases\n\nphase   =   [0,1]\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"For visualization purposes, a filename for the GIF animation must be defined. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Animation and Plot Settings ======================================= #\npath        =   string(\"./examples/StokesEquation/2D/Results/\")\nanim        =   Plots.Animation(path, String[] )\nfilename    =   string(Ini.p,\"_ηr_\",round(ηᵣ),\n                        \"_tracers_DC\")\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Since the energy equation is not solved, fewer data fields need to be initialized. The momentum equation is solved using the defect correction method. Therefore the strain rate and stress components are requirerd as well.  ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Allocation ======================================================== #\nD       =   (\n    ρ       =   zeros(Float64,(NC...)),\n    p       =   zeros(Float64,(NC...)),\n    cp      =   zeros(Float64,(NC...)),\n    vx      =   zeros(Float64,(NV.x,NV.y+1)),\n    vy      =   zeros(Float64,(NV.x+1,NV.y)),    \n    Pt      =   zeros(Float64,(NC...)),\n    vxc     =   zeros(Float64,(NC...)),\n    vyc     =   zeros(Float64,(NC...)),\n    vc      =   zeros(Float64,(NC...)),\n    wt      =   zeros(Float64,(NC.x,NC.y)),\n    wtv     =   zeros(Float64,(NV.x,NV.y)),\n    ηc      =   zeros(Float64,NC...),\n    ηv      =   zeros(Float64,NV...),\n)\n# ------------------------------------------------------------------- #\n# Needed for the defect correction solution ---\ndivV        =   zeros(Float64,NC...)\nε           =   (\n    xx      =   zeros(Float64,NC...), \n    yy      =   zeros(Float64,NC...), \n    xy      =   zeros(Float64,NV...),\n)\nτ           =   (\n    xx      =   zeros(Float64,NC...), \n    yy      =   zeros(Float64,NC...), \n    xy      =   zeros(Float64,NV...),\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"No-slip velocity boundary conditions are applied at the top and bottom, and free-slip conditions along the lateral boundaries. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Boundary Conditions =============================================== #\nVBC     =   (\n    type    =   (E=:freeslip,W=:freeslip,S=:noslip,N=:noslip),\n    val     =   (E=zeros(NV.y),W=zeros(NV.y),S=zeros(NV.x),N=zeros(NV.x)),\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"The number of time steps is arbitrarily limited to a maximum of 50 iterations. This enables the rise of multiple dikes without reaching a full overturn of the system. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Time ============================================================== #\nT   =   TimeParameter(\n    tmax    =   4500.0,         #   [ Ma ]\n    Δfacc   =   1.0,            #   Courant time factor\n    itmax   =   50,             #   Maximum iterations; 30000\n)\nT.tmax      =   T.tmax*1e6*T.year    #   [ s ]\nT.Δ         =   T.Δfacc * minimum((Δ.x,Δ.y)) / \n                    (sqrt(maximum(abs.(D.vx))^2 + maximum(abs.(D.vy))^2))\n\nTime        =   zeros(T.itmax)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"In the following the tracers are initialized. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Tracer Advection ================================================== #\nnmx,nmy     =   5,5\nnoise       =   0\nnmark       =   nmx*nmy*NC.x*NC.y\nAparam      =   :phase\nMPC         =   (\n    c       =   zeros(Float64,(NC.x,NC.y)),\n    v       =   zeros(Float64,(NV.x,NV.y)),\n    th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),\n    thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),\n)\nMPC1        = (\n    PG_th   =   [similar(D.ρ) for _ = 1:nthreads()],    # per thread\n    PV_th   =   [similar(D.ηv) for _ = 1:nthreads()],   # per thread\n    wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread\n    wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread\n)\nMPC     =   merge(MPC,MPC1)\nMa      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,Ini.p,phase;λ,δA)\n# RK4 weights ---\nrkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\nrkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping\n# Count marker per cell ---\nCountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)\n# Interpolate from markers to cell ---\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\nMarkers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n@. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                        D.ηv[2:end-0,1:end-1] + \n                        D.ηv[1:end-1,2:end-0] + \n                        D.ηv[2:end-0,2:end-0])\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"To solve the linear system of equations, one needs to defined the numbering of the unknowns and initialize the residual and the correction term arrays. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# System of Equations =============================================== #\n# Iterations\nniter  =    10\nϵ      =    1e-8\n# Numbering, without ghost nodes! ---\noff    = [  NV.x*NC.y,                          # vx\n            NV.x*NC.y + NC.x*NV.y,              # vy\n            NV.x*NC.y + NC.x*NV.y + NC.x*NC.y]  # Pt\n\nNum    =    (\n    Vx  =   reshape(1:NV.x*NC.y, NV.x, NC.y), \n    Vy  =   reshape(off[1]+1:off[1]+NC.x*NV.y, NC.x, NV.y), \n    Pt  =   reshape(off[2]+1:off[2]+NC.x*NC.y,NC...),\n            )\nδx      =   zeros(maximum(Num.Pt))\nF       =   zeros(maximum(Num.Pt))\n# Residuals ---\nFm     =    (\n    x       =   zeros(Float64,NV.x, NC.y), \n    y       =   zeros(Float64,NC.x, NV.y)\n)\nFPt     =   zeros(Float64,NC...)      \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Now, the time loop can be started. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Time Loop ========================================================= #\nfor it = 1:T.itmax\n    # Update Time ---\n    if it > 1\n        Time[it]   =   Time[it-1] + T.Δ \n    end\n    @printf(\"Time step: #%04d, Time [Myr]: %04e\\n \",it,\n                Time[it]/(60*60*24*365.25)/1.0e6)","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"An initial guess is provided for the momentum equation, and residuals are computed iteratively. Within the defect correction method, the coefficient matrix is assembled to calculate the correction term for the initial guess. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"    # Momentum Equation ===\n    # Initial Residual ---------------------------------------------- #\n    D.vx    .=  0.0\n    D.vy    .=  0.0\n    D.Pt    .=  1.0\n    for iter=1:niter\n        Residuals2D!(D,VBC,ε,τ,divV,Δ,D.ηc,D.ηv,g,Fm,FPt)\n        F[Num.Vx]   =   Fm.x[:]\n        F[Num.Vy]   =   Fm.y[:]\n        F[Num.Pt]   =   FPt[:]\n        @printf(\"||R|| = %1.4e\\n\", norm(F)/length(F))\n        norm(F)/length(F) < ϵ ? break : nothing\n        # Assemble Coefficients ========================================= #\n        K       =   Assembly(NC, NV, Δ, D.ηc, D.ηv, VBC, Num)\n        # --------------------------------------------------------------- #\n        # Solution of the linear system ================================= #\n        δx      =   - K \\ F\n        # --------------------------------------------------------------- #\n        # Update Unknown Variables ====================================== #\n        D.vx[:,2:end-1]     .+=  δx[Num.Vx]\n        D.vy[2:end-1,:]     .+=  δx[Num.Vy]\n        D.Pt                .+=  δx[Num.Pt]\n    end\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"For visualization, the centroid velocity field is computed. The density, marker distribution, absolut velocity and centroid viscosity is plotted for certain time steps. Depending on the parameter save_fig the plot is displayed or stored to generate a gif animation. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"    # --------------------------------------------------------------- #\n    # Get the velocity on the centroids ---\n    for i = 1:NC.x\n        for j = 1:NC.y\n            D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2\n            D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2\n        end\n    end\n    @. D.vc        = sqrt(D.vxc^2 + D.vyc^2)\n    # ---\n    @show(minimum(D.vc))\n    @show(maximum(D.vc))\n    # ---\n    if Time[it] >= T.tmax\n        it = T.itmax\n    end\n    # ---\n    if mod(it,2) == 0 || it == T.itmax || it == 1\n        p = heatmap(x.c./1e3,y.c./1e3,D.ρ',color=:inferno,\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=true,\n                    title=\"ρ\",\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),                             \n                    ylims=(M.ymin/1e3, M.ymax/1e3),\n                    layout=(2,2),subplot=1)\n        scatter!(p,Ma.x[1:Pl.mainc:end]./1e3,Ma.y[1:Pl.mainc:end]./1e3,\n                    ms=1,ma=0.5,mc=Ma.phase[1:Pl.mainc:end],markerstrokewidth=0.0,\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=true,\n                    title=\"tracers\",label=\"\",\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                    ylims=(M.ymin/1e3, M.ymax/1e3),\n                    layout=(2,2),subplot=2)\n        heatmap!(p,x.c./1e3,y.c./1e3,D.vc',\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=true,\n                    title=\"V_c\",color=cgrad(:batlow),\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),\n                    ylims=(M.ymin/1e3, M.ymax/1e3),\n                    layout=(2,2),subplot=4)\n        quiver!(p,x.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                    y.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                    quiver=(D.vxc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc,\n                            D.vyc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc),        \n                    la=0.5,color=\"white\",layout=(2,2),subplot=4)\n        heatmap!(p,x.c./1e3,y.c./1e3,log10.(D.ηc'),color=reverse(cgrad(:roma)),\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",title=\"η_c\",\n                    clims=(15,27),\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                    ylims=(M.ymin/1e3, M.ymax/1e3),colorbar=true,\n                    layout=(2,2),subplot=3)\n        if save_fig == 1\n            Plots.frame(anim)\n        elseif save_fig == 0\n            display(p)\n        end\n    end\n    if Time[it] >= T.tmax\n        break\n    end","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Since only the momentum and mass conservation equations are solved, the maximum time step is fully governed by the Courant criterium. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"    # Calculate Time Stepping ---\n    T.Δ        =   T.Δfacc * minimum((Δ.x,Δ.y)) / \n            (sqrt(maximum(abs.(D.vx))^2 + maximum(abs.(D.vy))^2))\n    if Time[it] > T.tmax\n        T.Δ         =   T.tmax - Time[it-1]\n        Time[it]    =   Time[it-1] + T.Δ\n        it          =   T.itmax\n    end","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Now, one can advect the phases on the tracers using the staggered velocity field and Runge-Kutta 4th order. Following the advection, the information on the centroids and vertices is updated from the markers. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"    # Advection ===\n    # Advect tracers ---\n    @printf(\"Running on %d thread(s)\\n\", nthreads())  \n    AdvectTracer2D(Ma,nmark,D,x,y,T.Δ,Δ,NC,rkw,rkv,1)\n    CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,it)\n    # Interpolate phase from tracers to grid ---\n    Markers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\n    Markers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\n    Markers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n    @. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                        D.ηv[2:end-0,1:end-1] + \n                        D.ηv[1:end-1,2:end-0] + \n                        D.ηv[2:end-0,2:end-0])\nend # End Time Loop","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Finally, the gif animation is generated. ","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"# Save Animation ---\nif save_fig == 1\n    # Write the frames to a GIF file\n    Plots.gif(anim, string( path, filename, \".gif\" ), fps = 15)\n    foreach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\nend","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"(Image: RTI_transient)","category":"page"},{"location":"man/examples/RTI/","page":"Rayleigh Taylor Instability (RTI)","title":"Rayleigh Taylor Instability (RTI)","text":"Figure 1. Rayleigh–Taylor Instability. Transient evolution of a two-layer system with a density contrast of 100 kg/m³ and a viscosity contrast spanning six orders of magnitude. Panels show: density (top left), tracer distribution (top right), centroid viscosity (bottom left), and absolute centroid velocity (bottom right). ","category":"page"},{"location":"man/examples/FallingBlockDC/#Falling-Block;-Defect-Correction","page":"Falling Block","title":"Falling Block; Defect Correction","text":"","category":"section"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"This documentation presents two examples illustrating the use of the defect correction method to solve the momentum equation, assuming either constant or variable viscosity, in combination with tracer-based advection. For more details on the falling block benchmark setup, please refer to the documentation. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"For more details on the defect correction method, please refer to the momentum equation documentation. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"For more details on the tracer advection method, please refer to the advection scheme documentation. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"For more details on initializing the model using tracers, please refer to the initialization documentation. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"","category":"page"},{"location":"man/examples/FallingBlockDC/#[Falling-Block-constant-\\eta](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockConstEta_Dc.jl)","page":"Falling Block","title":"Falling Block - constant eta","text":"","category":"section"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"This is an example to solve the instantenous falling block problem assuming a constant viscosity and using the defect correction method.","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"First, one needs to load the corresponding modules. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"using Plots\nusing ExtendableSparse\nusing GeoModBox.InitialCondition, GeoModBox.MomentumEquation.TwoD","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Now one can define the parameters to setup the model and some plotting parameters.","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Define Initial Condition ========================================== #\n# Density --- \n#   1) block\nIni         =   (p=:block,) \n# ------------------------------------------------------------------- #\n# Plot Settings ===================================================== #\nPl  =   (\n    qinc    =   5,\n    qsc     =   100*(60*60*24*365.25)*5e1\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"In the following, one needs to define the model geometry and the numerical grid parameters. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Geometry ========================================================== #\nM       =   (\n    xmin    =   0.0,\n    xmax    =   500.0e3,    # [ m ]\n    ymin    =   -500.0e3,   # [ m ]\n    ymax    =   0.0,\n)\n# -------------------------------------------------------------------- #\n# Grid =============================================================== #\nNC      =   (\n    x   =   50, \n    y   =   50,\n)\nNV      =   (\n    x   =   NC.x + 1,\n    y   =   NC.y + 1,\n)\nΔ       =   (\n    x   =   (M.xmax - M.xmin)/NC.x,\n    y   =   (M.ymax - M.ymin)/NC.y,\n)\nx       =   (\n    c   =   LinRange(M.xmin+Δ.x/2,M.xmax-Δ.x/2,NC.x),\n    ce  =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),\n    v   =   LinRange(M.xmin,M.xmax,NV.x),\n)\ny       =   (\n    c   =   LinRange(M.ymin+Δ.y/2,M.ymax-Δ.y/2,NC.y),\n    ce  =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),\n    v   =   LinRange(M.ymin,M.ymax,NV.y),\n)\nx1      =   (\n    c2d     =   x.c .+ 0*y.c',\n    v2d     =   x.v .+ 0*y.v', \n    vx2d    =   x.v .+ 0*y.ce',\n    vy2d    =   x.ce .+ 0*y.v',\n)\nx   =   merge(x,x1)\ny1      =   (\n    c2d     =   0*x.c .+ y.c',\n    v2d     =   0*x.v .+ y.v',\n    vx2d    =   0*x.v .+ y.ce',\n    vy2d    =   0*x.ce .+ y.v',\n)\ny   =   merge(y,y1)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Next, define the physical parameters of the problem and initialize the required data arrays. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Physics ============================================================ #\ng       =   9.81            #   Gravitational acceleration\n\nη₀      =   1.0e21          #   Reference Viscosity\n\nρ₀      =   3200.0          #   Background density\nρ₁      =   3300.0          #   Block density\nρ       =   [ρ₀,ρ₁] \n\nphase   =   [0,1]\n# ------------------------------------------------------------------- #\n# Allocation ======================================================== #\nD   =   (\n    vx      =   zeros(Float64,NV.x,NC.y+2),\n    vy      =   zeros(Float64,NC.x+2,NV.y),\n    Pt      =   zeros(Float64,NC...),\n    p       =   zeros(Int64,NC...),\n    p_ex    =   zeros(Int64,NC.x+2,NC.y+2),\n    ρ       =   zeros(Float64,NC...),\n    vxc     =   zeros(Float64,NC...),\n    vyc     =   zeros(Float64,NC...),\n    vc      =   zeros(Float64,NC...),\n)\n# Needed for the defect correction solution ---\ndivV        =   zeros(Float64,NC...)\nε           =   (\n    xx      =   zeros(Float64,NC...), \n    yy      =   zeros(Float64,NC...), \n    xy      =   zeros(Float64,NV...),\n)\nτ           =   (\n    xx      =   zeros(Float64,NC...), \n    yy      =   zeros(Float64,NC...), \n    xy      =   zeros(Float64,NV...),\n)\n# Residuals ---\nFm     =    (\n    x       =   zeros(Float64,NV.x, NC.y), \n    y       =   zeros(Float64,NC.x, NV.y)\n)\nFPt         =   zeros(Float64,NC...)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"The velocity boundary conditions and the initial condition are set in the following. As this example computes only the instanteneous solution, tracers are not required, and the field is initialized using a predefined phase distribution function. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Boundary Conditions =============================================== #\nVBC     =   (\n    type    =   (E=:freeslip,W=:freeslip,S=:freeslip,N=:freeslip),\n    val     =   (E=zeros(NV.y),W=zeros(NV.y),S=zeros(NV.x),N=zeros(NV.x)),\n)\n# ------------------------------------------------------------------- #\n# Initial Condition ================================================= #\nIniPhase!(Ini.p,D,M,x,y,NC;phase)\nfor i in eachindex(phase)\n    D.ρ[D.p.==phase[i]] .= ρ[i]\nend\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"To solve the system of equations using the defect correction method, one needs to define the numbering of the nodes, the residual and correction vector. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# System of Equations =============================================== #\n# Numbering, without ghost nodes! ---\noff    = [  NV.x*NC.y,                          # vx\n            NV.x*NC.y + NC.x*NV.y,              # vy\n            NV.x*NC.y + NC.x*NV.y + NC.x*NC.y]  # Pt\n\nNum    =    (\n    Vx  =   reshape(1:NV.x*NC.y, NV.x, NC.y), \n    Vy  =   reshape(off[1]+1:off[1]+NC.x*NV.y, NC.x, NV.y), \n    Pt  =   reshape(off[2]+1:off[2]+NC.x*NC.y,NC...),\n            )\nF       =   zeros(maximum(Num.Pt))\nδx      =   zeros(maximum(Num.Pt))\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Now, one can solve the system of equations for the initial residuals. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Initial Residual -------------------------------------------------- #\nResiduals2Dc!(D,VBC,ε,τ,divV,Δ,η₀,g,Fm,FPt)\nF[Num.Vx]   =   Fm.x[:]\nF[Num.Vy]   =   Fm.y[:]\nF[Num.Pt]   =   FPt[:]\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"In the following, the coefficients for the coefficient matrix are collected and the correction term is calculated. The correction term is used to update the initial velocity and pressure guess. The final residual quantifies the accuracy of the numerical solution. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Assemble Coefficients ============================================= #\nK       =   Assemblyc(NC, NV, Δ, η₀, VBC, Num)\n# ------------------------------------------------------------------- #\n# Solution of the linear system ===================================== #\nδx      =   - K \\ F\n# ------------------------------------------------------------------- #\n# Update Unknown Variables ========================================== #\nD.vx[:,2:end-1]     .+=  δx[Num.Vx]\nD.vy[2:end-1,:]     .+=  δx[Num.Vy]\nD.Pt                .+=  δx[Num.Pt]\n# Final Residual ==================================================== #\nResiduals2Dc!(D,VBC,ε,τ,divV,Δ,η₀,g,Fm,FPt)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"For visualization purposes, the centroid velocity is calculated. Subsequently, the density, velocity components, and pressure fields of the instantaneous solution are plotted. The final figure is stored in the results directory. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# ------------------------------------------------------------------- #\n# Get the velocity on the centroids ---\nfor i = 1:NC.x\n    for j = 1:NC.y\n        D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2\n        D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2\n    end\nend\n@. D.vc        = sqrt(D.vxc^2 + D.vyc^2)\n# ---\n@show(minimum(D.vc))\n@show(maximum(D.vc))\n# ---\np = heatmap(x.c./1e3,y.c./1e3,D.ρ',color=:inferno,\n        xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n        title=\"Density\",\n        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n        ylims=(M.ymin/1e3, M.ymax/1e3),\n        layout=(2,2),subplot=1)\nquiver!(p,x.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n        y.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n        quiver=(D.vx[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc,\n        D.vyc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc), \n        la=0.5,\n        color=\"white\",layout=(2,2),subplot=1)\nheatmap!(p,x.c./1e3,y.c./1e3,D.vxc',\n        xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n        title=\"V_x\",color=cgrad(:batlow),\n        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),\n        ylims=(M.ymin/1e3, M.ymax/1e3),\n        layout=(2,2),subplot=3)\nheatmap!(p,x.c./1e3,y.c./1e3,D.vyc',\n        xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n        title=\"V_y\",color=cgrad(:batlow),\n        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),\n        ylims=(M.ymin/1e3, M.ymax/1e3),\n        layout=(2,2),subplot=4)\nheatmap!(p,x.c./1e3,y.c./1e3,D.Pt',\n        xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n        title=\"P_t\",color=cgrad(:lipari),\n        aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),\n        ylims=(M.ymin/1e3, M.ymax/1e3),\n        layout=(2,2),subplot=2)\ndisplay(p)\n\nsavefig(p,string(\"./examples/StokesEquation/2D/Results/FallingBlockConstEta_Instanteneous_DC.png\"))","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"(Image: FBIsoInst)","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Figure 1. Instanteneous solution of an isoviscous falling block problem. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"","category":"page"},{"location":"man/examples/FallingBlockDC/#[Falling-Block-variable-\\eta](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/FallingBlockVarEta_DC.jl)","page":"Falling Block","title":"Falling Block-variable eta","text":"","category":"section"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"This is an example to solve the falling block problem assuming a variable viscosity and using the defect correction method. The advection is done using tracers","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Let's load the necessary modules first. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"using Plots\nusing ExtendableSparse\nusing GeoModBox.InitialCondition, GeoModBox.MomentumEquation.TwoD\nusing GeoModBox.AdvectionEquation.TwoD\nusing GeoModBox.Tracers.TwoD\nusing Base.Threads\nusing Printf","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"As in the previous example, one needs to define the initial configuration, some plotting parameters, the model geometry, and the numerical grid at first. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Define Initial Condition ========================================== #\n#   1) block\nIni         =   (p=:block,) \n# ------------------------------------------------------------------- #\n# Plot Settings ===================================================== #\nPl  =   (\n    qinc    =   4,\n    mainc   =   2,\n    qsc     =   100*(60*60*24*365.25)*5e1\n)\n# ------------------------------------------------------------------- #\n# Geometry ========================================================== #\nM       =   (\n    xmin    =   0.0,\n    xmax    =   500.0e3,    # [ m ]\n    ymin    =   -500.0e3,   # [ m ]\n    ymax    =   0.0,\n)\n# -------------------------------------------------------------------- #\n# Grid =============================================================== #\nNC      =   (\n    x   =   50, \n    y   =   50,\n)\nNV      =   (\n    x   =   NC.x + 1,\n    y   =   NC.y + 1,\n)\nΔ       =   (\n    x   =   (M.xmax - M.xmin)/NC.x,\n    y   =   (M.ymax - M.ymin)/NC.y,\n)\nx       =   (\n    c   =   LinRange(M.xmin+Δ.x/2,M.xmax-Δ.x/2,NC.x),\n    ce  =   LinRange(M.xmin - Δ.x/2.0, M.xmax + Δ.x/2.0, NC.x+2),\n    v   =   LinRange(M.xmin,M.xmax,NV.x),\n)\ny       =   (\n    c   =   LinRange(M.ymin+Δ.y/2,M.ymax-Δ.y/2,NC.y),\n    ce  =   LinRange(M.ymin - Δ.x/2.0, M.ymax + Δ.x/2.0, NC.y+2),\n    v   =   LinRange(M.ymin,M.ymax,NV.y),\n)\nx1      =   (\n    c2d     =   x.c .+ 0*y.c',\n    v2d     =   x.v .+ 0*y.v', \n    vx2d    =   x.v .+ 0*y.ce',\n    vy2d    =   x.ce .+ 0*y.v',\n)\nx   =   merge(x,x1)\ny1      =   (\n    c2d     =   0*x.c .+ y.c',\n    v2d     =   0*x.v .+ y.v',\n    vx2d    =   0*x.v .+ y.ce',\n    vy2d    =   0*x.ce .+ y.v',\n)\ny   =   merge(y,y1)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Given that variable viscosity is assumed, the properties of both the block and surrounding matrix must be defined, along with other relevant physical parameters. The viscosity, density, and phase arrays are used to initialize the model using tracers. For more information, please refer to the documentation.","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Physics ============================================================ #\ng       =   9.81            #   Gravitational acceleration\n\nη₀      =   1.0e21          #   Reference Viscosity\nη₁      =   1.0e27          #   Block Viscosity\nηᵣ      =   log10(η₁/η₀)\nη       =   [η₀,η₁]         #   Viscosity for phases\n\nρ₀      =   3200.0          #   Background density\nρ₁      =   3300.0          #   Block density\nρ       =   [ρ₀,ρ₁] \n\nphase   =   [0,1]\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Next, define the output filename for the animation and initialize the data arrays. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Animation and Plot Settings ======================================= #\npath        =   string(\"./examples/StokesEquation/2D/Results/\")\nsave_fig    =   1\nanim        =   Plots.Animation(path, String[] )\nfilename    =   string(\"Falling_\",Ini.p,\"_ηr_\",round(ηᵣ),\n                        \"_tracers_DC\")\n# ------------------------------------------------------------------- #\n# Allocation ======================================================== #\nD   =   (\n    vx      =   zeros(Float64,NV.x,NC.y+2),\n    vy      =   zeros(Float64,NC.x+2,NV.y),\n    Pt      =   zeros(Float64,NC...),\n    p       =   zeros(Float64,NC...),\n    ρ       =   zeros(Float64,NC...),\n    vxc     =   zeros(Float64,NC...),\n    vyc     =   zeros(Float64,NC...),\n    vc      =   zeros(Float64,NC...),\n    wt      =   zeros(Float64,(NC.x,NC.y)),\n    wtv     =   zeros(Float64,(NV.x,NV.y)),\n    ηc      =   zeros(Float64,NC...),\n    ηv      =   zeros(Float64,NV...),\n)\n# Needed for the defect correction solution ---\ndivV        =   zeros(Float64,NC...)\nε           =   (\n    xx      =   zeros(Float64,NC...), \n    yy      =   zeros(Float64,NC...), \n    xy      =   zeros(Float64,NV...),\n)\nτ           =   (\n    xx      =   zeros(Float64,NC...), \n    yy      =   zeros(Float64,NC...), \n    xy      =   zeros(Float64,NV...),\n)\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"The velocity boundary conditions and time integration parameters are set in the following block. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Boundary Conditions =============================================== #\nVBC     =   (\n    type    =   (E=:freeslip,W=:freeslip,S=:freeslip,N=:freeslip),\n    val     =   (E=zeros(NV.y),W=zeros(NV.y),S=zeros(NV.x),N=zeros(NV.x)),\n)\n# ------------------------------------------------------------------- #\n# Time ============================================================== #\nT   =   ( \n    tmax    =   [0.0],  \n    Δfac    =   1.0,    # Courant time factor, i.e. dtfac*dt_courant\n    Δ       =   [0.0],\n    time    =   [0.0,0.0],\n)\nT.tmax[1]   =   20.589 * 1e6 * (60*60*24*365.25)   # [ s ]\nnt          =   9999\n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"To advect the properties using tracers, one needs to initialize the tracers in the following. This defines the initial position of the tracers within the model domain and assigns the phases to the corresponding tracers (IniTracer2D()). ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Note: Currently, the initial phase attribution to the tracers is only possible for a rectangular block (see source code for more details). However, additional configurations can be implemented and activated via the Ini.p variable. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Following the initialization of the tracers, the necessary information (density and viscosity) to solve the governing equations is interpolate from the tracers onto the required nodes (centroids or vertices). ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Tracer Advection ================================================== #\nnmx,nmy     =   3,3\nnoise       =   0\nnmark       =   nmx*nmy*NC.x*NC.y\nAparam      =   :phase\nMPC         =   (\n    c       =   zeros(Float64,(NC.x,NC.y)),\n    v       =   zeros(Float64,(NV.x,NV.y)),\n    th      =   zeros(Float64,(nthreads(),NC.x,NC.y)),\n    thv     =   zeros(Float64,(nthreads(),NV.x,NV.y)),\n)\nMPC1        = (\n    PG_th   =   [similar(D.ρ) for _ = 1:nthreads()],    # per thread\n    PV_th   =   [similar(D.ηv) for _ = 1:nthreads()],   # per thread\n    wt_th   =   [similar(D.wt) for _ = 1:nthreads()],   # per thread\n    wtv_th  =   [similar(D.wtv) for _ = 1:nthreads()],  # per thread\n)\nMPC     =   merge(MPC,MPC1)\nMa      =   IniTracer2D(Aparam,nmx,nmy,Δ,M,NC,noise,Ini.p,phase)\n# RK4 weights ---\nrkw     =   1.0/6.0*[1.0 2.0 2.0 1.0]   # for averaging\nrkv     =   1.0/2.0*[1.0 1.0 2.0 2.0]   # for time stepping\n# Count marker per cell ---\nCountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,1)\n# Interpolate from markers to cell ---\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\nMarkers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\nMarkers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n@. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                        D.ηv[2:end-0,1:end-1] + \n                        D.ηv[1:end-1,2:end-0] + \n                        D.ηv[2:end-0,2:end-0])\n# System of Equations =============================================== #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"To solve the linear system of equations, one needs to initialize the correspondig arrays as well. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Numbering, without ghost nodes! ---\noff    = [  NV.x*NC.y,                          # vx\n            NV.x*NC.y + NC.x*NV.y,              # vy\n            NV.x*NC.y + NC.x*NV.y + NC.x*NC.y]  # Pt\n\nNum    =    (\n    Vx  =   reshape(1:NV.x*NC.y, NV.x, NC.y), \n    Vy  =   reshape(off[1]+1:off[1]+NC.x*NV.y, NC.x, NV.y), \n    Pt  =   reshape(off[2]+1:off[2]+NC.x*NC.y,NC...),\n            )\nδx      =   zeros(maximum(Num.Pt))          # Correction term\nF       =   zeros(maximum(Num.Pt))          # Full residual (v and P)\n# Residuals ---\nFm     =    (\n    x       =   zeros(Float64,NV.x, NC.y), \n    y       =   zeros(Float64,NC.x, NV.y)\n)\nFPt     =   zeros(Float64,NC...)      \n# ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Now, one can start the time loop. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Time Loop ========================================================= #\nfor it = 1:nt\n    # Update Time ---\n    T.time[1]   =   T.time[2] \n    @printf(\"Time step: #%04d, Time [Myr]: %04e\\n \",it,\n                T.time[1]/(60*60*24*365.25)/1.0e6)","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"First the momentum equation is solved. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"    # Momentum Equation ===\n    # Initial Residual ---------------------------------------------- #\n    D.vx    .=  0.0\n    D.vy    .=  0.0\n    D.Pt    .=  0.0\n    Residuals2D!(D,VBC,ε,τ,divV,Δ,D.ηc,D.ηv,g,Fm,FPt)\n    F[Num.Vx]   =   Fm.x[:]\n    F[Num.Vy]   =   Fm.y[:]\n    F[Num.Pt]   =   FPt[:]\n    # Assemble Coefficients ========================================= #\n    K       =   Assembly(NC, NV, Δ, D.ηc, D.ηv, VBC, Num)\n    # --------------------------------------------------------------- #\n    # Solution of the linear system ================================= #\n    δx      =   - K \\ F\n    # --------------------------------------------------------------- #\n    # Update Unknown Variables ====================================== #\n    D.vx[:,2:end-1]     .+=  δx[Num.Vx]\n    D.vy[2:end-1,:]     .+=  δx[Num.Vy]\n    D.Pt                .+=  δx[Num.Pt]\n    # Final Residual ================================================ #\n    Residuals2D!(D,VBC,ε,τ,divV,Δ,D.ηc,D.ηv,g,Fm,FPt)\n    # --------------------------------------------------------------- #","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"For visualization purposes, the centroid velocities are calculated. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"    # --------------------------------------------------------------- #\n    # Get the velocity on the centroids ---\n    for i = 1:NC.x\n        for j = 1:NC.y\n            D.vxc[i,j]  = (D.vx[i,j+1] + D.vx[i+1,j+1])/2\n            D.vyc[i,j]  = (D.vy[i+1,j] + D.vy[i+1,j+1])/2\n        end\n    end\n    @. D.vc        = sqrt(D.vxc^2 + D.vyc^2)\n    # ---\n    @show(minimum(D.vc))\n    @show(maximum(D.vc))\n    # ---\n    if T.time[2] >= T.tmax[1]\n        it = nt\n    end\n    # ---","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"At selected time steps, the density, tracer distribution, viscosity, and absolute velocity are visualized in a single figure. These plots are used for the animation. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"    if mod(it,2) == 0 || it == nt || it == 1\n        p = heatmap(x.c./1e3,y.c./1e3,D.ρ',color=:inferno,\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                    title=\"ρ\",\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),                             ylims=(M.ymin/1e3, M.ymax/1e3),\n                    layout=(2,2),subplot=1)\n        scatter!(p,Ma.x[1:Pl.mainc:end]./1e3,Ma.y[1:Pl.mainc:end]./1e3,\n                    ms=1,ma=0.5,mc=Ma.phase[1:Pl.mainc:end],markerstrokewidth=0.0,\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                    title=\"tracers\",label=\"\",\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                    ylims=(M.ymin/1e3, M.ymax/1e3),\n                    layout=(2,2),subplot=2)\n        heatmap!(p,x.c./1e3,y.c./1e3,D.vc',\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",colorbar=false,\n                    title=\"V_c\",color=cgrad(:batlow),\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3),\n                    ylims=(M.ymin/1e3, M.ymax/1e3),\n                    layout=(2,2),subplot=4)\n        quiver!(p,x.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                    y.c2d[1:Pl.qinc:end,1:Pl.qinc:end]./1e3,\n                    quiver=(D.vxc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc,\n                            D.vyc[1:Pl.qinc:end,1:Pl.qinc:end].*Pl.qsc),        \n                    la=0.5,color=\"white\",layout=(2,2),subplot=4)\n        heatmap!(p,x.c./1e3,y.c./1e3,log10.(D.ηc'),color=reverse(cgrad(:roma)),\n                    xlabel=\"x[km]\",ylabel=\"y[km]\",title=\"η_c\",\n                    clims=(15,27),\n                    aspect_ratio=:equal,xlims=(M.xmin/1e3, M.xmax/1e3), \n                    ylims=(M.ymin/1e3, M.ymax/1e3),colorbar=true,\n                    layout=(2,2),subplot=3)\n        if save_fig == 1\n            Plots.frame(anim)\n        elseif save_fig == 0\n            display(p)\n        end\n    end\n    if T.time[2] >= T.tmax[1]\n        break\n    end","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Now, one needs to calculate the time stepping for the advection. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"    # Calculate Time Stepping ---\n    T.Δ[1]      =   T.Δfac * minimum((Δ.x,Δ.y)) / \n                        (sqrt(maximum(abs.(D.vx))^2 + maximum(abs.(D.vy))^2))\n    @printf(\"\\n\")\n    # Calculate Time ---\n    T.time[2]   =   T.time[1] + T.Δ[1]\n    if T.time[2] > T.tmax[1] \n        T.Δ[1]      =   T.tmax[1] - T.time[1]\n        T.time[2]   =   T.time[1] + T.Δ[1]\n    end","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Finally the tracers are advected and the information on the numerical grid is updated. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"    # Advection ===\n    # Advect tracers ---\n    @printf(\"Running on %d thread(s)\\n\", nthreads())  \n    AdvectTracer2D(Ma,nmark,D,x,y,T.Δ[1],Δ,NC,rkw,rkv,1)\n    CountMPC(Ma,nmark,MPC,M,x,y,Δ,NC,NV,it)\n    # Interpolate phase from tracers to grid ---\n    Markers2Cells(Ma,nmark,MPC.PG_th,D.ρ,MPC.wt_th,D.wt,x,y,Δ,Aparam,ρ)\n    Markers2Cells(Ma,nmark,MPC.PG_th,D.p,MPC.wt_th,D.wt,x,y,Δ,Aparam,phase)\n    Markers2Vertices(Ma,nmark,MPC.PV_th,D.ηv,MPC.wtv_th,D.wtv,x,y,Δ,Aparam,η)\n    @. D.ηc     =   0.25 * (D.ηv[1:end-1,1:end-1] + \n                        D.ηv[2:end-0,1:end-1] + \n                        D.ηv[1:end-1,2:end-0] + \n                        D.ηv[2:end-0,2:end-0])\nend # End Time Loop","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"The animation is saved in the corresponding gif file. ","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"# Save Animation ---\nif save_fig == 1\n    # Write the frames to a GIF file\n    Plots.gif(anim, string( path, filename, \".gif\" ), fps = 15)\n    foreach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\nend","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"(Image: FBvarytd)","category":"page"},{"location":"man/examples/FallingBlockDC/","page":"Falling Block","title":"Falling Block","text":"Figure 2. Time-dependent solution of the falling block problem assuming a viscosity contrast of 6 orders of magnitude","category":"page"},{"location":"man/examples/GaussianDiffusion2D/#[Gaussian-Diffusion-(2D)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Gaussian_Diffusion.jl)","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"","category":"section"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"This example performs a resolution test for various finite difference discretization schemes applied to the 2-D temperature conservation equation, assuming constant thermal parameters and neglecting adiabatic pressure effects (i.e., a simple diffusion problem) using a Gaussian temperature anomaly.","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"The following discretization schemes are employed: ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Forward Euler\nBackward Euler\nCrank-Nicolson\nAlternating-Direction Implicit\nDefect Correction","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"As the initial condition, a Gaussian temperature distribution with a specified width and amplitude is prescribed, centered at the midpoint of the 2-D model domain. The transient behavior of this temperature distribution can be described analytically. Thus, one can calculate the accuracy for each time step of each finite difference scheme using this analytical solution. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"The 2-D analytical solution is computed using the Julia package ExactFieldSolutions. Using the analytical solution, the thermal boudnary conditions are updated for each time step. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"For simplicity, the 2-D temperature conservation equation is solved independently for each discretization scheme over time. After each time loop, the transient solution is visualized and saved as a gif animation showing the temperature distribution, it's absolute deviation from the analytical solution, a vertical profile through the center of the model domain, and the RMS. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"For more details on the different numerical discretization schemes, please see the documentation.","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"using Plots, GeoModBox.HeatEquation.TwoD, ExtendableSparse\nusing Statistics, Printf, LinearAlgebra","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Now, let's define an array which includes the names of the different numerical schemes to be used. In the following, a loop is executed in which the individual scheme is called in the very beginning (via an if statement). Also, a mulitplication factor nrnxny is defined, which controlls the maximum resolution, that is nrnxny*20. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Within in each loop over the different numerical scheme, the resolution is consecutively increased up to the maximum defined resolution.","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"If save_fig = -1, only the final plot for the resolution test is shown and stored. For save_fig = 0 all fields are plotted, but not stored, and for save_fig = 1 the transient behavior for each resolution of each numerical scheme is stored in a gif animation. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Schema  =   [\"explicit\",\"implicit\",\"CNA\",\"ADI\",\"dc\"]\n# Schema      =   [\"ADI\"]\nns          =   size(Schema,1)\nnrnxny      =   6\nsave_fig    =   -1","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Now, one needs to define the geometrical and physical parameters for the problem. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"# Physical Parameters ------------------------------------------------ #\nP       = ( \n    L       =   200e3,          #   Length [ m ]\n    H       =   200e3,          #   Height [ m ]\n    k       =   3,              #   Thermal Conductivity [ W/m/K ]\n    cp      =   1000,           #   Specific Heat Capacity [ J/kg/K ]\n    ρ       =   3200,           #   Density [ kg/m^3 ]\n    K0      =   273.15,         #   Kelvin at 0 °C\n    Q0      =   0               #   Heat production rate\n)\nP1      = (\n    κ       =   P.k/P.ρ/P.cp,   #   Thermal Diffusivity [ m^2/s ] \n    Tamp    =   500,            #   Temperaturamplitude [K]\n    σ       =   20e3,           #   \n    Xc      =   0.0,            #   x-Coordinate of the Anomalycenter\n    Zc      =   0.0             #   y-Coordinate of the Anomalycenter\n)\nP       =   merge(P,P1)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Here, the arrays for the resolution test are initialized. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"# Statistical Parameter ---------------------------------------------- #\nSt      = (\n    ε           =   zeros(size(Schema,1),nrnxny),    \n    nxny        =   zeros(size(Schema,1),nrnxny),\n    Tmax        =   zeros(size(Schema,1),nrnxny),\n    Tmean       =   zeros(size(Schema,1),nrnxny),\n    Tanamax     =   [0.0],\n    Tanamean    =   [0.0]\n)\n# -------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Now, one can start the loop over the different numerical discretization schemes (m) and over the different resolutions (l). ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"# Loop over different discretization schemes ------------------------- #\nfor m = 1:ns\n    FDSchema = Schema[m]\n    display(FDSchema)\n    for l = 1:nrnxny","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Within these loops, one needs to refine the grid parameter. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Numerical Parameters --------------------------------------- #\n        NC  = (\n            x       =   l*20,       #   Number of Centroids in x\n            y       =   l*20        #   Number of Centroids in y\n        )\n        Δ   = (\n            x       =   P.L/NC.x,   #   Grid spacing in x\n            y       =   P.H/NC.y    #   Grid Spacing in y\n        )\n        display(string(\"nx = \",NC.x,\", ny = \",NC.y))\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Since the name of the animation does contain the resolution, one needs to define it here new as well. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Animationssettings ----------------------------------------- #\n        path        =   string(\"./examples/DiffusionEquation/2D/Results/\")\n        anim        =   Plots.Animation(path, String[] )\n        filename    =   string(\"Gaussian_Diffusion_\",FDSchema,\n                            \"_nx_\",NC.x,\"_ny_\",NC.y)\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"The grid coordinates are also defined. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Grid coordinates ------------------------------------------- #\n        x       = (\n            c       =   LinRange(-P.L/2+ Δ.x/2.0, P.L/2 - Δ.x/2.0, NC.x),\n        )\n        y       = (\n            c       =   LinRange(-P.H/2 + Δ.y/2.0, P.H/2 - Δ.y/2.0, NC.y),\n        )\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"For the sake of simplicity, the calculation of the time step is kept the same for each numerical scheme. Thus, it needs to fulfill the diffusion stability criterion and needs to be newly defined within each resolution loop. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Time Parameters -------------------------------------------- #\n        T       = (\n            year        =   365.25*3600*24,     #   Seconds per year\n            Δfac        =   1.0,                #   Factor for Explicit Stability Criterion\n        )\n        T1      = (\n            tmax        =   10 * 1e6 * T.year,  #   Maximum Time in [ s ]\n            Δ           =   [0.0]            \n        )\n        T       =   merge(T,T1)\n        T.Δ[1]  =   T.Δfac * (1.0 / ( 2.0 * P.κ * ( 1 /Δ.x^2 + 1 / Δ.y^2 )))\n        \n        nt      =   ceil(Int,T.tmax/T.Δ[1])     #   Number of Time Steps\n        time    =   zeros(1,nt)\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Next, the field arrays and initial condition are initialized. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Initial Conditions  ---------------------------------------- #\n        D       = (\n            Q           =   zeros(NC...),\n            T           =   zeros(NC...),\n            T0          =   zeros(NC...),\n            T_ex        =   zeros(NC.x+2,NC.y+2),\n            Tana        =   zeros(NC...),\n            RMS         =   zeros(1,nt),\n            εT          =   zeros(NC...),\n            Tmax        =   zeros(1,nt),\n            Tmean       =   zeros(1,nt),\n            Tmaxa       =   zeros(1,nt),\n            Tprofile    =   zeros(NC.y,nt),\n            Tprofilea   =   zeros(NC.y,nt),\n            ρ           =   zeros(NC...),\n            cp          =   zeros(NC...)            \n        )\n        @. D.ρ  =   P.ρ\n        # Initial conditions\n        AnalyticalSolution2D!(D.T, x.c, y.c, time[1], (T0=P.Tamp,K=P.κ,σ=P.σ))\n        @. D.Tana                   =   D.T\n        @. D.T0                     =   D.T\n        D.T_ex[2:end-1,2:end-1]     .=  D.T","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"For visualization purposes, the temperature profile through the center of the domain is stored. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Note: Even though we do not assume a radioactive heat source, one needs to initialize the field and set it to zero. This is required by the solver. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        D.Tprofile[:,1]     .=  (D.T[convert(Int,NC.x/2),:] + \n                                    D.T[convert(Int,NC.x/2)+1,:]) / 2\n        D.Tprofilea[:,1]    .=  (D.Tana[convert(Int,NC.x/2),:] + \n                                    D.Tana[convert(Int,NC.x/2)+1,:]) / 2\n        # Heat production rate ---\n        @. D.Q          = P.Q0\n        # Visualize initial condition ---\n        # subplot 1 ---\n        p = heatmap(x.c ./ 1e3, y.c ./ 1e3, (D.T.-P.K0)', \n                color=:viridis, colorbar=false, aspect_ratio=:equal, \n                xlabel=\"x [km]\", ylabel=\"z [km]\", \n                title=\"Temperature\", \n                xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3), \n                clims=(minimum(D.T.-P.K0), maximum(D.T.-P.K0)),layout=(2,2),\n                subplot=1)\n            contour!(p,x.c./1e3,y.c/1e3,D.T'.-P.K0,\n                    levels=:5,linecolor=:black,subplot=1)\n            contour!(p,x.c./1e3,y.c/1e3,D.Tana'.-P.K0,\n                    levels=:5,linestyle=:dash,linecolor=:yellow,subplot=1)\n        # subplot 2 ---\n        heatmap!(p,x.c ./ 1e3, y.c ./ 1e3, D.εT', \n                color=:viridis, colorbar=true, aspect_ratio=:equal, \n                xlabel=\"x [km]\", ylabel=\"z [km]\", \n                title=\"Deviation\", \n                xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3),  \n                clims=(-1,1),layout=(2,2),\n                subplot=2)\n        # subplot 3 ---\n        plot!(p,D.Tprofile[:,1],y.c./1e3,\n                linecolor=:black,\n                xlabel=\"T_{x=L/2} [°C]\",ylabel=\"Depth [km]\",\n                label=\"\",\n                subplot=3)\n        plot!(p,D.Tprofilea[:,1],y.c./1e3,\n                linestyle=:dash,linecolor=:yellow,\n                xlabel=\"T_{x=L/2} [°C]\",ylabel=\"Depth [km]\",\n                label=\"\",\n                subplot=3)\n        # subplot 4 ---\n        plot!(p,time[1:end]./T.year./1e6,D.RMS[1:end],\n                label=\"\",\n                xlabel=\"Time [ Myrs ]\",ylabel=\"RMS\",\n                subplot=4)\n        if save_fig == 0\n            display(p)\n        end","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"(Image: GD2Dini)","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Figure 1. Initial condition. Top left: Numerical temperature distribution (background colored field and black contour lines) overlain by the analytical solution (yellow dashed contours). Top right: Absolute deviation of the numerical from the analytical solution. Bottom left: Vertical temperature profile along the middle of the domain; black solid - numerical, yellow dashed - analytical. Bottom right: RMS over time. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Since the resolution varies, the boundary conditions must also be redefined within the loop. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Boundary Conditions ---------------------------------------- #\n        BC     = (type    = (W=:Dirichlet, E=:Dirichlet, \n                                N=:Dirichlet, S=:Dirichlet),\n                    val     = (W=D.Tana[1,:],E=D.Tana[end,:],\n                                N=D.Tana[:,end],S=D.Tana[:,1]))\n        # ------------------------------------------------------------ #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Depending on the numerical method, one needs to define the coefficient matrix and degrees of freedom for the linear system of equations or the iterative parameters (for the defect correction method). ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        if FDSchema == \"implicit\"\n            # Linear System of Equations ----------------------------- #\n            Num     =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)\n            ndof    =   maximum(Num.T)\n            K       =   ExtendableSparseMatrix(ndof,ndof)\n            rhs     =   zeros(ndof)\n        end\n        if FDSchema == \"CNA\"\n            # Linear System of Equations ----------------------------- #\n            Num     =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)\n            ndof    =   maximum(Num.T)\n            K1      =   ExtendableSparseMatrix(ndof,ndof)\n            K2      =   ExtendableSparseMatrix(ndof,ndof)\n            rhs     =   zeros(ndof)\n        end\n        if FDSchema == \"dc\"\n            niter       =   10\n            ϵ           =   1e-10\n            @. D.ρ      =   P.ρ\n            @. D.cp     =   P.cp\n            k           =   (x=zeros(NC.x+1,NC.x), y=zeros(NC.x,NC.x+1))\n            @. k.x      =   P.k\n            @. k.y      =   P.k\n            Num         =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)\n            ndof        =   maximum(Num.T)\n            K           =   ExtendableSparseMatrix(ndof,ndof)\n            R           =   zeros(NC...)\n            ∂T          =   (∂x=zeros(NC.x+1, NC.x), ∂y=zeros(NC.x, NC.x+1))\n            q           =   (x=zeros(NC.x+1, NC.x), y=zeros(NC.x, NC.x+1))\n        end","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Now, all parameters are defined to solve the 2-D temperature conservation equation in a time loop using the corresponding numerical scheme. The analytical solution is calculated seperately. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Time Loop -------------------------------------------------- #\n        for n = 1:nt\n            if n>1\n                if FDSchema == \"explicit\"\n                    ForwardEuler2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC)\n                elseif FDSchema == \"implicit\"\n                    BackwardEuler2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC, rhs, K, Num)\n                elseif FDSchema == \"CNA\"\n                    CNA2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC, rhs, K1, K2, Num)\n                elseif FDSchema == \"ADI\"\n                    ADI2Dc!(D, P.κ, Δ.x, Δ.y, T.Δ[1], D.ρ, P.cp, NC, BC)\n                elseif FDSchema == \"dc\"\n                    for iter = 1:niter\n                        # Evaluate residual\n                        ComputeResiduals2D!(R, D.T, D.T_ex, D.T0, ∂T, q, D.ρ, D.cp, k, BC, Δ, T.Δ[1])\n                        # @printf(\"||R|| = %1.4e\\n\", norm(R)/length(R))\n                        norm(R)/length(R) < ϵ ? break : nothing\n                        # Assemble linear system\n                        K  = AssembleMatrix2D(D.ρ, D.cp, k, BC, Num, NC, Δ, T.Δ[1])\n                        # Solve for temperature correction: Cholesky factorisation\n                        Kc = cholesky(K.cscmatrix)\n                        # Solve for temperature correction: Back substitutions\n                        δT = -(Kc\\R[:])\n                        # Update temperature\n                        @. D.T += δT[Num.T]\n                    end\n                    D.T0    .= D.T\n                end\n                time[n]     =   time[n-1] + T.Δ[1]\n                if time[n] > T.tmax \n                    T.Δ[1]  =   T.tmax - time[n-1]\n                    time[n] =   time[n-1] + T.Δ[1]\n                end                \n                # Exact solution on cell centroids\n                AnalyticalSolution2D!(D.Tana, x.c, y.c, time[n], (T0=P.Tamp,K=P.κ,σ=P.σ))\n                # Exact solution on cell boundaries\n                BoundaryConditions2D!(BC, x.c, y.c, time[n], (T0=P.Tamp,K=P.κ,σ=P.σ)) \n            end\n            # Maximum and Mean Temperature with time ---\n            D.Tmax[n]   =   maximum(D.T)\n            D.Tmean[n]  =   mean(D.T)\n            # Vertical Profile along the Center of the Domain ---\n            D.Tprofile[:,n]     .=  (D.T[convert(Int,NC.x/2),:] + \n                                        D.T[convert(Int,NC.x/2)+1,:]) / 2\n            D.Tprofilea[:,n]    .=  (D.Tana[convert(Int,NC.x/2),:] + \n                                        D.Tana[convert(Int,NC.x/2)+1,:]) / 2\n            # Deviation from the Analytical Solution ---\n            @. D.εT     =   (D.Tana - D.T)\n            # RMS ---\n            D.RMS[n]    =   sqrt(sum(D.εT.^2)/(NC.x*NC.y))\n            # Plot Solution ---\n            if mod(n,2) == 0 || n == nt\n                # subplot 1 ---\n                p = heatmap(x.c ./ 1e3, y.c ./ 1e3, (D.T.-P.K0)', \n                    color=:viridis, colorbar=false, aspect_ratio=:equal, \n                    xlabel=\"x [km]\", ylabel=\"z [km]\", \n                    title=\"Temperature\", \n                    xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3), \n                    clims=(minimum(D.T.-P.K0), maximum(D.T.-P.K0)),layout=(2,2),\n                    subplot=1)\n\n                contour!(p,x.c./1e3,y.c/1e3,D.T'.-P.K0,\n                            levels=:5,linecolor=:black,subplot=1)\n                contour!(p,x.c./1e3,y.c/1e3,D.Tana'.-P.K0,\n                            levels=:5,linestyle=:dash,linecolor=:yellow,subplot=1)\n                # subplot 2 ---\n                heatmap!(p,x.c ./ 1e3, y.c ./ 1e3, D.εT', \n                        color=:viridis, colorbar=true, aspect_ratio=:equal, \n                        xlabel=\"x [km]\", ylabel=\"z [km]\", \n                        title=\"Deviation\", \n                        xlims=(-P.L/2/1e3, P.L/2/1e3), ylims=(-P.H/2/1e3, P.H/2/1e3), \n                        clims=(-1,1),\n                        subplot=2)\n                # subplot 3 ---\n                plot!(p,D.Tprofile[:,n],y.c./1e3,\n                    linecolor=:black, ylim=(-P.H/2/1e3,P.H/2/1e3),\n                    xlim=(0,P.Tamp),\n                    xlabel=\"T_{x=L/2} [°C]\",ylabel=\"Depth [km]\",\n                    label=\"\",\n                    subplot=3)\n                plot!(p,D.Tprofilea[:,n],y.c./1e3,\n                    linestyle=:dash,linecolor=:yellow,\n                    xlabel=\"T_{x=L/2} [°C]\",ylabel=\"Depth [km]\",\n                    label=\"\",\n                    subplot=3)\n                # subplot 4 ---\n                plot!(p,time[1:n]./T.year./1e6,D.RMS[1:n],\n                    label=\"\",\n                    xlabel=\"Time [ Myrs ]\",ylabel=\"RMS\",\n                    subplot=4)\n                if save_fig == 1\n                    Plots.frame(anim)\n                elseif save_fig == 0\n                    display(p)                        \n                end\n            end\n            # End Time Loop ---\n        end        \n        display(\"Time loop finished ...\")\n        display(\"-> Use new grid size...\")","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Now, one can save the plots in a gif animation and store the values for the resolution test. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"        # Save Animation ---\n        if save_fig == 1\n            # Write the frames to a GIF file\n            Plots.gif(anim, string( path, filename, \".gif\" ), fps = 15)\n        elseif save_fig == 0\n            display(plot(p))\n        end\n        foreach(rm, filter(startswith(string(path,\"00\")), readdir(path,join=true)))\n        # ------------------------------------------------------------ #\n        # Statistical Values for Each Scheme and Resolution ---\n        St.ε[m,l]       =   maximum(D.RMS[:])\n        St.nxny[m,l]    =   1/NC.x/NC.y\n        St.Tmax[m,l]    =   D.Tmax[nt]\n        St.Tmean[m,l]   =   D.Tmean[nt]\n        St.Tanamax[1]   =   maximum(D.Tana)\n        St.Tmean[1]     =   mean(D.Tana)\n        # ------------------------------------------------------------ #\n    end\nend","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"(Image: GD2D_Evolve_example)","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Figure 2. Final animation using the Crank-Nicolson approach for a resolution of 100 x 100. Top left: Numerical solution of the transient temperature field (background colored field and black contours); yellow dashed contours - analytical solution. Top right: Absolute deviation of the numerical from the analytical solution. Bottom left: Vertical temperature profile along the middle of the domain. Bottom right: RMS over time. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"Finally, the results of the resolution test are plotted. ","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"# Visualize Statistical Values --------------------------------------- #\nq   =   plot(0,0,layout=(1,3))\nfor m = 1:ns\n#    subplot(1,3,1)\n    plot!(q,St.nxny[m,:],St.ε[m,:],\n                marker=:circle,markersize=3,label=Schema[m],\n                xaxis=:log,yaxis=:log,\n                xlabel=\"1/nx/ny\",ylabel=\"ε_{T}\",layout=(1,3),\n                subplot=1)\n    plot!(q,St.nxny[m,:],St.Tmax[m,:],\n                marker=:circle,markersize=3,label=\"\",\n                xaxis=:log,\n                xlabel=\"1/nx/ny\",ylabel=\"T_{max}\",\n                subplot=2)\n    plot!(q,St.nxny[m,:],St.Tmean[m,:],\n                marker=:circle,markersize=3,label=\"\",\n                xaxis=:log,\n                xlabel=\"1/nx/ny\",ylabel=\"⟨T⟩\",\n                subplot=3)\n    display(q)\nend\n# --------------------------------------------------------------------- #\n# Save Final Figure --------------------------------------------------- #\nif save_fig == -1\n    savefig(q,\"./examples/DiffusionEquation/2D/Results/Gaussian_ResTest.png\")\nend\n# --------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/GaussianDiffusion2D/","page":"Gaussian Diffusion (2D)","title":"Gaussian Diffusion (2D)","text":"(Image: GD_Rest_test)","category":"page"},{"location":"man/exercises/09_2D_Falling_Block/#[09-–-Falling-Block](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/09_2D_Falling_Block_en.ipynb)","page":"09 - 2D Falling Block (steady state)","title":"09 – Falling Block","text":"","category":"section"},{"location":"man/exercises/09_2D_Falling_Block/","page":"09 - 2D Falling Block (steady state)","title":"09 - 2D Falling Block (steady state)","text":"In this exercise, students simulate the motion of a dense block sinking in a viscous fluid under the influence of gravity. The problem is set up in two dimensions with constant viscosity (isoviscous case) and free-slip velocity boundary conditions on all sides.  ","category":"page"},{"location":"man/exercises/09_2D_Falling_Block/","page":"09 - 2D Falling Block (steady state)","title":"09 - 2D Falling Block (steady state)","text":"The goals of this exercise are to:  ","category":"page"},{"location":"man/exercises/09_2D_Falling_Block/","page":"09 - 2D Falling Block (steady state)","title":"09 - 2D Falling Block (steady state)","text":"Set up the 2-D model geometry and define the block phase within the background medium.  \nAssign appropriate physical parameters, such as viscosity, density contrast, and gravity.  \nImplement the momentum and mass conservation equations using the finite difference method.  \nAssemble and solve the resulting linear system of equations for velocities and pressure.  \nVisualize the velocity field and the interaction between the sinking block and the surrounding viscous medium.  ","category":"page"},{"location":"man/exercises/09_2D_Falling_Block/","page":"09 - 2D Falling Block (steady state)","title":"09 - 2D Falling Block (steady state)","text":"This exercise provides a simple but powerful benchmark problem to validate the Stokes solver and to understand the dynamics of density-driven flow in an isoviscous medium.  ","category":"page"},{"location":"man/exercises/09_2D_Falling_Block/","page":"09 - 2D Falling Block (steady state)","title":"09 - 2D Falling Block (steady state)","text":"(Image: Exercise09)","category":"page"},{"location":"man/AdvOneD/#Advection-Equation-(1D)","page":"1D","title":"Advection Equation (1D)","text":"","category":"section"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"In one dimension, the advection equation for the temperature conservation, for example, is given as follows","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialTpartialt = -v_x left(fracpartialTpartialxright)\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"where T is the temperature [K], t is the time [s], and v_x is the velocity in the x-direction. ","category":"page"},{"location":"man/AdvOneD/#Discretization-Schemes","page":"1D","title":"Discretization Schemes","text":"","category":"section"},{"location":"man/AdvOneD/#Forward-in-Time-and-Centered-in-Space-(FTCS)","page":"1D","title":"Forward in Time and Centered in Space (FTCS)","text":"","category":"section"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Let's begin with the seemingly simplest approach. Approximating the partial derivatives using a FTCS scheme results in","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1-T_i^nDeltat = -v_xleft(fracT_i+1^n-T_i-1^n2Deltaxright)\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"where Deltat and Deltax are the time step and grid resolution, respectively, and i and n denote the spatial and temporal indices. This scheme is first-order accurate in time and second-order accurate in space. ","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Rearranging gives the solution for the temperature at the next time step:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nT_i^n+1 = T_i^n - v_x DeltatfracT_i+1^n - T_i-1^n2Deltax\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"The right-hand side can be simplified using the so-called Courant number:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nalpha = fracv_xDeltatDeltax\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"which represents the number of grid points traversed in a single time step. ","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Unfortunately, this scheme is unconditionally unstable for the advection equation, as shown by a Von Neumann or Hirt's stability analysis. Furthermore, the central difference at i causes amplification of the variable (here, temperature) at each subsequent time step. Hence, the solution continually grows and is unstable.","category":"page"},{"location":"man/AdvOneD/#Lax-Friedrichs-method","page":"1D","title":"Lax-Friedrichs method","text":"","category":"section"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"One way to suppress the instability of the FTCS scheme is the Lax-Friedrichs method. This replaces the term T_i^n with its spatial average at the same time level, resulting in:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1-left(T_i+1^n+T_i-1^nright)2Deltat=-v_xfracT_i+1^n-T_i-1^n2Deltax\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Rearanging gives:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nT_i^n+1 = frac12left(T_i+1^n+T_i-1^nright)-\nfracv_x Deltat2Deltax left(T_i+1^n-T_i-1^nright)\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"This method is stable for alpha  1 but introduces significant numerical diffusion.","category":"page"},{"location":"man/AdvOneD/#Upwind","page":"1D","title":"Upwind","text":"","category":"section"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Another approach is to consider only upstream information. The upwind scheme uses one-sided finite differences, always taken in the upstream direction. This results in a scheme that is first-order accurate in both space and time. The discretized advection equation becomes:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1-T_i^nDeltat = -v_xi\nbegincases\nfracT_i^n-T_i-1^nDeltax textif  v_xi gt 0\nfracT_i+1^n-T_i^nDeltaxtextif  v_xi lt 0 \nendcases\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"The scheme is stable if the Courant criterion is satisfied (alpha le 1), but numerical diffusion remains, which depends on the grid size. A Taylor series expansion shows that, in 1D with constant velocity, the scheme becomes non-diffusive if the time step exactly satisfies the Courant criterion. The method becomes unstable if this criterion is violated.","category":"page"},{"location":"man/AdvOneD/#Staggered-Leapfrog","page":"1D","title":"Staggered Leapfrog","text":"","category":"section"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"All previously discussed explicit schemes are only first-order accurate in time and second-order in space (except upwind, which is first-order in both). To match the temporal and spatial accuracy without choosing a very small time step, one may use the staggered leapfrog scheme:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1-T_i^n-12Deltat=-v_xfracT_i+1^n-T_i-1^n2Deltax\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"This method avoids numerical diffusion, but becomes increasingly unstable when strong gradients in the advected field are present.","category":"page"},{"location":"man/AdvOneD/#Semi-Lagrangian","page":"1D","title":"Semi-Lagrangian","text":"","category":"section"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"The methods discussed above each have drawbacks. The semi-Lagrangian method addresses several of them: it is stable, does not suffer from numerical diffusion, and is not constrained by the Courant criterion. It is related to tracer-based advection schemes and solves ODEs rather than using traditional finite differences. While not inherently conservative and subject to minor interpolation errors, it offers promising accuracy and efficiency.","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"The central idea is to trace an advected particle backward in time to its origin and interpolate the corresponding value from the Eulerian grid.","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"In 1D, assuming constant velocity in time and space, the procedure is:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"1. Calculate the initial position ","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"The initial position X_i of a particle landing on the Eulerian grid point x_i at time t_n+1 is:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nX_i=x_i-Deltatcdot v_xleft(t_n+1x_iright)\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"where x_i is the coordinate of the Eulerian grid point i, Deltat is the time step, v_x the velocity in x-direction, and t_n+1 is the time at the new time step. ","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"2. Interpolate the temperature","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Interpolate the temperature at t_n from the surrounding Eulerian grid points onto the position X_i, e.g., using cubic_spline_interpolation().","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"3. Update the Temperature field","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Assuming the temperature at the grid point at t_n+1 equals the interpolated value at X_i at time t_n:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nTleft(t_n+1x_iright) = Tleft(t_nX_iright)\nendequation","category":"page"},{"location":"man/AdvOneD/#Passive-tracers","page":"1D","title":"Passive tracers","text":"","category":"section"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Using passive tracers represents a fully Lagrangian method. Initially distributed tracers (or markers) are transported by the prescribed velocity field. Tracers can carry various attributes, and if these influence the model’s rheology or dynamics, they are considered active tracers, requiring velocity correction.","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"To transport a property with tracers:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"1. Define tracers vecx_p with initial positions vecx_pleft(t=0right) and initial property values fleft(vecx_pleft(t=0right)right).","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"2. Compute flow paths by solving the ODE of particle motion, for instance using Forward Euler or Runge-Kutta integration.","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"In 1D, the path equation is:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nfracdx_pdt=v_x left(x_ptright)\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"where x_p is the x-coordinate of the tracer. ","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Forward Euler","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"The flow path ODE is approximated as:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nfracx_p^n+1-x_p^nDeltat = v_x(x_p^n) \nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Solving for the next position:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nx_p^n+1 = x_p^n + Deltatcdot v_x(x_p^n) \nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"While simple, this method suffers from inaccuracy for large Deltat and v_x.","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Runge-Kutta 4-th order","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"A more accurate method is the 4th-order Runge-Kutta. In 1D, the next position is:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nx_p^n+1 = x_p^n + frac16k_1 + frac13k_2 + frac13k_3 + frac16k_4\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"where:","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"beginequation\nbeginsplit\nk_1  = Deltat cdot v_x(t^nx_p^n) \nk_2  = Deltat cdot v_x(t^n+Deltat2x_p^n+k_12) \nk_3  = Deltat cdot v_x(t^n+Deltat2x_p^n + k_22) \nk_4  = Deltat cdot v_x(t^n+Deltatx_p^n+k_3) \nendsplit\nendequation","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"3. Interpolate grid values of f(xt) from the tracer positions vecx_p, e.g., using bilinear interpolation.","category":"page"},{"location":"man/AdvOneD/","page":"1D","title":"1D","text":"Despite the advantages, care is required. Interpolation between grid and tracer data can cause smoothing and numerical diffusion, particularly in regions with sharp gradients. Additionally, clustering or depletion of tracers can introduce further errors and may require adaptive insertion of new tracers in under-sampled regions.","category":"page"},{"location":"man/examples/PoissonRestest/#[Poisson-Problem-(constant-k)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/Poisson_ResTest.jl)","page":"Poisson Problem (2D)","title":"Poisson Problem (constant k)","text":"","category":"section"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"This example performs a resolution test for the steady-state 2-D temperature conservation equation, i.e., the Poisson equation, assuming constant thermal conductivity k. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"The maximum resolution is define by n*ncx x n*ncy, where n needs to be defined in the very beginning. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"The temperature equation is solved for each resolution in a loop and the maximum and mean temperature is stored. In theory, increasing the resolution should asymptotically approach the exact solution of the problem. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"For more details on the model setup and the physics or the numerical scheme, please see the exercise or the documentation","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"using GeoModBox.HeatEquation.TwoD, ExtendableSparse, Plots, Statistics\nusing GLM, DataFrames","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"Let's first define the maximum resolution. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"# Define the numer of differen resolutions ------------------------------ #\n# Maximum resolution is defined as nx = n*40, ny = n*20 ---\nn       =   20","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"Now, one can define the geometrical and physical constants. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"# Physical Parameters --------------------------------------------------- #\nP       = ( \n    L       =   4.0e3,      #   [m]\n    H       =   2.0e3,      #   [m]\n    k       =   5.6,        #   Conductivity, W/m/K\n    # Define the region of the anomaly\n    Wcave   =   200.0,      # Width [ m ]\n    Hcave   =   200.0,      # Thickness [ m ]\n    Dcave   =   1.0e3,      # Depth of center [ m ]\n    Xcave   =   2.0e3,      # x-position of center [ m ]\n    Q       =   0.3         # volumetric heat production rate [ W/m³ ]; Q = rho*H\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"Dirichlet boundary conditions are applied to all domain boundaries. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"# Boundary conditions --------------------------------------------------- #\nBC      =   (\n    type    = (W=:Dirichlet, E=:Dirichlet, N=:Dirichlet, S=:Dirichlet),\n    val     = (W=:0.0,E=:0.0,N=:0.0,S=:0.0)\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"The following parameters are initialized for the resolution test: ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"the reziprocal resolution \nthe maximum temperature\nthe mean temperature","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"# Define statistical parameters for visualization ---\nST      =   (\n    x       =   zeros(n),       # Reziproc resolution 1/nx/ny\n    Tmax    =   zeros(n),       # Maximum temperature\n    Tmean   =   zeros(n)        # Mean temperature\n)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"The loop over resolutions (k) is now initialized.","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"# Loop over the resolutions --------------------------------------------- #\nfor k = 1:n","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"Within the loop, the grid parameters are updated for each resolution. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"    # Numerical Parameters ---------------------------------------------- #\n    NC      = (\n        x       =   k*40,        # Gitterpunkte in x-Richtung, Spalten\n        y       =   k*20         # Gitterpunkte in y-Richtung, Zeilen    \n    )\n    println(\"Run \",k,\", ncx = \",NC.x,\", ncy = \",NC.y)\n    # Initialize grid spacing ------------------------------------------- #\n    Δ       = (\n        x       =   P.L/NC.x,\n        y       =   P.H/NC.y\n    )\n    # ------------------------------------------------------------------- #   \n    ST.x[k]     =   1 / NC.x / NC.y\n    # ------------------------------------------------------------------- #\n    # Generate the grid ------------------------------------------------- #\n    x       = (\n        c       =   LinRange(0.0 + Δ.x[1]/2.0, P.L - Δ.x[1]/2.0, NC.x),\n    )\n    y       = (\n        c       =   LinRange(-P.H + Δ.y[1]/2.0, 0.0 - Δ.y[1]/2.0, NC.y),\n    )\n    # ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"The required fields are then initialized, and initial conditions are applied. For simplicity, a constant background temperature of zero is assumed. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"    # Initialcondition -------------------------------------------------- #\n    D       = ( \n        Q       =   zeros(NC...),\n        T       =   zeros(NC...),\n    )\n    # Heat production rate in the anomaly ---\n    for i = 1:NC.x, j = 1:NC.y\n        if x.c[i] >= (P.Xcave-P.Wcave/2.0) && x.c[i] <=(P.Xcave+P.Wcave/2.0) && \n            y.c[j] >= -P.Dcave-P.Hcave/2.0 && y.c[j] <= -P.Dcave+P.Hcave/2.0 \n            D.Q[i,j]    = P.Q\n        end\n    end\n    # ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"To solve the Poisson equation, one needs to define the coefficient matrix, the degrees of freedom of the linear system of equations, and the right-hand side. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"    # Linear System of Equations ---------------------------------------- #\n    Num     =   (T=reshape(1:NC.x*NC.y, NC.x, NC.y),)\n    ndof    =   maximum(Num.T)\n    K       =   ExtendableSparseMatrix(ndof,ndof)\n    rhs     =   zeros(ndof)\n    # ------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"The linear system of equation is solve via the function Poisson2Dc!() for a constant thermal conductivity. The function updates the temperature field D.T with the solution. After solving the equation for each resolution, the corresponding test metrics are computed. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"    # Solve equation ---------------------------------------------------- #\n    Poisson2Dc!(D,NC,P,BC,Δ,K,rhs,Num)\n    # ------------------------------------------------------------------- #\n    ST.Tmax[k]      =   maximum(D.T[:])\n    ST.Tmean[k]     =   mean(D.T[:])\nend","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"After the resolution loop, a linear fit is applied to the mean and maximum temperature to extrapolate the theoretical solution at zero grid spacing.","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"# Linear fit ------------------------------------------------------------ #\ndf_max      =   DataFrame(x = ST.x, Tmax = ST.Tmax)\ndf_mean     =   DataFrame(x = ST.x, Tmean = ST.Tmean)\n# Fit linear models\nlinfitMAX   =   lm(@formula(Tmax ~ x), df_max)\nlinfitMEAN  =   lm(@formula(Tmean ~ x), df_mean)\n# Extract coefficients\n#coef1       =   coef(linfitMAX)\n#coef2       =   coef(linfitMEAN)\n# Calculate fitted values\nlinfit1     =   predict(linfitMAX)\nlinfit2     =   predict(linfitMEAN)\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"Finally, one can plot the maximum and mean temperature over the reciprocal resolution and the linear fit. ","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"# Plot solution --------------------------------------------------------- #\n# Subplot 1 ---\np = scatter(ST.x, ST.Tmean, marker=:circle, markersize=4,label=\"\",\n        xlabel=\"1/nx/ny\",ylabel=\"⟨T⟩\",title=\"Resolution Test\",\n        xaxis=:log,\n        layout=(2,1))\nplot!(p,ST.x, linfit2, color=\"black\", label=\"\", \n            linestyle=:dash, linewidth=2)\n## Add text for fitted minimum temperature\n#annotate!(p,1e-4, 121.8, \"T_{fit,mean} = $(coef2[1])\")\n\n# subplot 2 ---\nscatter!(p,ST.x, ST.Tmax, marker=:circle, markersize=4,label=\"\",\n        xlabel=\"1/nx/ny\",ylabel=\"T_{max}\",\n        subplot=2)\nplot!(p,ST.x, linfit1, color=\"black\", label=\"\", \n            linestyle=:dash, linewidth=2,subplot=2)\n\n# Show the plot\ndisplay(p)\nsavefig(\"./examples/DiffusionEquation/2D/Results/Poisson_ResTest.png\")\n# ----------------------------------------------------------------------- #","category":"page"},{"location":"man/examples/PoissonRestest/","page":"Poisson Problem (2D)","title":"Poisson Problem (2D)","text":"(Image: PP_rest_test)","category":"page"},{"location":"man/MomentumOneD/#Stokes-Equation-(1D)","page":"1D","title":"Stokes Equation (1D)","text":"","category":"section"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Before tackling the Stokes equation in two dimensions, we start with a simpler, one-dimensional problem: uniaxial Stokes flow in a horizontal channel, assuming a known horizontal pressure gradient. This setup provides a first-order approximation for flows in magma or subduction channels. The one-dimensional Stokes equation in the x-direction is expressed as:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"x-component","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\n0 = -fracpartialPpartialx + fracpartialtau_xypartialy\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"where P is the pressure [Pa], fracpartialpartial x_i denotes the partial derivative in the i-th direction, and tau_xy is the horizontal shear stress [Pa], defined by:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\ntau_xy = 2 eta dotvarepsilon_xy\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"with eta the viscosity [Pa·s] and dotvarepsilon_xy the shear strain-rate [1/s], given by:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\ndotvarepsilon_xy = frac12 fracpartialv_xpartialy\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Note: For the y-component of the Stokes equation, gravitational acceleration g_y must be included.","category":"page"},{"location":"man/MomentumOneD/#Discretization","page":"1D","title":"Discretization","text":"","category":"section"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"(Image: Stokes1D_Grid)","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Figure 1. Channel flow setup and finite difference grid. Left: Sketch of uniaxial channel flow driven by either a constant velocity at the top (v_x) and/or a horizontal pressure gradient left(fracDelta PDelta x = P_1 - P_0right), representing Couette, Poiseuille, or Couette-Poiseuille flow. Right: Finite difference grid with conservative gridding—viscosity is defined at vertices, and horizontal velocity is defined between them. The open circles at the top represent ghost nodes for horizontal velocity.","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"The finite difference grid employs a conservative scheme where velocity and viscosity are defined at staggered nodes. This ensures the horizontal shear stress is conserved across adjacent grid points, with stress values defined at the vertices. Such conservative gridding is essential when viscosity varies with depth. To build intuition, we first consider the simpler case of constant viscosity before addressing depth-dependent viscosity.","category":"page"},{"location":"man/MomentumOneD/#Constant-Viscosity","page":"1D","title":"Constant Viscosity","text":"","category":"section"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"In the case of constant viscosity, a conservative gridding is not required. Equation (1) simplifies to:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\n0 = -fracpartialPpartialx + etafracpartial^2v_xpartialy^2\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Applying a central difference approximation to the second derivative, and assuming a constant and known horizontal pressure gradient, this becomes:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialPpartialx = eta left( fracv_xj-1 - 2v_xj + v_xj+1Deltay^2 right)\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"which can be rewritten in a more compact form:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialPpartialx=av_xj-1+bv_xj+cv_xj+1 \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"where","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"a = c = fracetaDeltay^2quad textrmand quad b = -frac2etaDeltay^2","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"This results in a linear system of equations of the form:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nboldK cdot vecv_x = vecrhs\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"where boldK is a tridiagonal matrix, vecv_x is the vector of unknown horizontal velocites between the vertices, and vectextrhs is the known right-hand side defined by the pressure gradient and boundary velocities. ","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"For simplicity, no separate solver for the constant viscosity case is included in GeoModBox.jl. Instead, viscosity is always treated numerically as an array, even in isoviscous cases. For implementation details, refer to the source code.","category":"page"},{"location":"man/MomentumOneD/#Variable-Viscosity","page":"1D","title":"Variable Viscosity","text":"","category":"section"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"In the case of variable viscosity, Equation (1) becomes:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\n0 = -fracpartialPpartialx + fracpartialtau_xypartialy = -fracpartialPpartialx + fracpartialpartialyleft(etafracpartialv_xpartialyright)\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"The differential operators in Equation (8) are approximated using central finite differences. The shear stress tau_xy and viscosity eta are defined at the vertices, while the velocity v_x is defined at the centroids (the midpoints between adjacent vertices in 1D).","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Using a central difference approximation for the shear stress, Equation (8) becomes:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialPpartialx=fractau_xyj+1-tau_xyjDeltay textrmfor j = 1nc \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"or, in terms of the velocity:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialPpartialx=fraceta_j+1fracpartialv_xpartialyvert_j+1-eta_jfracpartialv_xpartialyvert_jDeltay textrmfor j = 1nc\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Approximating the velocity derivatives using central differences gives:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialPpartialx=fraceta_j+1fracv_xj+1-v_xjDeltay-eta_jfracv_xj-v_xj-1Deltayvert_jDeltay\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Note: The index j ranges from 1 to nc, where viscosity is defined on the vertices and velocity on the centroids.","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Rewriting the above in terms of the unknown velocities, the equation becomes:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialPpartialx=av_xj-1+bv_xj+cv_xj+1 \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"where","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\na = fraceta_jDeltay^2 quad \nb = -fraceta_j+eta_j+1Deltay^2 textrmand quad \nc = fraceta_j+1Deltay^2 \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"This again results in a linear system of equations with a tridiagonal coefficient matrix.","category":"page"},{"location":"man/MomentumOneD/#Boundary-Conditions","page":"1D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"To solve the equations, boundary conditions must be specified. For both Dirichlet and Neumann boundary conditions, the velocity values at the ghost nodes need to be defined. As with thermal boundary conditions, the ghost node velocities can be determined by assuming either a constant velocity at the boundary (Dirichlet) or a constant velocity gradient across the boundary (Neumann). The ghost node velocities are defined as:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Dirichlet Boundary Conditions","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Bottom","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nV_GS = 2V_BCS - v_x1\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Top","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nV_GN = 2V_BCN - v_xnc\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Neumann Boundary Conditions","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Bottom","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nV_GS = v_x1 - c_sDeltay\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Top","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nV_GN=v_xnc + c_NDeltay\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"where ","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nc_S = fracdv_xdyvert_S textrmand c_N=fracdv_xdyvert_N \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"are the velocity gradients across the boundary. ","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"To maintain a symmetric coefficient matrix, the coefficients at the centroids adjacent to the boundaries and the corresponding right-hand side (RHS) must be adjusted. The discretized equations at the bottom and top boundaries become:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Dirichlet Boundary Conditions","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Bottom","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nleft(b-aright)v_x1+cv_x2 = fracpartialPpartialx - 2aV_BCS\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Top","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nav_xnc-1+left(b-cright)v_xnx = fracpartialPpartialx - 2cV_BCN\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Neumann Boundary Conditions","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Bottom","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nleft(b+aright)v_x1+cv_x2 = fracpartialPpartialx + ac_SΔy\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Top","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nav_xnc-1+left(b+cright)v_xnx = fracPx - cc_NΔy\nendequation","category":"page"},{"location":"man/MomentumOneD/#Solution","page":"1D","title":"Solution","text":"","category":"section"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"There are different ways to solve the linear system of equations. The most convenient one is a direct solution using right division of the coefficient matrix by the right-hand side.","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Direct","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nv_x = boldK  rhs\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Similar to the thermal problem, the system can also be solved using the defect correction method. This becomes especially useful when the system is non-linear, as it allows one to iteratively reduce the residual.","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Defect Correction","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"The first step is to calculate the residual of the governing equation:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nR = -fracPx + fracτ_xyy\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"or in terms of the unknown horizontal velocity:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nR = -fracPx + boldK cdot v_x \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Assuming an initial guess for the horizontal velocity v_xi, the initial residual is:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nR_i = -fracPx + boldK_i cdot v_xi\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Now assume that the initial guess can be corrected to the exact solution by adding a correction term deltav_x. With some algebra:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\n0 = -fracPx + boldKleft(v_xi+ deltav_x right) = boldKcdot v_xi -fracPx + boldKcdot deltav_x = R_i + boldK cdot deltav_x\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Rearanging gives: ","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nR_i = -boldKcdotdeltav_x \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"so the correction term is:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\ndeltav_x = -boldK^-1R_i \nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Finally, the corrected solution is:","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"beginequation\nv_x^n = v_xi + deltav_x\nendequation","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"If the system is linear, this gives the solution in one step. For non-linear problems, this process must be iterated until the residual becomes sufficiently small.","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"For implementation details, see the source code.","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"An example of solving the channel flow using the defect correction method is provided in the examples.","category":"page"},{"location":"man/MomentumOneD/","page":"1D","title":"1D","text":"Solving the same problem using the direct method is part of the exercises.","category":"page"},{"location":"man/examples/Overview_Convection/#Thermal-convection","page":"Thermal convection","title":"Thermal convection","text":"","category":"section"},{"location":"man/examples/Overview_Convection/","page":"Thermal convection","title":"Thermal convection","text":"Thermal mantle convection is a perfect example on how to transport heat with both diffusion (especiall in the thermal boundary layers) and advection (mainly within the interior). ","category":"page"},{"location":"man/examples/Overview_Convection/","page":"Thermal convection","title":"Thermal convection","text":"Bottom \nInternally\nMixed Heated","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/#[05-2D-Heat-Diffusion-(transient,-sill)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/05_2D_Diffusion_TD_Sill_en.ipynb)","page":"05b - 2D Heat Diffusion (Sill)","title":"05 - 2D Heat Diffusion (transient, sill)","text":"","category":"section"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"This exercise investigates transient two-dimensional heat diffusion with a horizontally layered thermal anomaly (“sill”) at mid-depth. The setup uses a fixed surface temperature, a linear geotherm, and Neumann lateral boundaries; the sill starts hot and includes internal heat production. The case is useful for exploring the interplay between transient cooling and internal heating and how the system approaches thermal equilibrium.","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"The main objectives are:","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"Formulating and discretizing the transient 2D heat diffusion equation with internal heating,  \nImplementing explicit (Forward Euler) and implicit (Backward Euler) time integration,  \nApplying Dirichlet/Neumann boundary conditions via ghost nodes,  \nComparing stability constraints (explicit) versus unconditional stability and linear solves (implicit), and  \nVisualizing the evolving temperature field and simple diagnostics (e.g., vertical profiles, maximum temperature over time).","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"The evolution of the temperature field is illustrated in Figure 1. The vertical profiles and the maximum temperature over time are illustrated in Figure 2. ","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"(Image: Exercise05_1)  ","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"Figure 1. Time-dependent evolution of the two-dimensional temperature field with basal plume heating using the explicit scheme. ","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"(Image: Exercise_05_2)","category":"page"},{"location":"man/exercises/05_2D_Diffusion_TD_Sill/","page":"05b - 2D Heat Diffusion (Sill)","title":"05b - 2D Heat Diffusion (Sill)","text":"Figure 2. Temperature-Depth profiles over time and the evolution of the maximum temperature with time. ","category":"page"},{"location":"man/exercises/10_2D_Falling_Block_td/#[10-–-2D-Falling-Block-(time-dependent)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/10_2D_Falling_Block_td_en.ipynb)","page":"10 - 2D Falling Block (time-dep)","title":"10 – 2D Falling Block (time-dependent)","text":"","category":"section"},{"location":"man/exercises/10_2D_Falling_Block_td/","page":"10 - 2D Falling Block (time-dep)","title":"10 - 2D Falling Block (time-dep)","text":"This exercise extends the falling block problem to a time-dependent case with constant viscosity.   The problem couples the solution of the momentum conservation equation (Stokes system) with the advection equation, where density (or phase) is transported through the velocity field.  ","category":"page"},{"location":"man/exercises/10_2D_Falling_Block_td/","page":"10 - 2D Falling Block (time-dep)","title":"10 - 2D Falling Block (time-dep)","text":"The main objectives are:  ","category":"page"},{"location":"man/exercises/10_2D_Falling_Block_td/","page":"10 - 2D Falling Block (time-dep)","title":"10 - 2D Falling Block (time-dep)","text":"Setting up the model domain with a dense block embedded in a viscous medium under gravity,  \nDefining free-slip velocity boundary conditions on all sides,  \nAssembling the coefficient matrix for the Stokes system (constant viscosity → assembled once),  \nImplementing a time loop that in each step:  \nUpdates the right-hand side with the current density distribution,  \nSolves the Stokes system for velocity and pressure,  \nAdvects density (or phase) using different numerical schemes, including tracers,  \nRecomputes the time step and visualizes the solution,  \nProducing an animation of the sinking block over time.  ","category":"page"},{"location":"man/exercises/10_2D_Falling_Block_td/","page":"10 - 2D Falling Block (time-dep)","title":"10 - 2D Falling Block (time-dep)","text":"This problem demonstrates how to couple Stokes flow with advection of material properties, and how the choice of advection scheme affects the evolution of the solution.  ","category":"page"},{"location":"man/exercises/10_2D_Falling_Block_td/","page":"10 - 2D Falling Block (time-dep)","title":"10 - 2D Falling Block (time-dep)","text":"(Image: Exercise10)","category":"page"},{"location":"man/exercises/10_2D_Falling_Block_td/","page":"10 - 2D Falling Block (time-dep)","title":"10 - 2D Falling Block (time-dep)","text":"Figure 1. Time evolution of the sinking block in a viscous medium using the tracer advection method.  ","category":"page"},{"location":"man/exercises/08_1D_Stokes/#[08-–-1D-Stokes-Equation](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/08_1D_Stokes_en.ipynb)","page":"08 - 1D Stokes","title":"08 – 1D Stokes Equation","text":"","category":"section"},{"location":"man/exercises/08_1D_Stokes/","page":"08 - 1D Stokes","title":"08 - 1D Stokes","text":"This exercise focuses on solving the one-dimensional Stokes equation for a channel flow with both constant and depth-dependent viscosity. The problem setup allows direct comparison between the analytical solution and the numerical approximation, providing a way to test the accuracy of finite difference methods.  ","category":"page"},{"location":"man/exercises/08_1D_Stokes/","page":"08 - 1D Stokes","title":"08 - 1D Stokes","text":"The main objectives are:  ","category":"page"},{"location":"man/exercises/08_1D_Stokes/","page":"08 - 1D Stokes","title":"08 - 1D Stokes","text":"Deriving and discretizing the 1-D Stokes equation with finite difference operators,  \nDefining viscosity profiles (constant and logarithmically varying with depth),  \nImplementing Dirichlet and Neumann boundary conditions,  \nAssembling and solving the linear system of equations,  \nComparing numerical and analytical solutions,  \nVisualizing velocity profiles and the relative error.  ","category":"page"},{"location":"man/exercises/08_1D_Stokes/","page":"08 - 1D Stokes","title":"08 - 1D Stokes","text":"The resulting velocity distributions illustrate the difference between Couette and Couette–Poiseuille flow, and highlight the influence of variable viscosity on the channel flow solution.  ","category":"page"},{"location":"man/exercises/08_1D_Stokes/","page":"08 - 1D Stokes","title":"08 - 1D Stokes","text":"(Image: Exercise08)","category":"page"},{"location":"man/exercises/08_1D_Stokes/","page":"08 - 1D Stokes","title":"08 - 1D Stokes","text":"Figure 1. Solution of the 1-D Stokes problem. ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/#[11-–-2D-Thermal-Convection](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/11_2D_Thermal_Convection_en.ipynb)","page":"11 - 2D Thermal Convection","title":"11 – 2D Thermal Convection","text":"","category":"section"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"This exercise introduces 2-D thermal convection as an application of the three fundamental conservation laws:  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"Conservation of energy,  \nConservation of momentum, and  \nConservation of mass.  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"We focus on the isoviscous, bottom-heated setup, which serves as the simplest form of mantle convection. The problem demonstrates the interplay between advection and diffusion in heat transport, while density variations due to thermal expansion drive convective flow.  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"The main objectives are:  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"Understanding the governing equations for temperature, momentum, and mass conservation,  \nApplying the Boussinesq approximation to simplify the system,  \nIntroducing the Rayleigh number as the key nondimensional control parameter,  \nSetting up a finite-difference discretization of the model domain,  \nImplementing thermal and velocity boundary conditions,  \nSolving the coupled system in time, including advection and diffusion of temperature,  \nAnalyzing convection patterns for different Rayleigh numbers (Ra = 10^4 10^5 10^6),  \nComputing diagnostic measures such as the Nusselt number and RMS velocity.  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"The results illustrate how increasing the Rayleigh number strengthens convection, changes the scale of plumes and slabs, and increases the overall vigor of the flow.  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"(Image: Exercise11a)","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"Figure 1. Isoviscous, bottom-heated thermal convection for Ra = 10^6 with a resolution of 150x50. The initial condition is a linearly increasing temperature profile with an elliptical anomaly at the top. Thermal boundary conditions are fixed temperature at the top and bottom and zero heat flux at the sides. All velocity boundary conditions are free slip. Heat diffusion is solved using the Crank–Nicolson method, the Stokes equation using the defect correction method, and temperature advection with the semi-Lagrangian method. Models run until a steady state is reached or up to a maximum of 8000 iterations.  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"(Image: Exercise11b)","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"Figure 2. Time series of the surface Nusselt number and the root mean square velocity. For details on how these diagnostics are calculated, see the exercise.  ","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"(Image: Exercise11c)","category":"page"},{"location":"man/exercises/11_2D_Thermal_Convection/","page":"11 - 2D Thermal Convection","title":"11 - 2D Thermal Convection","text":"Figure 3. Variation in the root mean square velocity with numerical iterations. Empirically, a tolerance of 10^-15 was chosen to define steady state. Low-Ra cases typically reach steady state in fewer than 3000 iterations.  ","category":"page"},{"location":"man/examples/ViscousInclusion/#[Viscous-Inclusion](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/StokesEquation/2D/ViscousInclusion.jl)","page":"Viscous Inclusion","title":"Viscous Inclusion","text":"","category":"section"},{"location":"man/examples/ViscousInclusion/","page":"Viscous Inclusion","title":"Viscous Inclusion","text":"...tba...","category":"page"},{"location":"man/examples/ForwardEuler_DC/#[Diffusion-Equation-(Forward-Euler)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/ForwardEuler.jl)","page":"Forward Euler (2D)","title":"Diffusion Equation (Forward Euler)","text":"","category":"section"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"This is a straight forward example to solve the conductive part of the 2-D temperature conservation equation using the forward euler method. The focus lies on the","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"application of the expanded temperature field and boundary conditions,\nimplementation of the analytical solution (ExactFieldSolution.jl), and\napplication of the forward Euler method. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"The example calculates the numerical solution of a transient diffusion of an initial, Gaussian 2-D temperature distribution. The peak T0 of the Gaussian anomaly is located in the center of the model domain with a certain width sigma. The diffusion is controlled by the diffusion coefficient (thermal conductivity) K. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"The accuracy of the numerical solution is checked with its analytical solution. The results are plotet for ever nout time step in a single figure. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"using GeoModBox.HeatEquation.TwoD\nusing Plots","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"Now, one needs to define the geometry and the numerical parameters. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"# Spatial domain\nxlim = (min=-1/2, max=1/2)\nylim = (min=-1/2, max=1/2)\nnc   = (x=100, y=100)\nnv   = (x=nc.x+1, y=nc.y+1)\nnc   = (x=nc.x+0, y=nc.y+0)\nnv   = (x=nv.x+0, y=nv.y+0)\nΔ    = (x=(xlim.max-xlim.min)/nc.x, y=(ylim.max-ylim.min)/nc.y)\nx    = (c=LinRange(xlim.min+Δ.x/2, xlim.max-Δ.x/2, nc.x), v=LinRange(xlim.min, xlim.max, nv.x))\ny    = (c=LinRange(ylim.min+Δ.y/2, ylim.max-Δ.y/2, nc.y), v=LinRange(ylim.min, ylim.max, nv.y))","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"Now, one needs to define the time parameters. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"# Time domain\nnt   = 400\nt    = 0.\nnout = 10 ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"In the following, all fields and parameter arrays are initialized. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"# Primitive variables\nT_ex  = zeros(nc.x+2, nc.y+2)\nT     = zeros(nc...)\nTe    = zeros(nc...)\n# Derived fields\n∂T    = (∂x=zeros(nv.x, nc.x), ∂y=zeros(nc.x, nv.x))\nq     = ( x=zeros(nv.x, nc.x),  y=zeros(nc.x, nv.x))\n# Material parameters\nρ     = zeros(nc...)\nCp    = zeros(nc...)\nk     = ( x=zeros(nv.x, nc.x), y=zeros(nc.x, nv.x))","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"Here, the boundary conditions are defined, using a named tuple BC. The tuple contains the type (Dirichlet or Neumann) and the value of each boundary (North, East, South, West). ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"# Boundary conditions\nBC   = (\n    type = (W=:Dirichlet, E=:Dirichlet, S=:Dirichlet, N=:Dirichlet),\n    val  = (W=zeros(nc.y), E=zeros(nc.y), S=zeros(nc.x), N=zeros(nc.x)))","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"As initial condition, the analytical solution for the time t=0 is choosen. Also, the values for the physical parameter are assigned. Here, all parameters are non-dimensional. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"# Initial conditions\nAnalyticalSolution2D!(T, x.c, y.c, t,(T0=1.0,K=1e-6,σ=0.1))\n@. k.x = 1e-6 \n@. k.y = 1e-6\n@. ρ   = 1.0\n@. Cp  = 1.0\nΔt = max(Δ...)^2/(maximum(k.x)/minimum(ρ)/minimum(Cp))/4.1","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"Now, the time loop can start. Within the time loop, the time, the analytical solution and the value for the boundaries is calculated within the following. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"# Time integration\n@views for it=1:nt\n    t += Δt\n    # Exact solution on cell centroids\n    AnalyticalSolution2D!(Te, x.c, y.c, t,(T0=1.0,K=1e-6,σ=0.1))\n    # Exact solution on cell boundaries\n    BoundaryConditions2D!(BC, x.c, y.c, t,(T0=1.0,K=1e-6,σ=0.1))","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"In the following, the temperature conservation equation is solved using the forward euler method. That is, the temperature at the new time step is completly calculated from the temperature field of the old time step. To solve the equations for the centroids along the boundaries of the model domain, one needs to update the temperature of the ghost nodes according to the defined boundary condition. Once, the temperature is defined on the expanded grid, one can calculate the temperature flux using central finite differences and the given heat flux. The central differences of the heat flux determine the temperature a the new time step. For more details on the finit difference discretization of the temperature conservation equation, please refere to the documentation.","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"    @. T_ex[2:end-1,2:end-1] = T \n    @. T_ex[  1,2:end-1] = (BC.type.W==:Dirichlet) * (2*BC.val.W - T_ex[    2,2:end-1])# + (BC.type.W==:Neumann) * (T_ex[    2,2:end-1] - Δ.x/k.x[  1,:]*BC.val.W)\n    @. T_ex[end,2:end-1] = (BC.type.E==:Dirichlet) * (2*BC.val.E - T_ex[end-1,2:end-1])# + (BC.type.E==:Neumann) * (T_ex[end-1,2:end-1] + Δ.x/k.x[end,:]*BC.val.E)\n    @. T_ex[2:end-1,  1] = (BC.type.S==:Dirichlet) * (2*BC.val.S - T_ex[2:end-1,    2])# + (BC.type.S==:Neumann) * (T_ex[2:end-1,    2] - Δ.y/k.y[:,  1]*BC.val.S)\n    @. T_ex[2:end-1,end] = (BC.type.N==:Dirichlet) * (2*BC.val.N - T_ex[2:end-1,end-1])# + (BC.type.N==:Neumann) * (T_ex[2:end-1,end-1] - Δ.y/k.y[:,end]*BC.val.N)\n    @. ∂T.∂x = (T_ex[2:end,2:end-1] - T_ex[1:end-1,2:end-1])/Δ.x\n    @. ∂T.∂y = (T_ex[2:end-1,2:end] - T_ex[2:end-1,1:end-1])/Δ.y\n    @. q.x   = -k.x * ∂T.∂x\n    @. q.y   = -k.y * ∂T.∂y\n    @. T    -= Δt *( (q.x[2:end,:] - q.x[1:end-1,:])/Δ.x + (q.y[:,2:end] - q.y[:,1:end-1])/Δ.y )","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"Finally, the analytical and numerical solution and its error are plotted for each nout time step. ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"    # Visualisation\n    if mod(it, nout)==0\n        p1 = plot(aspect_ratio=1, xlims=(xlim...,), ylims=(ylim...,))\n        p1 = heatmap!(x.c, y.c, Te', title=\"Analytics\")\n        p2 = plot(aspect_ratio=1, xlims=(xlim...,), ylims=(ylim...,))\n        p2 = heatmap!(x.c, y.c, T', title=\"Numerics\")\n        p3 = plot(aspect_ratio=1, xlims=(xlim...,), ylims=(ylim...,))\n        p3 = heatmap!(x.c, y.c, (abs.(T-Te))', title=\"Error\")\n        display(plot(p1, p2, p3, layout=(2,2)))\n    end\nend","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"(Image: FE2DDiff) ","category":"page"},{"location":"man/examples/ForwardEuler_DC/","page":"Forward Euler (2D)","title":"Forward Euler (2D)","text":"Figure 1. Final plot for the forward Euler solution.","category":"page"},{"location":"man/examples/InternallyHeatedConvection/#[Internally-Heated-Convection](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/MixedHeatedConvection/InternallyHeated.jl)","page":"Internally Heated","title":"Internally Heated Convection","text":"","category":"section"},{"location":"man/examples/InternallyHeatedConvection/","page":"Internally Heated","title":"Internally Heated","text":"... tba ...","category":"page"},{"location":"man/examples/BackwardEuler_DC/#[Diffusion-Equation-(Backward-Euler)](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/examples/DiffusionEquation/2D/BackwardEuler.jl)","page":"Backward Euler (2D)","title":"Diffusion Equation (Backward Euler)","text":"","category":"section"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"This is a straight forward example to solve the conductive part of the 2-D temperature conservation equation using the defect correction method. The focus lies on the","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"application of the expanded temperature field and boundary conditions,\nset up of the coefficient matrix and residual vector,\nimplementation of the analytical solution (ExactFieldSolution.jl), and\napplication of the defect correction method. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"The example calculates the numerical solution of a transient diffusion of an initial, Gaussian 2-D temperature distribution. The peak T0 of the Gaussian anomaly is located in the center of the model domain with a certain width sigma. The diffusion is controlled by the diffusion coefficient (thermal conductivity) K. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"The accuracy of the numerical solution is checked with its analytical solution. The results are plotet for ever nout time step in a single figure. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"First one needs to load the required packages: ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"using GeoModBox.HeatEquation.TwoD\nusing ExactFieldSolutions, LinearAlgebra, Plots, Printf","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"Now, one needs to define the geometry and the numerical parameters. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"# Spatial domain\nxlim = (min=-1/2, max=1/2)\nylim = (min=-1/2, max=1/2)\nnc   = (x=100, y=100)\nnv   = (x=nc.x+1, y=nc.y+1)\nnc   = (x=nc.x+0, y=nc.y+0)\nnv   = (x=nv.x+0, y=nv.y+0)\nΔ    = (x=(xlim.max-xlim.min)/nc.x, y=(ylim.max-ylim.min)/nc.y)\nx    = (c=LinRange(xlim.min+Δ.x/2, xlim.max-Δ.x/2, nc.x), v=LinRange(xlim.min, xlim.max, nv.x))\ny    = (c=LinRange(ylim.min+Δ.y/2, ylim.max-Δ.y/2, nc.y), v=LinRange(ylim.min, ylim.max, nv.y))","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"Now, one needs to define the time parameters and parameters for the solution iteration. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"# Time domain\nnt   = 500\nt    = 0.\nnout = 10 \n# Iterations\nniter = 10\nϵ     = 1e-10","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"In the following, all fields and parameter arrays are initialized. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"# Primitive variables\nT_ex  = zeros(nc.x+2, nc.y+2)\nT     = zeros(nc...)\nT0    = zeros(nc...)\nTe    = zeros(nc...)\n# Derived fields\n∂T    = (∂x=zeros(nv.x, nc.x), ∂y=zeros(nc.x, nv.x))\nq     = (x=zeros(nv.x, nc.x), y=zeros(nc.x, nv.x))\n# Material parameters\nρ     = zeros(nc...)\nCp    = zeros(nc...)\nk     = (x=zeros(nv.x, nc.x), y=zeros(nc.x, nv.x))\n# Residuals\nR     = zeros(nc...)","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"Here, the boundary conditions are defined, using a named tuple BC. The tuple contains the type (Dirichlet or Neumann) and the value of each boundary (North, East, South, West). Additionally, the array for the numbering of the equation is initialized. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"# Boundary conditions\nBC   = (\n    type = (W=:Dirichlet, E=:Dirichlet, S=:Dirichlet, N=:Dirichlet),\n    # type = (W=:Neumann, E=:Neumann, S=:Neumann, N=:Neumann),\n    val  = (W=zeros(nc.y), E=zeros(nc.y), S=zeros(nc.x), N=zeros(nc.x)))\n# Numbering \nNum    = (T=reshape(1:nc.x*nc.y, nc.x, nc.y),)","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"As initial condition, the analytical solution for the time t=0 is choosen. Also, the values for the physical parameter are assigned. Here, all parameters are non-dimensional. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"# Initial conditions\nAnalyticalSolution2D!(T, x.c, y.c, t,(T0=1.0,K=1e-6,σ=0.1))\n@. k.x = 1e-6 \n@. k.y = 1e-6\n@. ρ   = 1.0\n@. Cp  = 1.0\nΔt = max(Δ...)^2/(maximum(k.x)/minimum(ρ)/minimum(Cp))/4.1","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"Now, the time loop can start. Within the time loop, the time, the analytical solution and the value for the boundaries is calculated within the following. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"# Time integration Loop\nfor it=1:nt\n    @printf(\"Time step = %05d\\n\", it)\n    t += Δt\n    @. T0 = T\n    # Exact solution on cell centroids\n    AnalyticalSolution2D!(Te, x.c, y.c, t,(T0=1.0,K=1e-6,σ=0.1))\n    # Exact solution on cell boundaries\n    BoundaryConditions2D!(BC, x.c, y.c, t,(T0=1.0,K=1e-6,σ=0.1))","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"The temperature conservation equation is solved in the following using the defect correction method. Therefore, one first needs to determine the residual (ComputeResiduals2D!()) of the system of equations, assuming an initial guess. If the residual is small enough (ϵ), the solution iteration is stopped. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"Note: The iteration is only necessary, if the system is non-linear. Here, the final solution is found after one iteration. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"For more details on the defect correction method, please refer to the documentation.","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"    # Iteration loop\n    for iter=1:niter\n        # Evaluate residual\n        ComputeResiduals2D!(R, T, T_ex, T0, ∂T, q, ρ, Cp, k, BC, Δ, Δt)\n        @printf(\"||R|| = %1.4e\\n\", norm(R)/length(R))\n        norm(R)/length(R) < ϵ ? break : nothing\n        # Assemble linear system\n        K  = AssembleMatrix2D(ρ, Cp, k, BC, Num, nc, Δ, Δt)\n        # Solve for temperature correction: Cholesky factorisation\n        Kc = cholesky(K.cscmatrix)\n        # Solve for temperature correction: Back substitutions\n        δT = -(Kc\\R[:])\n        # Update temperature\n        @. T += δT[Num.T]\n    end","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"Finally, the analytical and numerical solution and its error are plotted for each nout time step. ","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"    # Visualisation\n    if mod(it, nout)==0\n        p1 = plot(aspect_ratio=1, xlims=(xlim...,), ylims=(ylim...,))\n        p1 = heatmap!(x.c, y.c, Te', title=\"Analytics\")\n        p2 = plot(aspect_ratio=1, xlims=(xlim...,), ylims=(ylim...,))\n        p2 = heatmap!(x.c, y.c, T', title=\"Numerics\")\n        p3 = plot(aspect_ratio=1, xlims=(xlim...,), ylims=(ylim...,))\n        p3 = heatmap!(x.c, y.c, (abs.(T-Te))', title=\"Error\")\n        display(plot(p1, p2, p3, layout=(2,2)))\n    end\nend","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"(Image: BE2DDiff)","category":"page"},{"location":"man/examples/BackwardEuler_DC/","page":"Backward Euler (2D)","title":"Backward Euler (2D)","text":"Figure 1. Final plot for the backward Euler solution using the defect correction method. ","category":"page"},{"location":"man/exercises/07_2D_Energy_Equation/#[07-2D-Energy-Equation](https://github.com/GeoSci-FFM/GeoModBox.jl/blob/main/exercises/07_2D_Energy_Equation_en.ipynb)","page":"07 - 2D Energy Conservation","title":"07 - 2D Energy Equation","text":"","category":"section"},{"location":"man/exercises/07_2D_Energy_Equation/","page":"07 - 2D Energy Conservation","title":"07 - 2D Energy Conservation","text":"This exercise focuses on solving the two-dimensional energy conservation equation, which combines both advection and diffusion processes. The main objectives are:","category":"page"},{"location":"man/exercises/07_2D_Energy_Equation/","page":"07 - 2D Energy Conservation","title":"07 - 2D Energy Conservation","text":"Understand the combined transport of temperature by advection and diffusion,  \nLearn to apply different numerical schemes for advection (upwind, semi-Lagrangian, tracers, etc.) and diffusion (explicit, implicit, Crank–Nicolson, ADI, defect correction),  \nDefine different initial conditions for the temperature field (e.g., circular anomaly, Gaussian distribution, block anomaly, linear gradient),  \nExplore prescribed velocity fields (rigid-body rotation, convection cell),  \nVisualize and analyze the transient evolution of temperature fields and generate animations.","category":"page"},{"location":"man/exercises/07_2D_Energy_Equation/","page":"07 - 2D Energy Conservation","title":"07 - 2D Energy Conservation","text":"The example below shows the evolution of an initial linear temperature field in a constant shear cell velocity field (Figure 1).","category":"page"},{"location":"man/exercises/07_2D_Energy_Equation/","page":"07 - 2D Energy Conservation","title":"07 - 2D Energy Conservation","text":"(Image: Exercise07)","category":"page"},{"location":"man/exercises/07_2D_Energy_Equation/","page":"07 - 2D Energy Conservation","title":"07 - 2D Energy Conservation","text":"Figure 1. Evolution of a 2-D temperature field unsing the Crank-Nicholson approach for diffusion and the semi-lagrangian method for advection.","category":"page"},{"location":"man/DiffOneD/#Temperature-Equation-(1D)","page":"1D","title":"Temperature Equation (1D)","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"In one dimension, the diffusive component of the temperature equation is expressed as follows, assuming only radiogenic heat sources:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartial Tpartial t = -fracpartial q_xpartial x + rho H\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"By incorporating Fourier’s law and allowing for spatially variable thermal properties, the equation becomes:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartial Tpartial t = fracpartialpartial x k_x fracpartial Tpartial x + rho H \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Assuming constant thermal properties, Equation (2) simplifies to:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartial Tpartial t = kappa fracpartial^2 Tpartial x^2 + fracQrho c_p\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where kappa = krhoc_p is the thermal diffusivity [m²/s], and Q = rho H is the volumetric heat production rate [W/m³].  ","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Equation (3) is classified as a parabolic partial differential equation (PDE), which can be solved numerically given appropriate initial and boundary conditions.","category":"page"},{"location":"man/DiffOneD/#Discretization-and-Numerical-Schemes","page":"1D","title":"Discretization and Numerical Schemes","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"To solve Equation (3) numerically, the spatial domain must be discretized, assigning physical parameters to their corresponding grid locations.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Note: Although thermal conductivity is currently assumed to be constant, a conservative gridding approach is employed to ensure physical consistency. In this scheme, temperature T is defined at cell centers (centroids), while heat flux q is defined at cell interfaces (vertices).","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"(Image: 1DDiscretization)","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Figure 1. 1D Discretization. Conservative finite difference grid used to solve the 1D diffusive part of the temperature equation. Temperature is defined at centroids, while heat flux is defined at vertices. Ghost nodes are introduced to implement Dirichlet and Neumann boundary conditions.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The example script Heat1Ddiscretization.jl demonstrates various numerical schemes for solving the diffusive part of the temperature equation, including explicit, implicit, Crank–Nicolson, and defect correction methods. Below, these well-known schemes are briefly described and their respective strengths and limitations highlighted.","category":"page"},{"location":"man/DiffOneD/#Explicit-Finite-Difference-Scheme-(FTCS;-Forward-Euler)","page":"1D","title":"Explicit Finite Difference Scheme (FTCS; Forward Euler)","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"A fundamental and intuitive approach to solving the 1D heat diffusion equation is the Forward in Time and Centered in Space (FTCS) scheme, implemented in an explicit manner.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"This method approximates the continuous PDE on a discrete grid and converges to the analytical solution as the spatial (Delta x) and temporal (Delta t) resolutions are refined. Its main advantages are simplicity and computational efficiency.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"However, the FTCS scheme is conditionally stable. Its stability is governed by the heat diffusion stability criterion, which can be derived via Von Neumann analysis. This assesses how numerical perturbations grow or decay over time.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"For a uniform grid, the stability condition is:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nDelta t  fracDeltax^22 kappa\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Consequently, the maximum allowable time step is constrained by the spatial resolution.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Discretizing Equation (3) with the FTCS scheme gives:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1 - T_i^n Delta t = kappa fracT_i-1^n - 2T_i^n + T_i+1^nDeltax^2 + fracQ_i^nrho c_p\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where  i is the spatial grid index, n is the time step index, Delta x is the grid spacing, Delta t is the time step, and Q_i^n is the heat production rate at node i and time n.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Solving for T_i^n+1:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nT_i^n+1 = T_i^n + a left(T_i-1^n - 2T_i^n + T_i+1^n right) + fracQ_i^n Delta trho c_p \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where a = frackappa Delta tDelta x^2.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Equation (6) is solved for all interior nodes at each time step, assuming initial and boundary conditions are specified.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"For implementation details, see the source code.","category":"page"},{"location":"man/DiffOneD/#Boundary-Conditions","page":"1D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Boundary conditions are implemented using ghost nodes. Here, the two most common thermal boundary conditions are considered: Dirichlet and Neumann.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Dirichlet Boundary Condition","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The Dirichlet condition specifies a fixed temperature at the boundary. The temperature at the left (West) and right (East) ghost nodes is given by:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nT_GW = 2T_BCW - T_1\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nT_GE = 2T_BCE - T_nc\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where  T_BCW and T_BCE are the prescribed boundary temperatures, T_1 and T_nc are the temperatures at the first and last interior centroids, T_GW and T_GE are the ghost node temperatures on the west and east boundaries, and nc is the number of centroids.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Neumann Boundary Condition","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The Neumann condition specifies a fixed gradient (e.g., a heat flux or temperature gradient) at the boundary. The ghost node temperatures are defined as:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nT_GW = T_1 - c_W Deltax\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nT_GE = T_nc + c_E Deltax\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"with:  ","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nleft c_W = fracpartialTpartialx rightvert_W textrmand left c_E = fracpartialTpartialx rightvert_E \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where c_W and c_E are the prescribed temperature gradients on the west and east boundaries, respectively.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"These ghost node definitions are substituted into the numerical scheme to consistently enforce the boundary conditions at each time step.","category":"page"},{"location":"man/DiffOneD/#Implicit-Scheme-(Backward-Euler)","page":"1D","title":"Implicit Scheme (Backward Euler)","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The fully implicit finite difference scheme, also known as the Backward Euler method, is unconditionally stable, allowing time steps larger than those permitted by the diffusion stability criterion.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"In 1D, the temperature equation becomes:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1-T_i^nDelta t = kappa fracT_i-1^n+1-2T_i^n+1+T_i+1^n+1Deltax^2 + fracQ_i^nrho c_p\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where  i is the spatial index, n and n+1 are the current and next time steps, Delta t is the time step, and Delta x is the spatial grid spacing. ","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Rearranging into known (right-hand side) and unknown (left-hand side) terms yields a linear system:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n-a T_i-1^n+1 + left(2a + b right) T_i^n+1 - a T_i+1^n+1 = b T_i^n + fracQ_i^nrho c_p\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"with  a = dfrackappaDelta x^2 and b = dfrac1Delta t.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"This equation results in a tridiagonal system of the form:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nmathbfA cdot vecx = vectextrhs\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where mathbfA is the coefficient matrix (with three non-zero diagonals), vecx is the unknown temperature vector at time n+1, and vectextrhs is the known right-hand side.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The coefficients are arranged to match the matrix structure used in the defect correction method, preserving modularity.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Note: While the implicit method is unconditionally stable, very large time steps may still yield inaccurate results, particularly for resolving small-scale thermal gradients.","category":"page"},{"location":"man/DiffOneD/#Boundary-Conditions-2","page":"1D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The temperature at ghost nodes is defined as before (see Equations (7)-(10)). However, to maintain symmetry in the coefficient matrix and ensure consistent discretization near boundaries, both the matrix coefficients and the right-hand side must be modified for the nodes adjacent to the boundaries.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Dirichlet Boundary Condition","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"West boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nleft(3 a + bright) T_1^n+1 - a T_2^n+1 = b T_1^n + 2 a T_BCW\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"East boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n-a T_nc-1^n+1 + left(3 a + bright) T_nc^n+1  = b T_nc^n + 2 a T_BCE \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Neumann Boundary Condition","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"West boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nleft(a + bright) T_1^n+1 - a T_2^n+1 = b T_1^n - a c_W Deltax\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"East boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n-a T_nc-1^n+1 + left(a + bright) T_nc^n+1  = b T_nc^n + a c_E Deltax \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where  T_BCW, T_BCE are the prescribed boundary temperatures, c_W, c_E are the prescribed temperature gradients at the west and east boundaries, and nc is the number of centroids.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"These adjustments ensure that the boundary conditions are enforced consistently while preserving the symmetry and stability of the implicit solver.","category":"page"},{"location":"man/DiffOneD/#Defect-Correction-Method","page":"1D","title":"Defect Correction Method","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The defect correction method is an iterative scheme that progressively reduces the residual of the diffusive part of the temperature equation using a correction term. If the system is linear, one iteration is sufficient to obtain the exact solution.","category":"page"},{"location":"man/DiffOneD/#Theory","page":"1D","title":"Theory","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The diffusive part of the temperature equation, in implicit form, can be written as:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nmathbfK cdot T - b = R \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where  mathbfK is the coefficient matrix, T is the temperature at the new time step, b is a known term that includes contributions from the previous time step and internal heat sources, and R is the residual (or defect).","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Given an initial temperature guess T_i, the residual is:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nR_i = mathbfK cdot T_i - b\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"To reduce the residual, a correction delta T is defined such that:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n0 = mathbfK left(T_i + deltaT right) - b = mathbfK T_i - b + mathbfK deltaT = R_i + mathbfK deltaT\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Rearranging gives: ","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nR_i = -mathbfK deltaT \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"and hence: ","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\ndeltaT = -mathbfK^-1 R_i \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Thus, the updated solution becomes: ","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nT_i+1 = T_i + delta T\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"In the linear case, this yields the exact solution in a single step. For nonlinear problems, the process is repeated iteratively until the residual is sufficiently small.","category":"page"},{"location":"man/DiffOneD/#Coefficient-Matrix","page":"1D","title":"Coefficient Matrix","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The matrix mathbfK can be derived from the discretized form of the temperature equation:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracpartialTpartialt - kappa fracpartial^2Tpartialx^2 = R \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"which discretizes to: ","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1-T_i^nDeltat - kappa fracT_i-1^n+1 - 2 T_i^n+1 + T_i+1^n+1Deltax^2 = R\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"or equivalently:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n-a T_i-1^n+1 + left(2 a + b right) T_i^n+1 - a T_i+1^n+1 - b T_i^n = R \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\na = frackappaDeltax^2 textrmand  b = frac1Deltat \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"This structure defines the coefficients in mathbfK.","category":"page"},{"location":"man/DiffOneD/#Boundary-Conditions-3","page":"1D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"As in the implicit FTCS method, the coefficients in mathbfK must be adjusted for centroids adjacent to the boundaries (see Equations (14)–(17)). However, the right-hand side vector b remains unchanged during these modifications.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"This makes the defect correction method efficient and modular, especially when reusing the same matrix structure across iterations or solver variants.","category":"page"},{"location":"man/DiffOneD/#Crank-Nicolson-approach-(CNA)","page":"1D","title":"Crank-Nicolson approach (CNA)","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The fully implicit FTCS method is unconditionally stable but only first-order accurate in time. To improve temporal accuracy while retaining stability, the Crank-Nicolson scheme can be used. This method employs a time-centered (implicit) discretization and is second-order accurate in time.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"In one dimension, the Crank-Nicolson discretization of the diffusive part of the temperature equation (Equation (3)) becomes:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nfracT_i^n+1 - T_i^nDelta t = frackappa2frac(T_i-1^n+1-2T_i^n+1+T_i+1^n+1)+(T_i-1^n-2T_i^n+T_i+1^n)Deltax^2 \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Rearranging into known and unknown terms yields a linear system of the form:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n-aT_i-1^n+1 + left(b+2aright)T_i^n+1 - a T_i+1^n+1 = aT_i-1^n + left(b-2aright)T_i^n + a T_i+1^n\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"a = frackappa2Deltax^2quad textrmandquad b = frac1Deltat","category":"page"},{"location":"man/DiffOneD/#Boundary-Conditions-4","page":"1D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"To obtain a symmetric coefficient matrix, both the matrix and the right-hand side vector must be modified at the boundaries. The equations for centroids adjacent to the boundaries are:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Dirichlet Boundary Conditions","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"West boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nleft(b + 3 a right) T_1^n+1 - a T_2^n+1 = left( b - 3 a right) T_1^n + a T_2^n + 4 a T_BCW\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"East boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n-a T_nc-1^n+1 + left(b + 3 a right) T_nc^n+1 = a T_nc-1^n + left( b - 3 a right) T_nc^n + 4 a T_BCE\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Neumann Boundary Conditions","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"West boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nleft(b+aright)T_1^n+1 - a T_2^n+1 = left(b-aright)T_1^n + a T_2 - 2ac_W Deltax\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"East boundary","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\n-a T_nc-1^n+1 + left(b+aright)T_nc^n+1  = a T_nc-1^n + left(b-aright)T_nc^n + 2ac_E Deltax\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The resulting coefficient matrix remains tridiagonal, preserving computational efficiency. However, memory requirements increase with finer spatial resolution due to the larger size of the linear system, making this method more memory-intensive.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"For implementation details, refer to the source code.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"","category":"page"},{"location":"man/DiffOneD/#Temperature-Field-Management","page":"1D","title":"Temperature Field Management","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"For the explicit solver and the defect correction method, the full temperature field—including ghost nodes—is used to evaluate the temperature equation. The old temperature field is assigned to the centroids of the extended grid to compute the new temperature.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"For the implicit methods (Backward Euler, Crank-Nicolson), the current temperature at the centroids is assigned to the right-hand side vector. The coefficient matrix is then assembled, and the new temperature is computed by solving the resulting linear system.","category":"page"},{"location":"man/DiffOneD/#Summary","page":"1D","title":"Summary","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"While the explicit FTCS scheme is simple and efficient for small time steps, implicit methods like Backward Euler and Crank-Nicolson are preferred for their unconditional stability. The Crank-Nicolson scheme further improves accuracy with its second-order time discretization. The defect correction method provides a flexible framework for both linear and nonlinear problems, allowing for iterative refinement when needed.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"","category":"page"},{"location":"man/DiffOneD/#Variable-Thermal-Parameters","page":"1D","title":"Variable Thermal Parameters","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"To solve the diffusive component of the 1D temperature equation with spatially variable thermal properties, a conservative finite difference scheme is employed. In this formulation, temperature is defined at centroids, while heat flux and thermal conductivity are defined at vertices (see Figure 1).","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"The governing equation is:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nrho c_p fracpartialTpartialt = fracpartialpartialyleft(k fracpartialTpartialyright) + rho H\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where rho is the density [kg/m³], c_p is the specific heat capacity [J/kg/K], T is the temperature [K], t is the time [s], k is the thermal conductivity [W/m/K],  H is the internal heat generation rate per unit mass [W/kg], and y is the vertical coordinate (depth) [m]","category":"page"},{"location":"man/DiffOneD/#Discretization","page":"1D","title":"Discretization","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"In a conservative scheme, the vertical conductive heat flux q_y is defined on vertices, as:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nleft q_ym = -k_m fracpartial Tpartial yrightvert_m textrmfor m = 1nv \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where n_v is the number of vertices.","category":"page"},{"location":"man/DiffOneD/#Explicit-Finite-Difference-Formulation","page":"1D","title":"Explicit Finite Difference Formulation","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Using the above discretization, the time evolution of temperature at each centroid is computed from:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nrho_j c_pj fracT_j^n+1 - T_j^nDeltat = -fracq_yj+1^n - q_yj^n Deltay + rho_j H_j textrmfor j = 1nc \nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where  T is evaluated at centroids, q_y and k are evaluated at vertices, Delta t is the time step, and Delta y is the spatial grid resolution.","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Substituting the expression for q_y gives:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nrho_j c_pj fracT_j^n+1 - T_j^nDeltat = frac k_j+1 fracT_j+1^n - T_j^nDeltay - k_j fracT_j^n - T_j-1^nDeltay Deltay + rho_j H_j\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"Rewriting this into an explicit update formula for T_j^n+1:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\nT_j^n+1 = ak_jT_j-1^n + left(1-aleft(k_j+1+k_jright)right)T_j^n + ak_j+1T_j+1^n + fracH_jDeltatc_pj\nendequation","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"where:","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"beginequation\na = fracDeltatDeltay^2 rho c_p_j\nendequation","category":"page"},{"location":"man/DiffOneD/#Boundary-Conditions-5","page":"1D","title":"Boundary Conditions","text":"","category":"section"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"For centroids adjacent to the boundaries, ghost nodes are used to evaluate the temperature gradient consistently with the chosen thermal boundary condition (Dirichlet or Neumann). These ghost node values are computed according to equations (7)–(10).","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"","category":"page"},{"location":"man/DiffOneD/","page":"1D","title":"1D","text":"For implementation details, refer to the source code.","category":"page"},{"location":"man/MomentumMain/#Momentum-Equation","page":"General","title":"Momentum Equation","text":"","category":"section"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"On geological time scales, Earth's mantle and lithosphere behave like a fluid that moves and deforms in response to forces. In general, three major force types influence fluid motion: inertial, surface, and body (volumetric) forces. A commonly used expression to describe such motion is:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\nrho fracD v_iDt = fracpartialsigma_ijpartialx_j + rho g_i\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"where  rho is the density [kg/m³],  v_i is the velocity component [m/s] in direction i,  sigma_ij is the Cauchy stress tensor [Pa],  g_i is the gravitational acceleration [m/s²] in direction i, and  fracDDt is the Lagrangian (material) time derivative, expressed in Eulerian form as: ","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\nfracDDt = fracpartialpartialt + v_jfracpartialpartialx_j\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"The Cauchy stress tensor is commonly decomposed as:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\nsigma_ij = -fracpartialPpartialx_i + fracpartialtau_ijpartialx_j\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"where P is the total pressure (including dynamic and hydrostatic components), and tau_ij is the deviatoric stress tensor.","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Substituting into the momentum equation and expanding the material derivative yields the Navier–Stokes equation in Eulerian form:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\nrho left(fracpartialv_ipartialt + v_jfracpartialv_ipartialx_jright) = -fracpartialPpartialx_i + fracpartialtau_ijpartialx_j + rho g_i\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"with Einstein summation implied over repeated indices.","category":"page"},{"location":"man/MomentumMain/#Constitutive-Relation","page":"General","title":"Constitutive Relation","text":"","category":"section"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"To solve the momentum equation, we must define the rheology of the material. For a purely viscous fluid, the deviatoric stress is related to the strain rate by:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\ntau_ij = 2 eta cdot dotvarepsilon_ij\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"where  eta is the dynamic viscosity [Pa·s] and  dotvarepsilon_ij the strain rate tensor [1/s], given by: ","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\ndotvarepsilon_ij = frac12 left(fracpartialv_ipartialx_j + fracpartialv_jpartialx_iright)\nendequation","category":"page"},{"location":"man/MomentumMain/#Stokes-Equation","page":"General","title":"Stokes Equation","text":"","category":"section"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"In the mantle, inertial forces are typically negligible compared to viscous and gravitational forces. Under this Stokes flow approximation, the momentum equation simplifies to:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\n0 = -fracpartialPpartialx_i + fracpartialtau_ijpartialx_j + rho g_i\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Using the constitutive relation, we obtain:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\n0 = -fracpartialPpartialx_i + fracpartialpartialx_j eta left(fracpartialv_ipartialx_j + fracpartialv_jpartialx_iright) + rho g_i\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Assuming constant viscosity simplifies this further to:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\n0 = -fracpartialPpartialx_i + eta left(fracpartial^2v_ipartialx_j^2 + fracpartial^2v_jpartialx_i^2right) + rho g_i\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Solving this system requires discretization of both the x- and y-components of the momentum equation, as well as the mass conservation equation. For implementation details, refer to the 1D and 2D momentum equation documentation.","category":"page"},{"location":"man/MomentumMain/#Continuum-Equation","page":"General","title":"Continuum Equation","text":"","category":"section"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"The Stokes system provides two equations for the three unknowns v_x, v_y, and P. To close the system, we use the continuity equation. Assuming an incompressible fluid (Boussinesq approximation), the mass conservation equation becomes:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"beginequation\nfracpartialv_ipartialx_i = 0\nendequation","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Together, the momentum and continuity equations allow solving for v_x, v_y, and P.","category":"page"},{"location":"man/MomentumMain/#Examples","page":"General","title":"Examples","text":"","category":"section"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"The following examples demonstrate the application of the Stokes equations:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"1D channel flow with constant and depth-dependent viscosity  \n2D falling block benchmark  \n2D falling block with constant viscosity (defect correction)  \n2D falling block with variable viscosity (defect correction)  \n2D viscous inclusion problem  \n2D Rayleigh–Taylor instability benchmark","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Examples of coupled temperature–momentum systems (i.e., convection models) using operator splitting include:","category":"page"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Mixed heated convection models","category":"page"},{"location":"man/MomentumMain/#Exercises","page":"General","title":"Exercises","text":"","category":"section"},{"location":"man/MomentumMain/","page":"General","title":"General","text":"Steady-state, isoviscous 2D falling block  \nTime-dependent, isoviscous 2D falling block\n2D thermal convection (isoviscous)  \nScaled 2D thermal convection  \nBlankenbach benchmark with resolution study","category":"page"},{"location":"man/Examples/#Examples-and-Benchmarks","page":"General","title":"Examples and Benchmarks","text":"","category":"section"},{"location":"man/Examples/","page":"General","title":"General","text":"This section provides various one- and two-dimensional examples and benchmark problems for each of the governing equations. The examples demonstrate how to implement different numerical solvers, apply scaling, and evaluate the advantages and limitations of various finite difference schemes.","category":"page"},{"location":"man/Examples/","page":"General","title":"General","text":"By clicking on the title of each page, you will be directed to the corresponding Julia script in the examples directory.","category":"page"},{"location":"man/Examples/","page":"General","title":"General","text":"Note: In GeoModBox.jl, thermal and kinematic boundary conditions are explicitly implemented within the solvers. The absolute values at ghost nodes are computed based on the values provided in the boundary condition tuple BC. Each tuple specifies the type (either Dirichlet or Neumann) and the corresponding value at each boundary.   For constant velocity boundary conditions, additional values must be defined in val for the boundary nodes (e.g., BC.val.vxW, BC.val.vxE). These additional values are required to directly solve the momentum equation and update the right-hand side of the linear system. Furthermore, these values must be assigned to the initial boundary nodes of the respective velocity fields.   For more details on the implementation of constant velocity boundaries, refer to the documentation of the viscous inclusion example or the initial velocity setup.","category":"page"},{"location":"man/Examples/","page":"General","title":"General","text":"Note: By default, the results of time-dependent examples in GeoModBox.jl are stored as GIF animations. To visualize solutions at specific time steps without generating a GIF, set the parameter save_fig = 0. In this case, individual plots are not saved, so caution is advised when running problems that require multiple time step iterations.","category":"page"},{"location":"man/Examples/","page":"General","title":"General","text":"Note: Some examples use named tuples to define constants and parameters. Alternatively, mutable structures can be used—particularly useful when parameters need to be modified after initialization (e.g., for scaling purposes). A full transition from named tuples to mutable structures is planned for future versions of GeoModBox.jl.","category":"page"},{"location":"man/AdvectMain/#Advection-Equation","page":"General","title":"Advection Equation","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"In cases where the material remains stationary (e.g., during the thermal evolution of intrusions or within a non-deforming lithosphere), it is sufficient to solve only the diffusive term of the energy equation. However, in most geodynamical contexts, material is in motion, and physical properties such as temperature, density, or composition must be advected with the flow.","category":"page"},{"location":"man/AdvectMain/#Eulerian-and-Lagrangian-Formulations","page":"General","title":"Eulerian and Lagrangian Formulations","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"Advection describes the transport of scalar or vector quantities due to the motion of a fluid. Depending on the reference frame, the governing equations take different forms.","category":"page"},{"location":"man/AdvectMain/#Eulerian-Formulation","page":"General","title":"Eulerian Formulation","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"In a fixed (Eulerian) reference frame, the local rate of change of temperature, for example, is governed by the advection equation:","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"beginequation\nfracpartial Tpartial t = - vecv cdot nablaT\nendequation","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"where vecv is the velocity vector and T is the temperature field. Eulerian formulations are solved on a fixed grid using schemes that aim to balance accuracy, stability, and computational efficiency. GeoModBox.jl supports several such schemes appropriate for a range of applications.","category":"page"},{"location":"man/AdvectMain/#Lagrangian-Formulation","page":"General","title":"Lagrangian Formulation","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"In a moving (Lagrangian) reference frame, which follows individual fluid particles, temperature evolution is described by the material (substantial) derivative:","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"beginequation\nfracDTDt\nendequation","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"which relates to the Eulerian description via:","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"beginequation\nfracDTDt = fracpartial Tpartial t + vecv cdot nablaT\nendequation","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"In the Lagrangian frame, advection reduces to solving a system of ordinary differential equations (ODEs) for particle trajectories:","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"beginequation\nfracDx_iDt = v_i\nendequation","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"where x_i are the coordinates and v_i the corresponding velocity components.","category":"page"},{"location":"man/AdvectMain/#Discretization-Schemes","page":"General","title":"Discretization Schemes","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"Although simple in form, the advection equation is challenging to solve numerically. The choice of discretization and interpolation schemes can introduce numerical artifacts such as diffusion, dispersion, or instability.","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"To promote clarity and modularity, GeoModBox.jl employs an operator-splitting strategy. This approach decouples the advective and diffusive terms of the temperature conservation equation and solves them sequentially. First, the advective (convective) term is solved, followed by the diffusive term. The latter is handled using the schemes described in the Diffusion Equation documentation. ","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"Note: The energy equation can also be solved for diffusion and advection simultaneously using combined schemes. Interestingly, the Forward in Time and Centered in Space (FTCS) scheme—although unstable for pure advection—can exhibit numerical stability due to diffusion when both processes are active.","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"For the advection term, GeoModBox.jl includes the following numerical schemes:","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"Upwind  \nLax  \nStaggered leapfrog  \nSemi-Lagrangian  \nPassive tracer/marker method","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"The first four schemes work for any scalar field defined at centroids, including ghost nodes, and use centroid-defined velocity fields.","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"Passive tracers can be used to advect temperature or phase identifiers. When advecting phase IDs, the tracer data must also include material parameters such as viscosity or density. These values are interpolated either to centroids or to vertices, depending on the quantity (e.g., viscosity at vertices). The tracer or marker-in-cell (MIC) method tracks material properties along particle paths and solves the associated ODE system using standard time integration methods, including:","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"Euler method  \nRunge–Kutta methods","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"The GeoModBox.jl focuses on the tracer advection using a fourth-order Runge–Kutta method, with velocities from the staggered grid.","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"An important consideration in advection is the preservation of amplitude and shape, especially in problems involving rigid body rotation. Numerical diffusion and interpolation artifacts can significantly affect the solution quality depending on the chosen scheme, making the selection of an appropriate method crucial.","category":"page"},{"location":"man/AdvectMain/#Advection-Stability-Criterion","page":"General","title":"Advection Stability Criterion","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"To avoid spurious oscillations in the advected field between adjacent grid points, the Courant–Friedrichs–Lewy (CFL) criterion must be satisfied:","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"beginequation\nDeltat le fractextrmminleft(DeltaxDeltayright)textrmmaxleft(v_xv_yright)\nendequation","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"where Deltax and Deltay are the spatial resolutions in the x- and y-directions, and v_x, v_y are the corresponding velocity components.","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"This criterion ensures that no particle is advected a greater distance than the minimum grid spacing within one time step.","category":"page"},{"location":"man/AdvectMain/#Examples","page":"General","title":"Examples","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"2-D advection with constant velocity field  \nResolution test of 2-D advection","category":"page"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"See the examples documentation for further details.","category":"page"},{"location":"man/AdvectMain/#Exercises","page":"General","title":"Exercises","text":"","category":"section"},{"location":"man/AdvectMain/","page":"General","title":"General","text":"1-D Gaussian or block anomaly advection  \n2-D coupled advection-diffusion","category":"page"}]
}
